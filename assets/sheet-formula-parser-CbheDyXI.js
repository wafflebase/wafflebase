var Ta=Object.defineProperty;var ga=(l,a,p)=>a in l?Ta(l,a,{enumerable:!0,configurable:!0,writable:!0,value:p}):l[a]=p;var Q=(l,a,p)=>ga(l,typeof a!="symbol"?a+"":a,p);import{g as ya}from"./vendor-react-Bg6UneQK.js";var rr={},Ai={},xo;function Na(){if(xo)return Ai;xo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Ai,"__esModule",{value:!0}),Ai}var mi={},_o;function va(){if(_o)return mi;_o=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(mi,"__esModule",{value:!0}),mi}var nr={},Si,Ao;function be(){if(Ao)return Si;Ao=1;function l(a,p){if(!a)throw new Error(p||"Assertion failed")}return l.ok=l,l.equal=function(a,p,x){if(a!=p)throw new Error(x||`Expected ${p}, got ${a}`)},l.strictEqual=function(a,p,x){if(a!==p)throw new Error(x||`Expected ${p}, got ${a}`)},Si=l,Si}var Ie={},mo;function z(){if(mo)return Ie;mo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Ie,"__esModule",{value:!0}),Ie.SuppressWarnings=Ie.Override=Ie.Nullable=Ie.NotNull=void 0;function l(h,s,r){}Ie.NotNull=l;function a(h,s,r){}Ie.Nullable=a;function p(h,s,r){}Ie.Override=p;function x(h){return(s,r,n)=>{}}return Ie.SuppressWarnings=x,Ie}var Ei={},So;function $t(){return So||(So=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.IntStream=void 0,function(a){a.EOF=-1,a.UNKNOWN_SOURCE_NAME="<unknown>"}(l.IntStream||(l.IntStream={}))}(Ei)),Ei}var Eo;function Ca(){if(Eo)return nr;Eo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=nr&&nr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(nr,"__esModule",{value:!0}),nr.ANTLRInputStream=void 0;const a=be(),p=z(),x=$t();let h=class{constructor(r){this.p=0,this.data=r,this.n=r.length}reset(){this.p=0}consume(){if(this.p>=this.n)throw a(this.LA(1)===x.IntStream.EOF),new Error("cannot consume EOF");this.p<this.n&&this.p++}LA(r){return r===0?0:r<0&&(r++,this.p+r-1<0)||this.p+r-1>=this.n?x.IntStream.EOF:this.data.charCodeAt(this.p+r-1)}LT(r){return this.LA(r)}get index(){return this.p}get size(){return this.n}mark(){return-1}release(r){}seek(r){if(r<=this.p){this.p=r;return}for(r=Math.min(r,this.n);this.p<r;)this.consume()}getText(r){let n=r.a,t=r.b;t>=this.n&&(t=this.n-1);let o=t-n+1;return n>=this.n?"":this.data.substr(n,o)}get sourceName(){return this.name?this.name:x.IntStream.UNKNOWN_SOURCE_NAME}toString(){return this.data}};return l([p.Override],h.prototype,"consume",null),l([p.Override],h.prototype,"LA",null),l([p.Override],h.prototype,"index",null),l([p.Override],h.prototype,"size",null),l([p.Override],h.prototype,"mark",null),l([p.Override],h.prototype,"release",null),l([p.Override],h.prototype,"seek",null),l([p.Override],h.prototype,"getText",null),l([p.Override],h.prototype,"sourceName",null),l([p.Override],h.prototype,"toString",null),nr.ANTLRInputStream=h,nr}var ir={},He={},_n={},To;function Yt(){return To||(To=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=_n&&_n.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(l,"__esModule",{value:!0}),l.ATNState=void 0;const p=z();let x=class Mi{constructor(){this.stateNumber=Mi.INVALID_STATE_NUMBER,this.ruleIndex=0,this.epsilonOnlyTransitions=!1,this.transitions=[],this.optimizedTransitions=this.transitions}getStateNumber(){return this.stateNumber}get nonStopStateNumber(){return this.getStateNumber()}hashCode(){return this.stateNumber}equals(s){return s instanceof Mi?this.stateNumber===s.stateNumber:!1}get isNonGreedyExitState(){return!1}toString(){return String(this.stateNumber)}getTransitions(){return this.transitions.slice(0)}get numberOfTransitions(){return this.transitions.length}addTransition(s,r){if(this.transitions.length===0)this.epsilonOnlyTransitions=s.isEpsilon;else if(this.epsilonOnlyTransitions!==s.isEpsilon)throw this.epsilonOnlyTransitions=!1,new Error("ATN state "+this.stateNumber+" has both epsilon and non-epsilon transitions.");this.transitions.splice(r!==void 0?r:this.transitions.length,0,s)}transition(s){return this.transitions[s]}setTransition(s,r){this.transitions[s]=r}removeTransition(s){return this.transitions.splice(s,1)[0]}get onlyHasEpsilonTransitions(){return this.epsilonOnlyTransitions}setRuleIndex(s){this.ruleIndex=s}get isOptimized(){return this.optimizedTransitions!==this.transitions}get numberOfOptimizedTransitions(){return this.optimizedTransitions.length}getOptimizedTransition(s){return this.optimizedTransitions[s]}addOptimizedTransition(s){this.isOptimized||(this.optimizedTransitions=new Array),this.optimizedTransitions.push(s)}setOptimizedTransition(s,r){if(!this.isOptimized)throw new Error("This ATNState is not optimized.");this.optimizedTransitions[s]=r}removeOptimizedTransition(s){if(!this.isOptimized)throw new Error("This ATNState is not optimized.");this.optimizedTransitions.splice(s,1)}};a([p.Override],x.prototype,"hashCode",null),a([p.Override],x.prototype,"equals",null),a([p.Override],x.prototype,"toString",null),l.ATNState=x,function(h){h.INVALID_STATE_NUMBER=-1}(x=l.ATNState||(l.ATNState={}))}(_n)),_n}var Ti={},go;function Te(){return go||(go=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.ATNStateType=void 0,function(a){a[a.INVALID_TYPE=0]="INVALID_TYPE",a[a.BASIC=1]="BASIC",a[a.RULE_START=2]="RULE_START",a[a.BLOCK_START=3]="BLOCK_START",a[a.PLUS_BLOCK_START=4]="PLUS_BLOCK_START",a[a.STAR_BLOCK_START=5]="STAR_BLOCK_START",a[a.TOKEN_START=6]="TOKEN_START",a[a.RULE_STOP=7]="RULE_STOP",a[a.BLOCK_END=8]="BLOCK_END",a[a.STAR_LOOP_BACK=9]="STAR_LOOP_BACK",a[a.STAR_LOOP_ENTRY=10]="STAR_LOOP_ENTRY",a[a.PLUS_LOOP_BACK=11]="PLUS_LOOP_BACK",a[a.LOOP_END=12]="LOOP_END"}(l.ATNStateType||(l.ATNStateType={}))}(Ti)),Ti}var Ve={},An={},yo;function Qt(){if(yo)return An;yo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(An,"__esModule",{value:!0}),An.RecognitionException=void 0;let l=class extends Error{constructor(p,x,h,s){super(s),this._offendingState=-1,this._recognizer=p,this.input=x,this.ctx=h,p&&(this._offendingState=p.state)}get offendingState(){return this._offendingState}setOffendingState(p){this._offendingState=p}get expectedTokens(){if(this._recognizer)return this._recognizer.atn.getExpectedTokens(this._offendingState,this.ctx)}get context(){return this.ctx}get inputStream(){return this.input}getOffendingToken(p){if(!(p&&p!==this._recognizer))return this.offendingToken}setOffendingToken(p,x){p===this._recognizer&&(this.offendingToken=x)}get recognizer(){return this._recognizer}};return An.RecognitionException=l,An}var Ye={},mn={},Xe={},No;function Zt(){if(No)return Xe;No=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Xe&&Xe.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o},a=Xe&&Xe.__param||function(h,s){return function(r,n){s(r,n,h)}};Object.defineProperty(Xe,"__esModule",{value:!0}),Xe.Transition=void 0;const p=z();let x=class{constructor(s){if(s==null)throw new Error("target cannot be null.");this.target=s}get isEpsilon(){return!1}get label(){}};return x.serializationNames=["INVALID","EPSILON","RANGE","RULE","PREDICATE","ATOM","ACTION","SET","NOT_SET","WILDCARD","PRECEDENCE"],l([p.NotNull],x.prototype,"target",void 0),x=l([a(0,p.NotNull)],x),Xe.Transition=x,Xe}var vo;function Xi(){if(vo)return mn;vo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(mn,"__esModule",{value:!0}),mn.AbstractPredicateTransition=void 0;const l=Zt();let a=class extends l.Transition{constructor(x){super(x)}};return mn.AbstractPredicateTransition=a,mn}var or={},We={},sr={},gi={},Co;function xe(){return Co||(Co=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.MurmurHash=void 0,function(a){function x(t=0){return t}a.initialize=x;function h(t,o){o==null?o=0:typeof o=="string"?o=n(o):typeof o=="object"&&(o=o.hashCode());let d=o;return d=Math.imul(d,3432918353),d=d<<15|d>>>17,d=Math.imul(d,461845907),t=t^d,t=t<<13|t>>>19,t=Math.imul(t,5)+3864292196,t&4294967295}a.update=h;function s(t,o){return t=t^o*4,t=t^t>>>16,t=Math.imul(t,2246822507),t=t^t>>>13,t=Math.imul(t,3266489909),t=t^t>>>16,t}a.finish=s;function r(t,o=0){let e=x(o),i=0;for(let u of t)e=h(e,u),i++;return e=s(e,i),e}a.hashCode=r;function n(t){let o=t.length;if(o===0)return 0;let e=0;for(let i=0;i<o;i++){let u=t.charCodeAt(i);e=(e<<5>>>0)-e+u,e|=0}return e}}(l.MurmurHash||(l.MurmurHash={}))}(gi)),gi}var ur={},Oo;function qe(){if(Oo)return ur;Oo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ur&&ur.__decorate||function(x,h,s,r){var n=arguments.length,t=n<3?h:r===null?r=Object.getOwnPropertyDescriptor(h,s):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")t=Reflect.decorate(x,h,s,r);else for(var e=x.length-1;e>=0;e--)(o=x[e])&&(t=(n<3?o(t):n>3?o(h,s,t):o(h,s))||t);return n>3&&t&&Object.defineProperty(h,s,t),t};Object.defineProperty(ur,"__esModule",{value:!0}),ur.ObjectEqualityComparator=void 0;const a=z();let p=class{hashCode(h){return h==null?0:h.hashCode()}equals(h,s){return h==null?s==null:h.equals(s)}};return p.INSTANCE=new p,l([a.Override],p.prototype,"hashCode",null),l([a.Override],p.prototype,"equals",null),ur.ObjectEqualityComparator=p,ur}var Do;function Oa(){if(Do)return sr;Do=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=sr&&sr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(sr,"__esModule",{value:!0}),sr.DefaultEqualityComparator=void 0;const a=z(),p=xe(),x=qe();let h=class{hashCode(r){return r==null?0:typeof r=="string"||typeof r=="number"?p.MurmurHash.hashCode([r]):x.ObjectEqualityComparator.INSTANCE.hashCode(r)}equals(r,n){return r==null?n==null:typeof r=="string"||typeof r=="number"?r===n:x.ObjectEqualityComparator.INSTANCE.equals(r,n)}};return h.INSTANCE=new h,l([a.Override],h.prototype,"hashCode",null),l([a.Override],h.prototype,"equals",null),sr.DefaultEqualityComparator=h,sr}var bo;function Jt(){if(bo)return We;bo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=We&&We.__decorate||function(o,e,i,u){var c=arguments.length,f=c<3?e:u===null?u=Object.getOwnPropertyDescriptor(e,i):u,A;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")f=Reflect.decorate(o,e,i,u);else for(var d=o.length-1;d>=0;d--)(A=o[d])&&(f=(c<3?A(f):c>3?A(e,i,f):A(e,i))||f);return c>3&&f&&Object.defineProperty(e,i,f),f},a=We&&We.__param||function(o,e){return function(i,u){e(i,u,o)}};Object.defineProperty(We,"__esModule",{value:!0}),We.Array2DHashSet=void 0;const p=be(),x=Oa(),h=z(),s=xe(),r=16,n=.75;let t=class Jn{constructor(e,i=r){if(this.n=0,this.threshold=Math.floor(r*n),e instanceof Jn){this.comparator=e.comparator,this.buckets=e.buckets.slice(0);for(let u=0;u<this.buckets.length;u++){let c=this.buckets[u];c&&(this.buckets[u]=c.slice(0))}this.n=e.n,this.threshold=e.threshold}else this.comparator=e||x.DefaultEqualityComparator.INSTANCE,this.buckets=this.createBuckets(i)}getOrAdd(e){return this.n>this.threshold&&this.expand(),this.getOrAddImpl(e)}getOrAddImpl(e){let i=this.getBucket(e),u=this.buckets[i];if(!u)return u=[e],this.buckets[i]=u,this.n++,e;for(let c of u)if(this.comparator.equals(c,e))return c;return u.push(e),this.n++,e}get(e){if(e==null)return e;let i=this.getBucket(e),u=this.buckets[i];if(u){for(let c of u)if(this.comparator.equals(c,e))return c}}getBucket(e){return this.comparator.hashCode(e)&this.buckets.length-1}hashCode(){let e=s.MurmurHash.initialize();for(let i of this.buckets)if(i!=null)for(let u of i){if(u==null)break;e=s.MurmurHash.update(e,this.comparator.hashCode(u))}return e=s.MurmurHash.finish(e,this.size),e}equals(e){return e===this?!0:!(e instanceof Jn)||e.size!==this.size?!1:this.containsAll(e)}expand(){let e=this.buckets,i=this.buckets.length*2,u=this.createBuckets(i);this.buckets=u,this.threshold=Math.floor(i*n);let c=this.size;for(let f of e)if(f)for(let A of f){let d=this.getBucket(A),_=this.buckets[d];_||(_=[],this.buckets[d]=_),_.push(A)}p(this.n===c)}add(e){return this.getOrAdd(e)===e}get size(){return this.n}get isEmpty(){return this.n===0}contains(e){return this.containsFast(this.asElementType(e))}containsFast(e){return e==null?!1:this.get(e)!=null}*[Symbol.iterator](){yield*this.toArray()}toArray(){const e=new Array(this.size);let i=0;for(let u of this.buckets)if(u!=null)for(let c of u){if(c==null)break;e[i++]=c}return e}containsAll(e){if(e instanceof Jn){let i=e;for(let u of i.buckets)if(u!=null)for(let c of u){if(c==null)break;if(!this.containsFast(this.asElementType(c)))return!1}}else for(let i of e)if(!this.containsFast(this.asElementType(i)))return!1;return!0}addAll(e){let i=!1;for(let u of e)this.getOrAdd(u)!==u&&(i=!0);return i}clear(){this.buckets=this.createBuckets(r),this.n=0,this.threshold=Math.floor(r*n)}toString(){if(this.size===0)return"{}";let e="{",i=!0;for(let u of this.buckets)if(u!=null)for(let c of u){if(c==null)break;i?i=!1:e+=", ",e+=c.toString()}return e+="}",e}toTableString(){let e="";for(let i of this.buckets){if(i==null){e+=`null
`;continue}e+="[";let u=!0;for(let c of i)u?u=!1:e+=" ",c==null?e+="_":e+=c.toString();e+=`]
`}return e}asElementType(e){return e}createBuckets(e){return new Array(e)}};return l([h.NotNull],t.prototype,"comparator",void 0),l([h.Override],t.prototype,"hashCode",null),l([h.Override],t.prototype,"equals",null),l([h.Override],t.prototype,"add",null),l([h.Override],t.prototype,"size",null),l([h.Override],t.prototype,"isEmpty",null),l([h.Override],t.prototype,"contains",null),l([a(0,h.Nullable)],t.prototype,"containsFast",null),l([h.Override],t.prototype,Symbol.iterator,null),l([h.Override],t.prototype,"toArray",null),l([h.Override],t.prototype,"containsAll",null),l([h.Override],t.prototype,"addAll",null),l([h.Override],t.prototype,"clear",null),l([h.Override],t.prototype,"toString",null),l([h.SuppressWarnings("unchecked")],t.prototype,"asElementType",null),l([h.SuppressWarnings("unchecked")],t.prototype,"createBuckets",null),We.Array2DHashSet=t,We}var lr={},Ro;function ii(){if(Ro)return lr;Ro=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=lr&&lr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(lr,"__esModule",{value:!0}),lr.ArrayEqualityComparator=void 0;const a=z(),p=xe(),x=qe();let h=class{hashCode(r){return r==null?0:p.MurmurHash.hashCode(r,0)}equals(r,n){if(r==null)return n==null;if(n==null||r.length!==n.length)return!1;for(let t=0;t<r.length;t++)if(!x.ObjectEqualityComparator.INSTANCE.equals(r[t],n[t]))return!1;return!0}};return h.INSTANCE=new h,l([a.Override],h.prototype,"hashCode",null),l([a.Override],h.prototype,"equals",null),lr.ArrayEqualityComparator=h,lr}var Ce={},Po;function Xt(){if(Po)return Ce;Po=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Ce,"__esModule",{value:!0}),Ce.toCharArray=Ce.toMap=Ce.equals=Ce.join=Ce.escapeWhitespace=void 0;function l(s,r){return r?s.replace(/ /,"Â·"):s.replace(/\t/,"\\t").replace(/\n/,"\\n").replace(/\r/,"\\r")}Ce.escapeWhitespace=l;function a(s,r){let n="",t=!0;for(let o of s)t?t=!1:n+=r,n+=o;return n}Ce.join=a;function p(s,r){return s===r?!0:s===void 0||r===void 0?!1:s.equals(r)}Ce.equals=p;function x(s){let r=new Map;for(let n=0;n<s.length;n++)r.set(s[n],n);return r}Ce.toMap=x;function h(s){if(typeof s=="string"){let r=new Uint16Array(s.length);for(let n=0;n<s.length;n++)r[n]=s.charCodeAt(n);return r}else return s.toCharArray()}return Ce.toCharArray=h,Ce}var Lo;function fn(){return Lo||(Lo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=or&&or.__decorate||function(u,c,f,A){var d=arguments.length,_=d<3?c:A===null?A=Object.getOwnPropertyDescriptor(c,f):A,m;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")_=Reflect.decorate(u,c,f,A);else for(var S=u.length-1;S>=0;S--)(m=u[S])&&(_=(d<3?m(_):d>3?m(c,f,_):m(c,f))||_);return d>3&&_&&Object.defineProperty(c,f,_),_},p=or&&or.__param||function(u,c){return function(f,A){c(f,A,u)}};Object.defineProperty(l,"__esModule",{value:!0}),l.SemanticContext=void 0;const x=Jt(),h=ii(),s=xe(),r=z(),n=qe(),t=Xt();function o(u){let c;for(let f of u){if(c===void 0){c=f;continue}c.compareTo(f)<0&&(c=f)}return c}function e(u){let c;for(let f of u){if(c===void 0){c=f;continue}c.compareTo(f)>0&&(c=f)}return c}let i=class Pe{static get NONE(){return Pe._NONE===void 0&&(Pe._NONE=new Pe.Predicate),Pe._NONE}evalPrecedence(c,f){return this}static and(c,f){if(!c||c===Pe.NONE)return f;if(f===Pe.NONE)return c;let A=new Pe.AND(c,f);return A.opnds.length===1?A.opnds[0]:A}static or(c,f){if(!c)return f;if(c===Pe.NONE||f===Pe.NONE)return Pe.NONE;let A=new Pe.OR(c,f);return A.opnds.length===1?A.opnds[0]:A}};l.SemanticContext=i,function(u){function A(g){let T=[];for(let N=0;N<g.length;N++){let y=g[N];y instanceof u.PrecedencePredicate&&(T.push(y),g.splice(N,1),N--)}return T}class d extends u{constructor(T=-1,N=-1,y=!1){super(),this.ruleIndex=T,this.predIndex=N,this.isCtxDependent=y}eval(T,N){let y=this.isCtxDependent?N:void 0;return T.sempred(y,this.ruleIndex,this.predIndex)}hashCode(){let T=s.MurmurHash.initialize();return T=s.MurmurHash.update(T,this.ruleIndex),T=s.MurmurHash.update(T,this.predIndex),T=s.MurmurHash.update(T,this.isCtxDependent?1:0),T=s.MurmurHash.finish(T,3),T}equals(T){return T instanceof d?this===T?!0:this.ruleIndex===T.ruleIndex&&this.predIndex===T.predIndex&&this.isCtxDependent===T.isCtxDependent:!1}toString(){return"{"+this.ruleIndex+":"+this.predIndex+"}?"}}a([r.Override],d.prototype,"eval",null),a([r.Override],d.prototype,"hashCode",null),a([r.Override],d.prototype,"equals",null),a([r.Override],d.prototype,"toString",null),u.Predicate=d;class _ extends u{constructor(T){super(),this.precedence=T}eval(T,N){return T.precpred(N,this.precedence)}evalPrecedence(T,N){if(T.precpred(N,this.precedence))return u.NONE}compareTo(T){return this.precedence-T.precedence}hashCode(){let T=1;return T=31*T+this.precedence,T}equals(T){return T instanceof _?this===T?!0:this.precedence===T.precedence:!1}toString(){return"{"+this.precedence+">=prec}?"}}a([r.Override],_.prototype,"eval",null),a([r.Override],_.prototype,"evalPrecedence",null),a([r.Override],_.prototype,"compareTo",null),a([r.Override],_.prototype,"hashCode",null),a([r.Override],_.prototype,"equals",null),a([r.Override],_.prototype,"toString",null),u.PrecedencePredicate=_;class m extends u{}u.Operator=m;let S=class ei extends m{constructor(T,N){super();let y=new x.Array2DHashSet(n.ObjectEqualityComparator.INSTANCE);T instanceof ei?y.addAll(T.opnds):y.add(T),N instanceof ei?y.addAll(N.opnds):y.add(N),this.opnds=y.toArray();let O=A(this.opnds),F=e(O);F&&this.opnds.push(F)}get operands(){return this.opnds}equals(T){return this===T?!0:T instanceof ei?h.ArrayEqualityComparator.INSTANCE.equals(this.opnds,T.opnds):!1}hashCode(){return s.MurmurHash.hashCode(this.opnds,40363613)}eval(T,N){for(let y of this.opnds)if(!y.eval(T,N))return!1;return!0}evalPrecedence(T,N){let y=!1,O=[];for(let w of this.opnds){let M=w.evalPrecedence(T,N);if(y=y||M!==w,M==null)return;M!==u.NONE&&O.push(M)}if(!y)return this;if(O.length===0)return u.NONE;let F=O[0];for(let w=1;w<O.length;w++)F=u.and(F,O[w]);return F}toString(){return t.join(this.opnds,"&&")}};a([r.Override],S.prototype,"operands",null),a([r.Override],S.prototype,"equals",null),a([r.Override],S.prototype,"hashCode",null),a([r.Override],S.prototype,"eval",null),a([r.Override],S.prototype,"evalPrecedence",null),a([r.Override],S.prototype,"toString",null),S=a([p(0,r.NotNull),p(1,r.NotNull)],S),u.AND=S;let E=class ti extends m{constructor(T,N){super();let y=new x.Array2DHashSet(n.ObjectEqualityComparator.INSTANCE);T instanceof ti?y.addAll(T.opnds):y.add(T),N instanceof ti?y.addAll(N.opnds):y.add(N),this.opnds=y.toArray();let O=A(this.opnds),F=o(O);F&&this.opnds.push(F)}get operands(){return this.opnds}equals(T){return this===T?!0:T instanceof ti?h.ArrayEqualityComparator.INSTANCE.equals(this.opnds,T.opnds):!1}hashCode(){return s.MurmurHash.hashCode(this.opnds,486279973)}eval(T,N){for(let y of this.opnds)if(y.eval(T,N))return!0;return!1}evalPrecedence(T,N){let y=!1,O=[];for(let w of this.opnds){let M=w.evalPrecedence(T,N);if(y=y||M!==w,M===u.NONE)return u.NONE;M&&O.push(M)}if(!y)return this;if(O.length===0)return;let F=O[0];for(let w=1;w<O.length;w++)F=u.or(F,O[w]);return F}toString(){return t.join(this.opnds,"||")}};a([r.Override],E.prototype,"operands",null),a([r.Override],E.prototype,"equals",null),a([r.Override],E.prototype,"hashCode",null),a([r.Override],E.prototype,"eval",null),a([r.Override],E.prototype,"evalPrecedence",null),a([r.Override],E.prototype,"toString",null),E=a([p(0,r.NotNull),p(1,r.NotNull)],E),u.OR=E}(i=l.SemanticContext||(l.SemanticContext={}))}(or)),or}var Fo;function hl(){if(Fo)return Ye;Fo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ye&&Ye.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=Ye&&Ye.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(Ye,"__esModule",{value:!0}),Ye.PredicateTransition=void 0;const p=Xi(),x=z(),h=fn();let s=class extends p.AbstractPredicateTransition{constructor(n,t,o,e){super(n),this.ruleIndex=t,this.predIndex=o,this.isCtxDependent=e}get serializationType(){return 4}get isEpsilon(){return!0}matches(n,t,o){return!1}get predicate(){return new h.SemanticContext.Predicate(this.ruleIndex,this.predIndex,this.isCtxDependent)}toString(){return"pred_"+this.ruleIndex+":"+this.predIndex}};return l([x.Override],s.prototype,"serializationType",null),l([x.Override],s.prototype,"isEpsilon",null),l([x.Override],s.prototype,"matches",null),l([x.Override,x.NotNull],s.prototype,"toString",null),s=l([a(0,x.NotNull)],s),Ye.PredicateTransition=s,Ye}var Io;function oi(){if(Io)return Ve;Io=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ve&&Ve.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=Ve&&Ve.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(Ve,"__esModule",{value:!0}),Ve.FailedPredicateException=void 0;const p=Qt(),x=z(),h=hl();let s=class fl extends p.RecognitionException{constructor(n,t,o){super(n,n.inputStream,n.context,fl.formatMessage(t,o));let i=n.interpreter.atn.states[n.state].transition(0);i instanceof h.PredicateTransition?(this._ruleIndex=i.ruleIndex,this._predicateIndex=i.predIndex):(this._ruleIndex=0,this._predicateIndex=0),this._predicate=t,super.setOffendingToken(n,n.currentToken)}get ruleIndex(){return this._ruleIndex}get predicateIndex(){return this._predicateIndex}get predicate(){return this._predicate}static formatMessage(n,t){return t||`failed predicate: {${n}}?`}};return l([x.NotNull],s,"formatMessage",null),s=l([a(0,x.NotNull)],s),Ve.FailedPredicateException=s,Ve}var Ke={},wo;function si(){if(wo)return Ke;wo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ke&&Ke.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=Ke&&Ke.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.InputMismatchException=void 0;const p=Qt(),x=z();let h=class extends p.RecognitionException{constructor(r,n,t){t===void 0&&(t=r.context),super(r,r.inputStream,t),n!==void 0&&this.setOffendingState(n),this.setOffendingToken(r,r.currentToken)}};return h=l([a(0,x.NotNull)],h),Ke.InputMismatchException=h,Ke}var Ge={},ar={},yi={},Bo;function Wi(){return Bo||(Bo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.Arrays=void 0,function(a){function p(s,r,n,t){return x(s,n!==void 0?n:0,t!==void 0?t:s.length,r)}a.binarySearch=p;function x(s,r,n,t){let o=r,e=n-1;for(;o<=e;){let i=o+e>>>1,u=s[i];if(u<t)o=i+1;else if(u>t)e=i-1;else return i}return-(o+1)}function h(s){let r="[",n=!0;for(let t of s)n?n=!1:r+=", ",t===null?r+="null":t===void 0?r+="undefined":r+=t;return r+="]",r}a.toString=h}(l.Arrays||(l.Arrays={}))}(yi)),yi}var Mo;function Ki(){if(Mo)return ar;Mo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ar&&ar.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u};Object.defineProperty(ar,"__esModule",{value:!0}),ar.IntegerList=void 0;const a=Wi(),p=z(),x=new Int32Array(0),h=4,s=(1<<31>>>0)-1-8;let r=class ri{constructor(t){if(!t)this._data=x,this._size=0;else if(t instanceof ri)this._data=t._data.slice(0),this._size=t._size;else if(typeof t=="number")t===0?(this._data=x,this._size=0):(this._data=new Int32Array(t),this._size=0);else{this._data=x,this._size=0;for(let o of t)this.add(o)}}add(t){this._data.length===this._size&&this.ensureCapacity(this._size+1),this._data[this._size]=t,this._size++}addAll(t){if(Array.isArray(t))this.ensureCapacity(this._size+t.length),this._data.subarray(this._size,this._size+t.length).set(t),this._size+=t.length;else if(t instanceof ri)this.ensureCapacity(this._size+t._size),this._data.subarray(this._size,this._size+t.size).set(t._data),this._size+=t._size;else{this.ensureCapacity(this._size+t.size);let o=0;for(let e of t)this._data[this._size+o]=e,o++;this._size+=t.size}}get(t){if(t<0||t>=this._size)throw RangeError();return this._data[t]}contains(t){for(let o=0;o<this._size;o++)if(this._data[o]===t)return!0;return!1}set(t,o){if(t<0||t>=this._size)throw RangeError();let e=this._data[t];return this._data[t]=o,e}removeAt(t){let o=this.get(t);return this._data.copyWithin(t,t+1,this._size),this._data[this._size-1]=0,this._size--,o}removeRange(t,o){if(t<0||o<0||t>this._size||o>this._size||t>o)throw RangeError();this._data.copyWithin(o,t,this._size),this._data.fill(0,this._size-(o-t),this._size),this._size-=o-t}get isEmpty(){return this._size===0}get size(){return this._size}trimToSize(){this._data.length!==this._size&&(this._data=this._data.slice(0,this._size))}clear(){this._data.fill(0,0,this._size),this._size=0}toArray(){return this._size===0?[]:Array.from(this._data.subarray(0,this._size))}sort(){this._data.subarray(0,this._size).sort()}equals(t){if(t===this)return!0;if(!(t instanceof ri)||this._size!==t._size)return!1;for(let o=0;o<this._size;o++)if(this._data[o]!==t._data[o])return!1;return!0}hashCode(){let t=1;for(let o=0;o<this._size;o++)t=31*t+this._data[o];return t}toString(){return this._data.toString()}binarySearch(t,o,e){if(o===void 0&&(o=0),e===void 0&&(e=this._size),o<0||e<0||o>this._size||e>this._size)throw new RangeError;if(o>e)throw new RangeError;return a.Arrays.binarySearch(this._data,t,o,e)}ensureCapacity(t){if(t<0||t>s)throw new RangeError;let o;for(this._data.length===0?o=h:o=this._data.length;o<t;)o=o*2,(o<0||o>s)&&(o=s);let e=new Int32Array(o);e.set(this._data),this._data=e}toCharArray(){let t=new Uint16Array(this._size),o=0,e=!1;for(let i=0;i<this._size;i++){let u=this._data[i];if(u>=0&&u<65536){t[o]=u,o++;continue}if(!e){let f=new Uint16Array(this.charArraySize());f.set(t,0),t=f,e=!0}let c=String.fromCodePoint(u);t[o]=c.charCodeAt(0),t[o+1]=c.charCodeAt(1),o+=2}return t}charArraySize(){let t=0;for(let o=0;o<this._size;o++)t+=this._data[o]>=65536?2:1;return t}};return l([p.NotNull],r.prototype,"_data",void 0),l([p.Override],r.prototype,"equals",null),l([p.Override],r.prototype,"hashCode",null),l([p.Override],r.prototype,"toString",null),ar.IntegerList=r,ar}var cr={},ko;function ye(){if(ko)return cr;ko=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=cr&&cr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(cr,"__esModule",{value:!0}),cr.Interval=void 0;const a=z(),p=1e3;let x=class Le{constructor(s,r){this.a=s,this.b=r}static get INVALID(){return Le._INVALID}static of(s,r){return s!==r||s<0||s>p?new Le(s,r):(Le.cache[s]==null&&(Le.cache[s]=new Le(s,s)),Le.cache[s])}get length(){return this.b<this.a?0:this.b-this.a+1}equals(s){return s===this?!0:s instanceof Le?this.a===s.a&&this.b===s.b:!1}hashCode(){let s=23;return s=s*31+this.a,s=s*31+this.b,s}startsBeforeDisjoint(s){return this.a<s.a&&this.b<s.a}startsBeforeNonDisjoint(s){return this.a<=s.a&&this.b>=s.a}startsAfter(s){return this.a>s.a}startsAfterDisjoint(s){return this.a>s.b}startsAfterNonDisjoint(s){return this.a>s.a&&this.a<=s.b}disjoint(s){return this.startsBeforeDisjoint(s)||this.startsAfterDisjoint(s)}adjacent(s){return this.a===s.b+1||this.b===s.a-1}properlyContains(s){return s.a>=this.a&&s.b<=this.b}union(s){return Le.of(Math.min(this.a,s.a),Math.max(this.b,s.b))}intersection(s){return Le.of(Math.max(this.a,s.a),Math.min(this.b,s.b))}differenceNotProperlyContained(s){let r;return s.startsBeforeNonDisjoint(this)?r=Le.of(Math.max(this.a,s.b+1),this.b):s.startsAfterNonDisjoint(this)&&(r=Le.of(this.a,s.a-1)),r}toString(){return this.a+".."+this.b}};return x._INVALID=new x(-1,-2),x.cache=new Array(p+1),l([a.Override],x.prototype,"equals",null),l([a.Override],x.prototype,"hashCode",null),l([a.Override],x.prototype,"toString",null),cr.Interval=x,cr}var hr={},Sn={},$e={},Ni={},jo;function pe(){return jo||(jo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.Token=void 0;const a=$t();(function(p){p.INVALID_TYPE=0,p.EPSILON=-2,p.MIN_USER_TOKEN_TYPE=1,p.EOF=a.IntStream.EOF,p.DEFAULT_CHANNEL=0,p.HIDDEN_CHANNEL=1,p.MIN_USER_CHANNEL_VALUE=2})(l.Token||(l.Token={}))}(Ni)),Ni}var qo;function Vn(){if(qo)return $e;qo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=$e&&$e.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=$e&&$e.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty($e,"__esModule",{value:!0}),$e.CommonToken=void 0;const p=ye(),x=z(),h=pe();let s=class kn{constructor(n,t,o=kn.EMPTY_SOURCE,e=h.Token.DEFAULT_CHANNEL,i=0,u=0){this._line=0,this._charPositionInLine=-1,this._channel=h.Token.DEFAULT_CHANNEL,this.index=-1,this._text=t,this._type=n,this.source=o,this._channel=e,this.start=i,this.stop=u,o.source!=null&&(this._line=o.source.line,this._charPositionInLine=o.source.charPositionInLine)}static fromToken(n){let t=new kn(n.type,void 0,kn.EMPTY_SOURCE,n.channel,n.startIndex,n.stopIndex);return t._line=n.line,t.index=n.tokenIndex,t._charPositionInLine=n.charPositionInLine,n instanceof kn?(t._text=n._text,t.source=n.source):(t._text=n.text,t.source={source:n.tokenSource,stream:n.inputStream}),t}get type(){return this._type}set type(n){this._type=n}get line(){return this._line}set line(n){this._line=n}get text(){if(this._text!=null)return this._text;let n=this.inputStream;if(n==null)return;let t=n.size;return this.start<t&&this.stop<t?n.getText(p.Interval.of(this.start,this.stop)):"<EOF>"}set text(n){this._text=n}get charPositionInLine(){return this._charPositionInLine}set charPositionInLine(n){this._charPositionInLine=n}get channel(){return this._channel}set channel(n){this._channel=n}get startIndex(){return this.start}set startIndex(n){this.start=n}get stopIndex(){return this.stop}set stopIndex(n){this.stop=n}get tokenIndex(){return this.index}set tokenIndex(n){this.index=n}get tokenSource(){return this.source.source}get inputStream(){return this.source.stream}toString(n){let t="";this._channel>0&&(t=",channel="+this._channel);let o=this.text;o!=null?(o=o.replace(/\n/g,"\\n"),o=o.replace(/\r/g,"\\r"),o=o.replace(/\t/g,"\\t")):o="<no text>";let e=String(this._type);return n&&(e=n.vocabulary.getDisplayName(this._type)),"[@"+this.tokenIndex+","+this.start+":"+this.stop+"='"+o+"',<"+e+">"+t+","+this._line+":"+this.charPositionInLine+"]"}};return s.EMPTY_SOURCE={source:void 0,stream:void 0},l([x.NotNull],s.prototype,"source",void 0),l([x.Override],s.prototype,"type",null),l([x.Override],s.prototype,"line",null),l([x.Override],s.prototype,"text",null),l([x.Override],s.prototype,"charPositionInLine",null),l([x.Override],s.prototype,"channel",null),l([x.Override],s.prototype,"startIndex",null),l([x.Override],s.prototype,"stopIndex",null),l([x.Override],s.prototype,"tokenIndex",null),l([x.Override],s.prototype,"tokenSource",null),l([x.Override],s.prototype,"inputStream",null),l([x.Override],s.prototype,"toString",null),l([a(0,x.NotNull)],s,"fromToken",null),s=l([a(2,x.NotNull)],s),$e.CommonToken=s,$e}var zo;function Gi(){return zo||(zo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=Sn&&Sn.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(l,"__esModule",{value:!0}),l.CommonTokenFactory=void 0;const p=Vn(),x=ye(),h=z();let s=class{constructor(n=!1){this.copyText=n}create(n,t,o,e,i,u,c,f){let A=new p.CommonToken(t,o,n,e,i,u);return A.line=c,A.charPositionInLine=f,o==null&&this.copyText&&n.stream!=null&&(A.text=n.stream.getText(x.Interval.of(i,u))),A}createSimple(n,t){return new p.CommonToken(n,t)}};a([h.Override],s.prototype,"create",null),a([h.Override],s.prototype,"createSimple",null),l.CommonTokenFactory=s,function(r){r.DEFAULT=new r}(s=l.CommonTokenFactory||(l.CommonTokenFactory={}))}(Sn)),Sn}var En={},Uo;function pl(){if(Uo)return En;Uo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(En,"__esModule",{value:!0}),En.IntegerStack=void 0;const l=Ki();let a=class extends l.IntegerList{constructor(x){super(x)}push(x){this.add(x)}pop(){return this.removeAt(this.size-1)}peek(){return this.get(this.size-1)}};return En.IntegerStack=a,En}var fr={},Tn={},Ho;function dl(){if(Ho)return Tn;Ho=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Tn,"__esModule",{value:!0}),Tn.AcceptStateInfo=void 0;let l=class{constructor(p,x){this._prediction=p,this._lexerActionExecutor=x}get prediction(){return this._prediction}get lexerActionExecutor(){return this._lexerActionExecutor}};return Tn.AcceptStateInfo=l,Tn}var pr={},gn={},Vo;function pn(){if(Vo)return gn;Vo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(gn,"__esModule",{value:!0}),gn.Array2DHashMap=void 0;const l=Jt();class a{constructor(h){this.keyComparator=h}hashCode(h){return this.keyComparator.hashCode(h.key)}equals(h,s){return this.keyComparator.equals(h.key,s.key)}}let p=class ki{constructor(h){h instanceof ki?this.backingStore=new l.Array2DHashSet(h.backingStore):this.backingStore=new l.Array2DHashSet(new a(h))}clear(){this.backingStore.clear()}containsKey(h){return this.backingStore.contains({key:h})}get(h){let s=this.backingStore.get({key:h});if(s)return s.value}get isEmpty(){return this.backingStore.isEmpty}put(h,s){let r=this.backingStore.get({key:h,value:s}),n;return r?(n=r.value,r.value=s):this.backingStore.add({key:h,value:s}),n}putIfAbsent(h,s){let r=this.backingStore.get({key:h,value:s}),n;return r?n=r.value:this.backingStore.add({key:h,value:s}),n}get size(){return this.backingStore.size}hashCode(){return this.backingStore.hashCode()}equals(h){return h instanceof ki?this.backingStore.equals(h.backingStore):!1}};return gn.Array2DHashMap=p,gn}var Qe={},dr={},Ze={},yn={},Yo;function un(){if(Yo)return yn;Yo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(yn,"__esModule",{value:!0}),yn.DecisionState=void 0;const l=Yt();let a=class extends l.ATNState{constructor(){super(...arguments),this.decision=-1,this.nonGreedy=!1,this.sll=!1}};return yn.DecisionState=a,yn}var xr={},Nn={},Xo;function $i(){return Xo||(Xo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=Nn&&Nn.__decorate||function(t,o,e,i){var u=arguments.length,c=u<3?o:i===null?i=Object.getOwnPropertyDescriptor(o,e):i,f;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")c=Reflect.decorate(t,o,e,i);else for(var A=t.length-1;A>=0;A--)(f=t[A])&&(c=(u<3?f(c):u>3?f(o,e,c):f(o,e))||c);return u>3&&c&&Object.defineProperty(o,e,c),c};Object.defineProperty(l,"__esModule",{value:!0}),l.PredictionContextCache=void 0;const p=pn(),x=z(),h=qe(),s=Be(),r=be();let n=class ji{constructor(o=!0){this.contexts=new p.Array2DHashMap(h.ObjectEqualityComparator.INSTANCE),this.childContexts=new p.Array2DHashMap(h.ObjectEqualityComparator.INSTANCE),this.joinContexts=new p.Array2DHashMap(h.ObjectEqualityComparator.INSTANCE),this.enableCache=o}getAsCached(o){if(!this.enableCache)return o;let e=this.contexts.get(o);return e||(e=o,this.contexts.put(o,o)),e}getChild(o,e){if(!this.enableCache)return o.getChild(e);let i=new ji.PredictionContextAndInt(o,e),u=this.childContexts.get(i);return u||(u=o.getChild(e),u=this.getAsCached(u),this.childContexts.put(i,u)),u}join(o,e){if(!this.enableCache)return s.PredictionContext.join(o,e,this);let i=new ji.IdentityCommutativePredictionContextOperands(o,e),u=this.joinContexts.get(i);return u||(u=s.PredictionContext.join(o,e,this),u=this.getAsCached(u),this.joinContexts.put(i,u),u)}};l.PredictionContextCache=n,n.UNCACHED=new n(!1),function(t){class o{constructor(u,c){this.obj=u,this.value=c}equals(u){if(u instanceof o){if(u===this)return!0}else return!1;let c=u;return this.value===c.value&&(this.obj===c.obj||this.obj!=null&&this.obj.equals(c.obj))}hashCode(){let u=5;return u=7*u+(this.obj!=null?this.obj.hashCode():0),u=7*u+this.value,u}}a([x.Override],o.prototype,"equals",null),a([x.Override],o.prototype,"hashCode",null),t.PredictionContextAndInt=o;class e{constructor(u,c){r(u!=null),r(c!=null),this._x=u,this._y=c}get x(){return this._x}get y(){return this._y}equals(u){if(u instanceof e){if(this===u)return!0}else return!1;let c=u;return this._x===c._x&&this._y===c._y||this._x===c._y&&this._y===c._x}hashCode(){return this._x.hashCode()^this._y.hashCode()}}a([x.Override],e.prototype,"equals",null),a([x.Override],e.prototype,"hashCode",null),t.IdentityCommutativePredictionContextOperands=e}(n=l.PredictionContextCache||(l.PredictionContextCache={}))}(Nn)),Nn}var Wo;function Be(){return Wo||(Wo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=xr&&xr.__decorate||function(A,d,_,m){var S=arguments.length,E=S<3?d:m===null?m=Object.getOwnPropertyDescriptor(d,_):m,g;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")E=Reflect.decorate(A,d,_,m);else for(var T=A.length-1;T>=0;T--)(g=A[T])&&(E=(S<3?g(E):S>3?g(d,_,E):g(d,_))||E);return S>3&&E&&Object.defineProperty(d,_,E),E},p=xr&&xr.__param||function(A,d){return function(_,m){d(_,m,A)}};Object.defineProperty(l,"__esModule",{value:!0}),l.SingletonPredictionContext=l.PredictionContext=void 0;const x=pn(),h=Jt(),s=Wi(),r=xe(),n=z(),t=$i(),o=be(),e=1;let i=class ge{constructor(d){this.cachedHashCode=d}static calculateEmptyHashCode(){let d=r.MurmurHash.initialize(e);return d=r.MurmurHash.finish(d,0),d}static calculateSingleHashCode(d,_){let m=r.MurmurHash.initialize(e);return m=r.MurmurHash.update(m,d),m=r.MurmurHash.update(m,_),m=r.MurmurHash.finish(m,2),m}static calculateHashCode(d,_){let m=r.MurmurHash.initialize(e);for(let S of d)m=r.MurmurHash.update(m,S);for(let S of _)m=r.MurmurHash.update(m,S);return m=r.MurmurHash.finish(m,2*d.length),m}static fromRuleContext(d,_,m=!0){if(_.isEmpty)return m?ge.EMPTY_FULL:ge.EMPTY_LOCAL;let S;_._parent?S=ge.fromRuleContext(d,_._parent,m):S=m?ge.EMPTY_FULL:ge.EMPTY_LOCAL;let g=d.states[_.invokingState].transition(0);return S.getChild(g.followState.stateNumber)}static addEmptyContext(d){return d.addEmptyContext()}static removeEmptyContext(d){return d.removeEmptyContext()}static join(d,_,m=t.PredictionContextCache.UNCACHED){if(d===_)return d;if(d.isEmpty)return ge.isEmptyLocal(d)?d:ge.addEmptyContext(_);if(_.isEmpty)return ge.isEmptyLocal(_)?_:ge.addEmptyContext(d);let S=d.size,E=_.size;if(S===1&&E===1&&d.getReturnState(0)===_.getReturnState(0)){let M=m.join(d.getParent(0),_.getParent(0));return M===d.getParent(0)?d:M===_.getParent(0)?_:M.getChild(d.getReturnState(0))}let g=0,T=new Array(S+E),N=new Array(T.length),y=0,O=0,F=!0,w=!0;for(;y<S&&O<E;)d.getReturnState(y)===_.getReturnState(O)?(T[g]=m.join(d.getParent(y),_.getParent(O)),N[g]=d.getReturnState(y),F=F&&T[g]===d.getParent(y),w=w&&T[g]===_.getParent(O),y++,O++):d.getReturnState(y)<_.getReturnState(O)?(T[g]=d.getParent(y),N[g]=d.getReturnState(y),w=!1,y++):(o(_.getReturnState(O)<d.getReturnState(y)),T[g]=_.getParent(O),N[g]=_.getReturnState(O),F=!1,O++),g++;for(;y<S;)T[g]=d.getParent(y),N[g]=d.getReturnState(y),y++,w=!1,g++;for(;O<E;)T[g]=_.getParent(O),N[g]=_.getReturnState(O),O++,F=!1,g++;return F?d:w?_:(g<T.length&&(T=T.slice(0,g),N=N.slice(0,g)),T.length===0?ge.EMPTY_FULL:T.length===1?new f(T[0],N[0]):new c(T,N))}static isEmptyLocal(d){return d===ge.EMPTY_LOCAL}static getCachedContext(d,_,m){if(d.isEmpty)return d;let S=m.get(d);if(S)return S;if(S=_.get(d),S)return m.put(d,S),S;let E=!1,g=new Array(d.size);for(let N=0;N<g.length;N++){let y=ge.getCachedContext(d.getParent(N),_,m);if(E||y!==d.getParent(N)){if(!E){g=new Array(d.size);for(let O=0;O<d.size;O++)g[O]=d.getParent(O);E=!0}g[N]=y}}if(!E)return S=_.putIfAbsent(d,d),m.put(d,S??d),d;let T;if(g.length===1)T=new f(g[0],d.getReturnState(0));else{let N=new Array(d.size);for(let y=0;y<d.size;y++)N[y]=d.getReturnState(y);T=new c(g,N,d.hashCode())}return S=_.putIfAbsent(T,T),m.put(T,S||T),m.put(d,S||T),T}appendSingleContext(d,_){return this.appendContext(ge.EMPTY_FULL.getChild(d),_)}getChild(d){return new f(this,d)}hashCode(){return this.cachedHashCode}toStrings(d,_,m=ge.EMPTY_FULL){let S=[];e:for(let E=0;;E++){let g=0,T=!0,N=this,y=_,O="";for(O+="[";!N.isEmpty&&N!==m;){let F=0;if(N.size>0){let w=1;for(;1<<w>>>0<N.size;)w++;let M=(1<<w>>>0)-1;if(F=E>>g&M,T=T&&F>=N.size-1,F>=N.size)continue e;g+=w}if(d){O.length>1&&(O+=" ");let M=d.atn.states[y],W=d.ruleNames[M.ruleIndex];O+=W}else N.getReturnState(F)!==ge.EMPTY_FULL_STATE_KEY&&(N.isEmpty||(O.length>1&&(O+=" "),O+=N.getReturnState(F)));y=N.getReturnState(F),N=N.getParent(F)}if(O+="]",S.push(O),T)break}return S}};a([n.Override],i.prototype,"hashCode",null),a([p(0,n.NotNull),p(1,n.NotNull),p(2,n.NotNull)],i,"join",null),a([p(0,n.NotNull),p(1,n.NotNull),p(2,n.NotNull)],i,"getCachedContext",null),l.PredictionContext=i;class u extends i{constructor(d){super(i.calculateEmptyHashCode()),this.fullContext=d}get isFullContext(){return this.fullContext}addEmptyContext(){return this}removeEmptyContext(){throw new Error("Cannot remove the empty context from itself.")}getParent(d){throw new Error("index out of bounds")}getReturnState(d){throw new Error("index out of bounds")}findReturnState(d){return-1}get size(){return 0}appendSingleContext(d,_){return _.getChild(this,d)}appendContext(d,_){return d}get isEmpty(){return!0}get hasEmpty(){return!0}equals(d){return this===d}toStrings(d,_,m){return["[]"]}}a([n.Override],u.prototype,"addEmptyContext",null),a([n.Override],u.prototype,"removeEmptyContext",null),a([n.Override],u.prototype,"getParent",null),a([n.Override],u.prototype,"getReturnState",null),a([n.Override],u.prototype,"findReturnState",null),a([n.Override],u.prototype,"size",null),a([n.Override],u.prototype,"appendSingleContext",null),a([n.Override],u.prototype,"appendContext",null),a([n.Override],u.prototype,"isEmpty",null),a([n.Override],u.prototype,"hasEmpty",null),a([n.Override],u.prototype,"equals",null),a([n.Override],u.prototype,"toStrings",null);let c=class sn extends i{constructor(d,_,m){super(m||i.calculateHashCode(d,_)),o(d.length===_.length),o(_.length>1||_[0]!==i.EMPTY_FULL_STATE_KEY,"Should be using PredictionContext.EMPTY instead."),this.parents=d,this.returnStates=_}getParent(d){return this.parents[d]}getReturnState(d){return this.returnStates[d]}findReturnState(d){return s.Arrays.binarySearch(this.returnStates,d)}get size(){return this.returnStates.length}get isEmpty(){return!1}get hasEmpty(){return this.returnStates[this.returnStates.length-1]===i.EMPTY_FULL_STATE_KEY}addEmptyContext(){if(this.hasEmpty)return this;let d=this.parents.slice(0),_=this.returnStates.slice(0);return d.push(i.EMPTY_FULL),_.push(i.EMPTY_FULL_STATE_KEY),new sn(d,_)}removeEmptyContext(){if(!this.hasEmpty)return this;if(this.returnStates.length===2)return new f(this.parents[0],this.returnStates[0]);{let d=this.parents.slice(0,this.parents.length-1),_=this.returnStates.slice(0,this.returnStates.length-1);return new sn(d,_)}}appendContext(d,_){return sn.appendContextImpl(this,d,new i.IdentityHashMap)}static appendContextImpl(d,_,m){if(_.isEmpty){if(i.isEmptyLocal(_)){if(d.hasEmpty)return i.EMPTY_LOCAL;throw new Error("what to do here?")}return d}if(_.size!==1)throw new Error("Appending a tree suffix is not yet supported.");let S=m.get(d);if(!S){if(d.isEmpty)S=_;else{let E=d.size;d.hasEmpty&&E--;let g=new Array(E),T=new Array(E);for(let N=0;N<E;N++)T[N]=d.getReturnState(N);for(let N=0;N<E;N++)g[N]=sn.appendContextImpl(d.getParent(N),_,m);g.length===1?S=new f(g[0],T[0]):(o(g.length>1),S=new sn(g,T)),d.hasEmpty&&(S=i.join(S,_))}m.put(d,S)}return S}equals(d){if(this===d)return!0;if(!(d instanceof sn)||this.hashCode()!==d.hashCode())return!1;let _=d;return this.equalsImpl(_,new h.Array2DHashSet)}equalsImpl(d,_){let m=[],S=[];for(m.push(this),S.push(d);;){let E=m.pop(),g=S.pop();if(!E||!g)break;let T=new t.PredictionContextCache.IdentityCommutativePredictionContextOperands(E,g);if(!_.add(T))continue;let N=T.x.size;if(N===0){if(!T.x.equals(T.y))return!1;continue}let y=T.y.size;if(N!==y)return!1;for(let O=0;O<N;O++){if(T.x.getReturnState(O)!==T.y.getReturnState(O))return!1;let F=T.x.getParent(O),w=T.y.getParent(O);if(F.hashCode()!==w.hashCode())return!1;F!==w&&(m.push(F),S.push(w))}}return!0}};a([n.NotNull],c.prototype,"parents",void 0),a([n.NotNull],c.prototype,"returnStates",void 0),a([n.Override],c.prototype,"getParent",null),a([n.Override],c.prototype,"getReturnState",null),a([n.Override],c.prototype,"findReturnState",null),a([n.Override],c.prototype,"size",null),a([n.Override],c.prototype,"isEmpty",null),a([n.Override],c.prototype,"hasEmpty",null),a([n.Override],c.prototype,"addEmptyContext",null),a([n.Override],c.prototype,"removeEmptyContext",null),a([n.Override],c.prototype,"appendContext",null),a([n.Override],c.prototype,"equals",null),c=a([p(0,n.NotNull)],c);let f=class xl extends i{constructor(d,_){super(i.calculateSingleHashCode(d,_)),this.parent=d,this.returnState=_}getParent(d){return this.parent}getReturnState(d){return this.returnState}findReturnState(d){return this.returnState===d?0:-1}get size(){return 1}get isEmpty(){return!1}get hasEmpty(){return!1}appendContext(d,_){return _.getChild(this.parent.appendContext(d,_),this.returnState)}addEmptyContext(){let d=[this.parent,i.EMPTY_FULL],_=[this.returnState,i.EMPTY_FULL_STATE_KEY];return new c(d,_)}removeEmptyContext(){return this}equals(d){if(d===this)return!0;if(!(d instanceof xl))return!1;let _=d;return this.hashCode()!==_.hashCode()?!1:this.returnState===_.returnState&&this.parent.equals(_.parent)}};a([n.NotNull],f.prototype,"parent",void 0),a([n.Override],f.prototype,"getParent",null),a([n.Override],f.prototype,"getReturnState",null),a([n.Override],f.prototype,"findReturnState",null),a([n.Override],f.prototype,"size",null),a([n.Override],f.prototype,"isEmpty",null),a([n.Override],f.prototype,"hasEmpty",null),a([n.Override],f.prototype,"appendContext",null),a([n.Override],f.prototype,"addEmptyContext",null),a([n.Override],f.prototype,"removeEmptyContext",null),a([n.Override],f.prototype,"equals",null),f=a([p(0,n.NotNull)],f),l.SingletonPredictionContext=f,function(A){A.EMPTY_LOCAL=new u(!1),A.EMPTY_FULL=new u(!0),A.EMPTY_LOCAL_STATE_KEY=-2147483648,A.EMPTY_FULL_STATE_KEY=(1<<31>>>0)-1;class d extends x.Array2DHashMap{constructor(){super(_.INSTANCE)}}A.IdentityHashMap=d;class _{IdentityEqualityComparator(){}hashCode(S){return S.hashCode()}equals(S,E){return S===E}}_.INSTANCE=new _,a([n.Override],_.prototype,"hashCode",null),a([n.Override],_.prototype,"equals",null),A.IdentityEqualityComparator=_}(i=l.PredictionContext||(l.PredictionContext={}))}(xr)),xr}var Ko;function ui(){if(Ko)return Ze;Ko=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ze&&Ze.__decorate||function(A,d,_,m){var S=arguments.length,E=S<3?d:m===null?m=Object.getOwnPropertyDescriptor(d,_):m,g;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")E=Reflect.decorate(A,d,_,m);else for(var T=A.length-1;T>=0;T--)(g=A[T])&&(E=(S<3?g(E):S>3?g(d,_,E):g(d,_))||E);return S>3&&E&&Object.defineProperty(d,_,E),E},a=Ze&&Ze.__param||function(A,d){return function(_,m){d(_,m,A)}};Object.defineProperty(Ze,"__esModule",{value:!0}),Ze.ATNConfig=void 0;const p=pn(),x=un(),h=xe(),s=z(),r=qe(),n=Be(),t=fn(),o=be(),e=2147483648;let i=class jn{constructor(d,_,m){typeof _=="number"?(o((_&16777215)===_),this._state=d,this.altAndOuterContextDepth=_,this._context=m):(this._state=d,this.altAndOuterContextDepth=_.altAndOuterContextDepth,this._context=m)}static create(d,_,m,S=t.SemanticContext.NONE,E){return S!==t.SemanticContext.NONE?E!=null?new f(E,S,d,_,m,!1):new u(S,d,_,m):E!=null?new c(E,d,_,m,!1):new jn(d,_,m)}get state(){return this._state}get alt(){return this.altAndOuterContextDepth&16777215}get context(){return this._context}set context(d){this._context=d}get reachesIntoOuterContext(){return this.outerContextDepth!==0}get outerContextDepth(){return this.altAndOuterContextDepth>>>24&127}set outerContextDepth(d){o(d>=0),d=Math.min(d,127),this.altAndOuterContextDepth=d<<24|(this.altAndOuterContextDepth&-2130706433)>>>0}get lexerActionExecutor(){}get semanticContext(){return t.SemanticContext.NONE}get hasPassedThroughNonGreedyDecision(){return!1}clone(){return this.transform(this.state,!1)}transform(d,_,m){return m==null?this.transformImpl(d,this._context,this.semanticContext,_,this.lexerActionExecutor):m instanceof n.PredictionContext?this.transformImpl(d,m,this.semanticContext,_,this.lexerActionExecutor):m instanceof t.SemanticContext?this.transformImpl(d,this._context,m,_,this.lexerActionExecutor):this.transformImpl(d,this._context,this.semanticContext,_,m)}transformImpl(d,_,m,S,E){let g=S&&jn.checkNonGreedyDecision(this,d);return m!==t.SemanticContext.NONE?E!=null||g?new f(E,m,d,this,_,g):new u(m,d,this,_):E!=null||g?new c(E,d,this,_,g):new jn(d,this,_)}static checkNonGreedyDecision(d,_){return d.hasPassedThroughNonGreedyDecision||_ instanceof x.DecisionState&&_.nonGreedy}appendContext(d,_){if(typeof d=="number"){let m=this.context.appendSingleContext(d,_);return this.transform(this.state,!1,m)}else{let m=this.context.appendContext(d,_);return this.transform(this.state,!1,m)}}contains(d){if(this.state.stateNumber!==d.state.stateNumber||this.alt!==d.alt||!this.semanticContext.equals(d.semanticContext))return!1;let _=[],m=[];for(_.push(this.context),m.push(d.context);;){let S=_.pop(),E=m.pop();if(!S||!E)break;if(S===E)return!0;if(S.size<E.size)return!1;if(E.isEmpty)return S.hasEmpty;for(let g=0;g<E.size;g++){let T=S.findReturnState(E.getReturnState(g));if(T<0)return!1;_.push(S.getParent(T)),m.push(E.getParent(g))}}return!1}get isPrecedenceFilterSuppressed(){return(this.altAndOuterContextDepth&e)!==0}set isPrecedenceFilterSuppressed(d){d?this.altAndOuterContextDepth|=e:this.altAndOuterContextDepth&=~e}equals(d){return this===d?!0:d instanceof jn?this.state.stateNumber===d.state.stateNumber&&this.alt===d.alt&&this.reachesIntoOuterContext===d.reachesIntoOuterContext&&this.context.equals(d.context)&&this.semanticContext.equals(d.semanticContext)&&this.isPrecedenceFilterSuppressed===d.isPrecedenceFilterSuppressed&&this.hasPassedThroughNonGreedyDecision===d.hasPassedThroughNonGreedyDecision&&r.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor,d.lexerActionExecutor):!1}hashCode(){let d=h.MurmurHash.initialize(7);return d=h.MurmurHash.update(d,this.state.stateNumber),d=h.MurmurHash.update(d,this.alt),d=h.MurmurHash.update(d,this.reachesIntoOuterContext?1:0),d=h.MurmurHash.update(d,this.context),d=h.MurmurHash.update(d,this.semanticContext),d=h.MurmurHash.update(d,this.hasPassedThroughNonGreedyDecision?1:0),d=h.MurmurHash.update(d,this.lexerActionExecutor),d=h.MurmurHash.finish(d,7),d}toDotString(){let d="";d+=`digraph G {
`,d+=`rankdir=LR;
`;let _=new p.Array2DHashMap(n.PredictionContext.IdentityEqualityComparator.INSTANCE),m=[];function S(E){let g=_.size,T=_.putIfAbsent(E,g);return T??(m.push(E),g)}for(m.push(this.context),_.put(this.context,0);;){let E=m.pop();if(!E)break;for(let g=0;g<E.size;g++)d+="  s"+S(E),d+="->",d+="s"+S(E.getParent(g)),d+='[label="'+E.getReturnState(g)+`"];
`}return d+=`}
`,d.toString()}toString(d,_,m){m==null&&(m=_!=null),_==null&&(_=!0);let S="",E;m?E=this.context.toStrings(d,this.state.stateNumber):E=["?"];let g=!0;for(let T of E)g?g=!1:S+=", ",S+="(",S+=this.state,_&&(S+=",",S+=this.alt),this.context&&(S+=",",S+=T),this.semanticContext!==t.SemanticContext.NONE&&(S+=",",S+=this.semanticContext),this.reachesIntoOuterContext&&(S+=",up="+this.outerContextDepth),S+=")";return S.toString()}};l([s.NotNull],i.prototype,"_state",void 0),l([s.NotNull],i.prototype,"_context",void 0),l([s.NotNull],i.prototype,"state",null),l([s.NotNull,a(0,s.NotNull)],i.prototype,"context",null),l([s.NotNull],i.prototype,"semanticContext",null),l([s.Override],i.prototype,"clone",null),l([a(0,s.NotNull),a(2,s.NotNull)],i.prototype,"transformImpl",null),l([s.Override],i.prototype,"equals",null),l([s.Override],i.prototype,"hashCode",null),l([a(0,s.NotNull),a(3,s.NotNull)],i,"create",null),i=l([a(0,s.NotNull),a(2,s.NotNull)],i),Ze.ATNConfig=i;let u=class extends i{constructor(d,_,m,S){typeof m=="number"?super(_,m,S):super(_,m,S),this._semanticContext=d}get semanticContext(){return this._semanticContext}};l([s.NotNull],u.prototype,"_semanticContext",void 0),l([s.Override],u.prototype,"semanticContext",null),u=l([a(1,s.NotNull),a(2,s.NotNull)],u);let c=class extends i{constructor(d,_,m,S,E){if(typeof m=="number")super(_,m,S);else if(super(_,m,S),m.semanticContext!==t.SemanticContext.NONE)throw new Error("Not supported");this._lexerActionExecutor=d,this.passedThroughNonGreedyDecision=E}get lexerActionExecutor(){return this._lexerActionExecutor}get hasPassedThroughNonGreedyDecision(){return this.passedThroughNonGreedyDecision}};l([s.Override],c.prototype,"lexerActionExecutor",null),l([s.Override],c.prototype,"hasPassedThroughNonGreedyDecision",null),c=l([a(1,s.NotNull),a(2,s.NotNull)],c);let f=class extends u{constructor(d,_,m,S,E,g){typeof S=="number"?super(_,m,S,E):super(_,m,S,E),this._lexerActionExecutor=d,this.passedThroughNonGreedyDecision=g}get lexerActionExecutor(){return this._lexerActionExecutor}get hasPassedThroughNonGreedyDecision(){return this.passedThroughNonGreedyDecision}};return l([s.Override],f.prototype,"lexerActionExecutor",null),l([s.Override],f.prototype,"hasPassedThroughNonGreedyDecision",null),f=l([a(1,s.NotNull),a(2,s.NotNull)],f),Ze}var vn={};const _l=Object.assign(function(a){if(a===null)return"null";if(a===void 0)return"undefined";if(typeof a=="string")return JSON.stringify(a);if(typeof a!="object")return String(a);try{return JSON.stringify(a,null,2)}catch{return String(a)}},{custom:Symbol.for("nodejs.util.inspect.custom"),colors:{},styles:{}});function Al(l,...a){if(typeof l!="string")return a.map(String).join(" ");let p=0;return l.replace(/%[sdj%]/g,x=>{if(x==="%%")return"%";if(p>=a.length)return x;const h=a[p++];if(x==="%s")return String(h);if(x==="%d")return Number(h);if(x==="%j")try{return JSON.stringify(h)}catch{return"[Circular]"}return x})}function ml(l,a){l.super_=a,Object.setPrototypeOf(l.prototype,a.prototype)}function Sl(l,a){let p=!1;return function(...x){return p||(console.warn(a),p=!0),l.apply(this,x)}}function El(){return function(){}}function Qi(l){return l!=null&&typeof l.then=="function"}function Zi(l){return l instanceof RegExp}function Ji(l){return l instanceof Date}function Tl(l){return l instanceof Error}function gl(l){return typeof l=="function"}function yl(l){return l===null||typeof l!="object"&&typeof l!="function"}function Nl(){return!1}function vl(l){return l===null}function Cl(l){return l==null}function Ol(l){return l===void 0}function Dl(l){return typeof l=="string"}function bl(l){return typeof l=="number"}function Rl(l){return typeof l=="object"&&l!==null}function Pl(l){return typeof l=="boolean"}function Ll(l){return typeof l=="symbol"}function Fl(l){return Array.isArray(l)}const Il={isPromise:Qi,isRegExp:Zi,isDate:Ji},Da={inspect:_l,format:Al,inherits:ml,deprecate:Sl,debuglog:El,types:Il,isPromise:Qi,isRegExp:Zi,isDate:Ji,isError:Tl,isFunction:gl,isPrimitive:yl,isBuffer:Nl,isNull:vl,isNullOrUndefined:Cl,isUndefined:Ol,isString:Dl,isNumber:bl,isObject:Rl,isBoolean:Pl,isSymbol:Ll,isArray:Fl},ba=Object.freeze(Object.defineProperty({__proto__:null,debuglog:El,default:Da,deprecate:Sl,format:Al,inherits:ml,inspect:_l,isArray:Fl,isBoolean:Pl,isBuffer:Nl,isDate:Ji,isError:Tl,isFunction:gl,isNull:vl,isNullOrUndefined:Cl,isNumber:bl,isObject:Rl,isPrimitive:yl,isPromise:Qi,isRegExp:Zi,isString:Dl,isSymbol:Ll,isUndefined:Ol,types:Il},Symbol.toStringTag,{value:"Module"})),Ra=ya(ba);var Go;function er(){if(Go)return vn;Go=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(vn,"__esModule",{value:!0}),vn.BitSet=void 0;const l=Ra,a=xe(),p=new Uint16Array(0);function x(i){return i>>>4}function h(i){return i*16}function s(i){let u=1;for(let c=0;c<16;c++){if((i&u)!==0)return c;u=u<<1>>>0}throw new RangeError("No specified bit found")}function r(i){let u=32768;for(let c=15;c>=0;c--){if((i&u)!==0)return c;u=u>>>1}throw new RangeError("No specified bit found")}function n(i,u){return i&=15,u&=15,i===u?1<<i>>>0:65535>>>15-u^65535>>>16-i}const t=new Uint8Array(65536);for(let i=0;i<16;i++){const u=1<<i>>>0;let c=0;for(;c<t.length;){c+=u;for(let f=0;f<u;f++)t[c]++,c++}}let o=class qn{constructor(u){if(!u)this.data=p;else if(typeof u=="number"){if(u<0)throw new RangeError("nbits cannot be negative");this.data=new Uint16Array(x(u-1)+1)}else if(u instanceof qn)this.data=u.data.slice(0);else{let c=-1;for(let f of u)c<f&&(c=f);this.data=new Uint16Array(x(c-1)+1);for(let f of u)this.set(f)}}and(u){const c=this.data,f=u.data,A=Math.min(c.length,f.length);let d=-1;for(let _=0;_<A;_++)(c[_]&=f[_])!==0&&(d=_);d===-1&&(this.data=p),d<c.length-1&&(this.data=c.slice(0,d+1))}andNot(u){const c=this.data,f=u.data,A=Math.min(c.length,f.length);let d=-1;for(let _=0;_<A;_++)(c[_]&=f[_]^65535)!==0&&(d=_);d===-1&&(this.data=p),d<c.length-1&&(this.data=c.slice(0,d+1))}cardinality(){if(this.isEmpty)return 0;const u=this.data,c=u.length;let f=0;for(let A=0;A<c;A++)f+=t[u[A]];return f}clear(u,c){u==null?this.data.fill(0):c==null?this.set(u,!1):this.set(u,c,!1)}flip(u,c){if(c==null&&(c=u),u<0||c<u)throw new RangeError;let f=x(u);const A=x(c);if(f===A)this.data[f]^=n(u,c);else{for(this.data[f++]^=n(u,15);f<A;)this.data[f++]^=65535;this.data[f++]^=n(0,c)}}get(u,c){if(c===void 0)return!!(this.data[x(u)]&n(u,u));{let f=new qn(c+1);for(let A=u;A<=c;A++)f.set(A,this.get(A));return f}}intersects(u){let c=Math.min(this.length(),u.length());if(c===0)return!1;let f=x(c-1);for(let A=0;A<=f;A++)if((this.data[A]&u.data[A])!==0)return!0;return!1}get isEmpty(){return this.length()===0}length(){return this.data.length?this.previousSetBit(h(this.data.length)-1)+1:0}nextClearBit(u){if(u<0)throw new RangeError("fromIndex cannot be negative");const c=this.data,f=c.length;let A=x(u);if(A>f)return-1;let d=65535^n(u,15);if((c[A]|d)===65535){for(A++,d=0;A<f&&c[A]===65535;A++);if(A===f)return-1}return h(A)+s((c[A]|d)^65535)}nextSetBit(u){if(u<0)throw new RangeError("fromIndex cannot be negative");const c=this.data,f=c.length;let A=x(u);if(A>f)return-1;let d=n(u,15);if((c[A]&d)===0){for(A++,d=65535;A<f&&c[A]===0;A++);if(A>=f)return-1}return h(A)+s(c[A]&d)}or(u){const c=this.data,f=u.data,A=Math.min(c.length,f.length),d=Math.max(c.length,f.length),_=c.length===d?c:new Uint16Array(d);let m=-1;for(let E=0;E<A;E++)(_[E]=c[E]|f[E])!==0&&(m=E);const S=c.length>f.length?c:f;for(let E=A;E<d;E++)(_[E]=S[E])!==0&&(m=E);m===-1?this.data=p:_.length===m+1?this.data=_:this.data=_.slice(0,m)}previousClearBit(u){if(u<0)throw new RangeError("fromIndex cannot be negative");const c=this.data,f=c.length;let A=x(u);A>=f&&(A=f-1);let d=65535^n(0,u);if((c[A]|d)===65535){for(d=0,A--;A>=0&&c[A]===65535;A--);if(A<0)return-1}return h(A)+r((c[A]|d)^65535)}previousSetBit(u){if(u<0)throw new RangeError("fromIndex cannot be negative");const c=this.data,f=c.length;let A=x(u);A>=f&&(A=f-1);let d=n(0,u);if((c[A]&d)===0){for(A--,d=65535;A>=0&&c[A]===0;A--);if(A<0)return-1}return h(A)+r(c[A]&d)}set(u,c,f){if(c===void 0?(c=u,f=!0):typeof c=="boolean"&&(f=c,c=u),f===void 0&&(f=!0),u<0||u>c)throw new RangeError;let A=x(u),d=x(c);if(f&&d>=this.data.length){let _=new Uint16Array(d+1);this.data.forEach((m,S)=>_[S]=m),this.data=_}else if(!f){if(A>=this.data.length)return;d>=this.data.length&&(d=this.data.length-1,c=this.data.length*16-1)}if(A===d)this._setBits(A,f,n(u,c));else{for(this._setBits(A++,f,n(u,15));A<d;)this.data[A++]=f?65535:0;this._setBits(A,f,n(0,c))}}_setBits(u,c,f){c?this.data[u]|=f:this.data[u]&=65535^f}get size(){return this.data.byteLength*8}hashCode(){return a.MurmurHash.hashCode(this.data,22)}equals(u){if(u===this)return!0;if(!(u instanceof qn))return!1;const c=this.length();if(c!==u.length())return!1;if(c===0)return!0;let f=x(c-1);for(let A=0;A<=f;A++)if(this.data[A]!==u.data[A])return!1;return!0}toString(){let u="{",c=!0;for(let f=this.nextSetBit(0);f>=0;f=this.nextSetBit(f+1))c?c=!1:u+=", ",u+=f;return u+="}",u}xor(u){const c=this.data,f=u.data,A=Math.min(c.length,f.length),d=Math.max(c.length,f.length),_=c.length===d?c:new Uint16Array(d);let m=-1;for(let E=0;E<A;E++)(_[E]=c[E]^f[E])!==0&&(m=E);const S=c.length>f.length?c:f;for(let E=A;E<d;E++)(_[E]=S[E])!==0&&(m=E);m===-1?this.data=p:_.length===m+1?this.data=_:this.data=_.slice(0,m+1)}clone(){return new qn(this)}[Symbol.iterator](){return new e(this.data)}[l.inspect.custom](){return"BitSet "+this.toString()}};vn.BitSet=o;class e{constructor(u){this.data=u,this.index=0,this.mask=65535}next(){for(;this.index<this.data.length;){const u=this.data[this.index]&this.mask;if(u!==0){const c=h(this.index)+s(u);return this.mask=n(c+1,15),{done:!1,value:c}}this.index++,this.mask=65535}return{done:!0,value:-1}}[Symbol.iterator](){return this}}return vn}var $o;function Yn(){if($o)return dr;$o=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=dr&&dr.__decorate||function(_,m,S,E){var g=arguments.length,T=g<3?m:E===null?E=Object.getOwnPropertyDescriptor(m,S):E,N;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")T=Reflect.decorate(_,m,S,E);else for(var y=_.length-1;y>=0;y--)(N=_[y])&&(T=(g<3?N(T):g>3?N(m,S,T):N(m,S))||T);return g>3&&T&&Object.defineProperty(m,S,T),T};Object.defineProperty(dr,"__esModule",{value:!0}),dr.ATNConfigSet=void 0;const a=pn(),p=Jt(),x=ii(),h=ze(),s=ui(),r=er(),n=z(),t=qe(),o=Be(),e=$i(),i=fn(),u=be(),c=Xt();class f{hashCode(m){return m.state^m.alt}equals(m,S){return m.state===S.state&&m.alt===S.alt}}f.INSTANCE=new f;function A(_){return _?new a.Array2DHashMap(_):new a.Array2DHashMap(f.INSTANCE)}let d=class qi{constructor(m,S){this._uniqueAlt=0,this._hasSemanticContext=!1,this._dipsIntoOuterContext=!1,this.outermostConfigSet=!1,this.cachedHashCode=-1,m?(S?(this.mergedConfigs=void 0,this.unmerged=void 0):m.isReadOnly?(this.mergedConfigs=A(),this.unmerged=[]):(this.mergedConfigs=A(m.mergedConfigs),this.unmerged=m.unmerged.slice(0)),this.configs=m.configs.slice(0),this._dipsIntoOuterContext=m._dipsIntoOuterContext,this._hasSemanticContext=m._hasSemanticContext,this.outermostConfigSet=m.outermostConfigSet,(S||!m.isReadOnly)&&(this._uniqueAlt=m._uniqueAlt,this._conflictInfo=m._conflictInfo)):(this.mergedConfigs=A(),this.unmerged=[],this.configs=[],this._uniqueAlt=h.ATN.INVALID_ALT_NUMBER)}getRepresentedAlternatives(){if(this._conflictInfo!=null)return this._conflictInfo.conflictedAlts.clone();let m=new r.BitSet;for(let S of this)m.set(S.alt);return m}get isReadOnly(){return this.mergedConfigs==null}get isOutermostConfigSet(){return this.outermostConfigSet}set isOutermostConfigSet(m){if(this.outermostConfigSet&&!m)throw new Error("IllegalStateException");u(!m||!this._dipsIntoOuterContext),this.outermostConfigSet=m}getStates(){let m=new p.Array2DHashSet(t.ObjectEqualityComparator.INSTANCE);for(let S of this.configs)m.add(S.state);return m}optimizeConfigs(m){if(this.configs.length!==0)for(let S of this.configs)S.context=m.atn.getCachedContext(S.context)}clone(m){let S=new qi(this,m);return!m&&this.isReadOnly&&S.addAll(this.configs),S}get size(){return this.configs.length}get isEmpty(){return this.configs.length===0}contains(m){if(!(m instanceof s.ATNConfig))return!1;if(this.mergedConfigs&&this.unmerged){let S=m,E=this.getKey(S),g=this.mergedConfigs.get(E);if(g!=null&&this.canMerge(S,E,g))return g.contains(S);for(let T of this.unmerged)if(T.contains(m))return!0}else for(let S of this.configs)if(S.contains(m))return!0;return!1}*[Symbol.iterator](){yield*this.configs}toArray(){return this.configs}add(m,S){if(this.ensureWritable(),!this.mergedConfigs||!this.unmerged)throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");u(!this.outermostConfigSet||!m.reachesIntoOuterContext),S==null&&(S=e.PredictionContextCache.UNCACHED);let E,g=this.getKey(m),T=this.mergedConfigs.get(g);if(E=T==null,T!=null&&this.canMerge(m,g,T)){T.outerContextDepth=Math.max(T.outerContextDepth,m.outerContextDepth),m.isPrecedenceFilterSuppressed&&(T.isPrecedenceFilterSuppressed=!0);let N=o.PredictionContext.join(T.context,m.context,S);return this.updatePropertiesForMergedConfig(m),T.context===N?!1:(T.context=N,!0)}for(let N=0;N<this.unmerged.length;N++){let y=this.unmerged[N];if(this.canMerge(m,g,y)){y.outerContextDepth=Math.max(y.outerContextDepth,m.outerContextDepth),m.isPrecedenceFilterSuppressed&&(y.isPrecedenceFilterSuppressed=!0);let O=o.PredictionContext.join(y.context,m.context,S);return this.updatePropertiesForMergedConfig(m),y.context===O?!1:(y.context=O,E&&(this.mergedConfigs.put(g,y),this.unmerged.splice(N,1)),!0)}}return this.configs.push(m),E?this.mergedConfigs.put(g,m):this.unmerged.push(m),this.updatePropertiesForAddedConfig(m),!0}updatePropertiesForMergedConfig(m){this._dipsIntoOuterContext=this._dipsIntoOuterContext||m.reachesIntoOuterContext,u(!this.outermostConfigSet||!this._dipsIntoOuterContext)}updatePropertiesForAddedConfig(m){this.configs.length===1?this._uniqueAlt=m.alt:this._uniqueAlt!==m.alt&&(this._uniqueAlt=h.ATN.INVALID_ALT_NUMBER),this._hasSemanticContext=this._hasSemanticContext||!i.SemanticContext.NONE.equals(m.semanticContext),this._dipsIntoOuterContext=this._dipsIntoOuterContext||m.reachesIntoOuterContext,u(!this.outermostConfigSet||!this._dipsIntoOuterContext)}canMerge(m,S,E){return m.state.stateNumber!==E.state.stateNumber||S.alt!==E.alt?!1:m.semanticContext.equals(E.semanticContext)}getKey(m){return{state:m.state.stateNumber,alt:m.alt}}containsAll(m){for(let S of m)if(!(S instanceof s.ATNConfig)||!this.contains(S))return!1;return!0}addAll(m,S){this.ensureWritable();let E=!1;for(let g of m)this.add(g,S)&&(E=!0);return E}clear(){if(this.ensureWritable(),!this.mergedConfigs||!this.unmerged)throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");this.mergedConfigs.clear(),this.unmerged.length=0,this.configs.length=0,this._dipsIntoOuterContext=!1,this._hasSemanticContext=!1,this._uniqueAlt=h.ATN.INVALID_ALT_NUMBER,this._conflictInfo=void 0}equals(m){return this===m?!0:m instanceof qi?this.outermostConfigSet===m.outermostConfigSet&&c.equals(this._conflictInfo,m._conflictInfo)&&x.ArrayEqualityComparator.INSTANCE.equals(this.configs,m.configs):!1}hashCode(){if(this.isReadOnly&&this.cachedHashCode!==-1)return this.cachedHashCode;let m=1;return m=5*m^(this.outermostConfigSet?1:0),m=5*m^x.ArrayEqualityComparator.INSTANCE.hashCode(this.configs),this.isReadOnly&&(this.cachedHashCode=m),m}toString(m){m==null&&(m=!1);let S="",E=this.configs.slice(0);E.sort((g,T)=>g.alt!==T.alt?g.alt-T.alt:g.state.stateNumber!==T.state.stateNumber?g.state.stateNumber-T.state.stateNumber:g.semanticContext.toString().localeCompare(T.semanticContext.toString())),S+="[";for(let g=0;g<E.length;g++)g>0&&(S+=", "),S+=E[g].toString(void 0,!0,m);return S+="]",this._hasSemanticContext&&(S+=",hasSemanticContext="+this._hasSemanticContext),this._uniqueAlt!==h.ATN.INVALID_ALT_NUMBER&&(S+=",uniqueAlt="+this._uniqueAlt),this._conflictInfo!=null&&(S+=",conflictingAlts="+this._conflictInfo.conflictedAlts,this._conflictInfo.isExact||(S+="*")),this._dipsIntoOuterContext&&(S+=",dipsIntoOuterContext"),S.toString()}get uniqueAlt(){return this._uniqueAlt}get hasSemanticContext(){return this._hasSemanticContext}set hasSemanticContext(m){this.ensureWritable(),this._hasSemanticContext=m}get conflictInfo(){return this._conflictInfo}set conflictInfo(m){this.ensureWritable(),this._conflictInfo=m}get conflictingAlts(){if(this._conflictInfo!=null)return this._conflictInfo.conflictedAlts}get isExactConflict(){return this._conflictInfo==null?!1:this._conflictInfo.isExact}get dipsIntoOuterContext(){return this._dipsIntoOuterContext}get(m){return this.configs[m]}ensureWritable(){if(this.isReadOnly)throw new Error("This ATNConfigSet is read only.")}};return l([n.NotNull],d.prototype,"getRepresentedAlternatives",null),l([n.Override],d.prototype,"size",null),l([n.Override],d.prototype,"isEmpty",null),l([n.Override],d.prototype,"contains",null),l([n.Override],d.prototype,Symbol.iterator,null),l([n.Override],d.prototype,"toArray",null),l([n.Override],d.prototype,"containsAll",null),l([n.Override],d.prototype,"clear",null),l([n.Override],d.prototype,"equals",null),l([n.Override],d.prototype,"hashCode",null),dr.ATNConfigSet=d,dr}var _r={},Ar={},mr={},Qo;function li(){return Qo||(Qo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=mr&&mr.__decorate||function(e,i,u,c){var f=arguments.length,A=f<3?i:c===null?c=Object.getOwnPropertyDescriptor(i,u):c,d;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")A=Reflect.decorate(e,i,u,c);else for(var _=e.length-1;_>=0;_--)(d=e[_])&&(A=(f<3?d(A):f>3?d(i,u,A):d(i,u))||A);return f>3&&A&&Object.defineProperty(i,u,A),A},p=mr&&mr.__param||function(e,i){return function(u,c){i(u,c,e)}};Object.defineProperty(l,"__esModule",{value:!0}),l.DFAState=void 0;const x=ze(),h=er(),s=xe(),r=z(),n=Be(),t=be();let o=class wl{constructor(i){this.stateNumber=-1,this.configs=i,this.edges=new Map,this.contextEdges=new Map}get isContextSensitive(){return!!this.contextSymbols}isContextSymbol(i){return this.isContextSensitive?this.contextSymbols.get(i):!1}setContextSymbol(i){t(this.isContextSensitive),this.contextSymbols.set(i)}setContextSensitive(i){t(!this.configs.isOutermostConfigSet),!this.isContextSensitive&&(this.contextSymbols||(this.contextSymbols=new h.BitSet))}get acceptStateInfo(){return this._acceptStateInfo}set acceptStateInfo(i){this._acceptStateInfo=i}get isAcceptState(){return!!this._acceptStateInfo}get prediction(){return this._acceptStateInfo?this._acceptStateInfo.prediction:x.ATN.INVALID_ALT_NUMBER}get lexerActionExecutor(){if(this._acceptStateInfo)return this._acceptStateInfo.lexerActionExecutor}getTarget(i){return this.edges.get(i)}setTarget(i,u){this.edges.set(i,u)}getEdgeMap(){return this.edges}getContextTarget(i){return i===n.PredictionContext.EMPTY_FULL_STATE_KEY&&(i=-1),this.contextEdges.get(i)}setContextTarget(i,u){if(!this.isContextSensitive)throw new Error("The state is not context sensitive.");i===n.PredictionContext.EMPTY_FULL_STATE_KEY&&(i=-1),this.contextEdges.set(i,u)}getContextEdgeMap(){let i=new Map(this.contextEdges),u=i.get(-1);if(u!==void 0)if(i.size===1){let c=new Map;return c.set(n.PredictionContext.EMPTY_FULL_STATE_KEY,u),c}else i.delete(-1),i.set(n.PredictionContext.EMPTY_FULL_STATE_KEY,u);return i}hashCode(){let i=s.MurmurHash.initialize(7);return i=s.MurmurHash.update(i,this.configs.hashCode()),i=s.MurmurHash.finish(i,1),i}equals(i){if(this===i)return!0;if(!(i instanceof wl))return!1;let u=i;return this.configs.equals(u.configs)}toString(){let i="";return i+=this.stateNumber+":"+this.configs,this.isAcceptState&&(i+="=>",this.predicates?i+=this.predicates:i+=this.prediction),i.toString()}};a([r.NotNull],o.prototype,"configs",void 0),a([r.NotNull],o.prototype,"edges",void 0),a([r.NotNull],o.prototype,"contextEdges",void 0),a([r.Override],o.prototype,"hashCode",null),a([r.Override],o.prototype,"equals",null),a([r.Override],o.prototype,"toString",null),l.DFAState=o,function(e){let i=class{constructor(c,f){this.alt=f,this.pred=c}toString(){return"("+this.pred+", "+this.alt+")"}};a([r.NotNull],i.prototype,"pred",void 0),a([r.Override],i.prototype,"toString",null),i=a([p(0,r.NotNull)],i),e.PredPrediction=i}(o=l.DFAState||(l.DFAState={}))}(mr)),mr}var Zo;function ai(){return Zo||(Zo=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=Ar&&Ar.__decorate||function(t,o,e,i){var u=arguments.length,c=u<3?o:i===null?i=Object.getOwnPropertyDescriptor(o,e):i,f;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")c=Reflect.decorate(t,o,e,i);else for(var A=t.length-1;A>=0;A--)(f=t[A])&&(c=(u<3?f(c):u>3?f(o,e,c):f(o,e))||c);return u>3&&c&&Object.defineProperty(o,e,c),c},p=Ar&&Ar.__param||function(t,o){return function(e,i){o(e,i,t)}};Object.defineProperty(l,"__esModule",{value:!0}),l.ATNSimulator=void 0;const x=Yn(),h=li(),s=z(),r=Be();let n=class zn{constructor(o){this.atn=o}static get ERROR(){return zn._ERROR||(zn._ERROR=new h.DFAState(new x.ATNConfigSet),zn._ERROR.stateNumber=r.PredictionContext.EMPTY_FULL_STATE_KEY),zn._ERROR}clearDFA(){this.atn.clearDFA()}};a([s.NotNull],n.prototype,"atn",void 0),a([s.NotNull],n,"ERROR",null),n=a([p(0,s.NotNull)],n),l.ATNSimulator=n,n=l.ATNSimulator||(l.ATNSimulator={}),l.ATNSimulator=n}(Ar)),Ar}var Je={},Cn={},Jo;function Bl(){if(Jo)return Cn;Jo=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Cn,"__esModule",{value:!0}),Cn.ConsoleErrorListener=void 0;let l=class{syntaxError(p,x,h,s,r,n){console.error(`line ${h}:${s} ${r}`)}};return Cn.ConsoleErrorListener=l,l.INSTANCE=new l,Cn}var et={},es;function eo(){if(es)return et;es=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=et&&et.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o},a=et&&et.__param||function(h,s){return function(r,n){s(r,n,h)}};Object.defineProperty(et,"__esModule",{value:!0}),et.ProxyErrorListener=void 0;const p=z();let x=class{constructor(s){if(this.delegates=s,!s)throw new Error("Invalid delegates")}getDelegates(){return this.delegates}syntaxError(s,r,n,t,o,e){this.delegates.forEach(i=>{i.syntaxError&&i.syntaxError(s,r,n,t,o,e)})}};return l([p.Override,a(0,p.NotNull),a(4,p.NotNull)],x.prototype,"syntaxError",null),et.ProxyErrorListener=x,et}var ts;function Xn(){if(ts)return Je;ts=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Je&&Je.__decorate||function(t,o,e,i){var u=arguments.length,c=u<3?o:i===null?i=Object.getOwnPropertyDescriptor(o,e):i,f;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")c=Reflect.decorate(t,o,e,i);else for(var A=t.length-1;A>=0;A--)(f=t[A])&&(c=(u<3?f(c):u>3?f(o,e,c):f(o,e))||c);return u>3&&c&&Object.defineProperty(o,e,c),c},a=Je&&Je.__param||function(t,o){return function(e,i){o(e,i,t)}};Object.defineProperty(Je,"__esModule",{value:!0}),Je.Recognizer=void 0;const p=Bl(),x=eo(),h=z(),s=pe(),r=Xt();let n=class Un{constructor(){this._listeners=[p.ConsoleErrorListener.INSTANCE],this._stateNumber=-1}getTokenTypeMap(){let o=this.vocabulary,e=Un.tokenTypeMapCache.get(o);if(e==null){let i=new Map;for(let u=0;u<=this.atn.maxTokenType;u++){let c=o.getLiteralName(u);c!=null&&i.set(c,u);let f=o.getSymbolicName(u);f!=null&&i.set(f,u)}i.set("EOF",s.Token.EOF),e=i,Un.tokenTypeMapCache.set(o,e)}return e}getRuleIndexMap(){let o=this.ruleNames;if(o==null)throw new Error("The current recognizer does not provide a list of rule names.");let e=Un.ruleIndexMapCache.get(o);return e==null&&(e=r.toMap(o),Un.ruleIndexMapCache.set(o,e)),e}getTokenType(o){let e=this.getTokenTypeMap().get(o);return e??s.Token.INVALID_TYPE}get serializedATN(){throw new Error("there is no serialized ATN")}get atn(){return this._interp.atn}get interpreter(){return this._interp}set interpreter(o){this._interp=o}get parseInfo(){return Promise.resolve(void 0)}getErrorHeader(o){let e=o.getOffendingToken();if(!e)return"";let i=e.line,u=e.charPositionInLine;return"line "+i+":"+u}addErrorListener(o){if(!o)throw new TypeError("listener must not be null");this._listeners.push(o)}removeErrorListener(o){let e=this._listeners.indexOf(o);e!==-1&&this._listeners.splice(e,1)}removeErrorListeners(){this._listeners.length=0}getErrorListeners(){return this._listeners.slice(0)}getErrorListenerDispatch(){return new x.ProxyErrorListener(this.getErrorListeners())}sempred(o,e,i){return!0}precpred(o,e){return!0}action(o,e,i){}get state(){return this._stateNumber}set state(o){this._stateNumber=o}};return n.EOF=-1,n.tokenTypeMapCache=new WeakMap,n.ruleIndexMapCache=new WeakMap,l([h.SuppressWarnings("serial"),h.NotNull],n.prototype,"_listeners",void 0),l([h.NotNull],n.prototype,"getTokenTypeMap",null),l([h.NotNull],n.prototype,"getRuleIndexMap",null),l([h.NotNull],n.prototype,"serializedATN",null),l([h.NotNull],n.prototype,"atn",null),l([h.NotNull,a(0,h.NotNull)],n.prototype,"interpreter",null),l([h.NotNull,a(0,h.NotNull)],n.prototype,"getErrorHeader",null),l([a(0,h.NotNull)],n.prototype,"addErrorListener",null),l([a(0,h.NotNull)],n.prototype,"removeErrorListener",null),l([h.NotNull],n.prototype,"getErrorListeners",null),Je.Recognizer=n,Je}var Sr={},rs;function ln(){if(rs)return Sr;rs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Sr&&Sr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(Sr,"__esModule",{value:!0}),Sr.VocabularyImpl=void 0;const a=z(),p=pe();let x=class{constructor(s,r,n){this.literalNames=s,this.symbolicNames=r,this.displayNames=n,this._maxTokenType=Math.max(this.displayNames.length,Math.max(this.literalNames.length,this.symbolicNames.length))-1}get maxTokenType(){return this._maxTokenType}getLiteralName(s){if(s>=0&&s<this.literalNames.length)return this.literalNames[s]}getSymbolicName(s){if(s>=0&&s<this.symbolicNames.length)return this.symbolicNames[s];if(s===p.Token.EOF)return"EOF"}getDisplayName(s){if(s>=0&&s<this.displayNames.length){let t=this.displayNames[s];if(t)return t}let r=this.getLiteralName(s);if(r)return r;let n=this.getSymbolicName(s);return n||String(s)}};return x.EMPTY_VOCABULARY=new x([],[],[]),l([a.NotNull],x.prototype,"literalNames",void 0),l([a.NotNull],x.prototype,"symbolicNames",void 0),l([a.NotNull],x.prototype,"displayNames",void 0),l([a.Override],x.prototype,"maxTokenType",null),l([a.Override],x.prototype,"getLiteralName",null),l([a.Override],x.prototype,"getSymbolicName",null),l([a.Override,a.NotNull],x.prototype,"getDisplayName",null),l([a.NotNull],x,"EMPTY_VOCABULARY",void 0),Sr.VocabularyImpl=x,Sr}var ns;function Ml(){if(ns)return _r;ns=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=_r&&_r.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u};Object.defineProperty(_r,"__esModule",{value:!0}),_r.DFASerializer=void 0;const a=ai(),p=z(),x=Be(),h=Xn(),s=ln();let r=class{constructor(t,o,e,i){o instanceof h.Recognizer?(e=o.ruleNames,i=o.atn,o=o.vocabulary):o||(o=s.VocabularyImpl.EMPTY_VOCABULARY),this.dfa=t,this.vocabulary=o,this.ruleNames=e,this.atn=i}toString(){if(!this.dfa.s0)return"";let t="";if(this.dfa.states){let e=new Array(...this.dfa.states.toArray());e.sort((i,u)=>i.stateNumber-u.stateNumber);for(let i of e){let u=i.getEdgeMap(),c=[...u.keys()].sort((d,_)=>d-_),f=i.getContextEdgeMap(),A=[...f.keys()].sort((d,_)=>d-_);for(let d of c){let _=u.get(d);if((_==null||_===a.ATNSimulator.ERROR)&&!i.isContextSymbol(d))continue;let m=!1;t+=this.getStateString(i)+"-"+this.getEdgeLabel(d)+"->",i.isContextSymbol(d)&&(t+="!",m=!0);let S=_;S&&S.stateNumber!==a.ATNSimulator.ERROR.stateNumber?t+=this.getStateString(S)+`
`:m&&(t+=`ctx
`)}if(i.isContextSensitive)for(let d of A)t+=this.getStateString(i)+"-"+this.getContextLabel(d)+"->"+this.getStateString(f.get(d))+`
`}}let o=t;return o.length===0?"":o}getContextLabel(t){if(t===x.PredictionContext.EMPTY_FULL_STATE_KEY)return"ctx:EMPTY_FULL";if(t===x.PredictionContext.EMPTY_LOCAL_STATE_KEY)return"ctx:EMPTY_LOCAL";if(this.atn&&t>0&&t<=this.atn.states.length){let e=this.atn.states[t].ruleIndex;if(this.ruleNames&&e>=0&&e<this.ruleNames.length)return"ctx:"+String(t)+"("+this.ruleNames[e]+")"}return"ctx:"+String(t)}getEdgeLabel(t){return this.vocabulary.getDisplayName(t)}getStateString(t){if(t===a.ATNSimulator.ERROR)return"ERROR";let o=t.stateNumber,e="s"+o;if(t.isAcceptState&&(t.predicates?e=":s"+o+"=>"+t.predicates:e=":s"+o+"=>"+t.prediction),t.isContextSensitive){e+="*";for(let i of t.configs)if(i.reachesIntoOuterContext){e+="*";break}}return e}};return l([p.NotNull],r.prototype,"dfa",void 0),l([p.NotNull],r.prototype,"vocabulary",void 0),l([p.Override],r.prototype,"toString",null),_r.DFASerializer=r,_r}var tt={},is;function Pa(){if(is)return tt;is=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=tt&&tt.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=tt&&tt.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(tt,"__esModule",{value:!0}),tt.LexerDFASerializer=void 0;const p=Ml(),x=z(),h=ln();let s=class extends p.DFASerializer{constructor(n){super(n,h.VocabularyImpl.EMPTY_VOCABULARY)}getEdgeLabel(n){return"'"+String.fromCodePoint(n)+"'"}};return l([x.Override,x.NotNull],s.prototype,"getEdgeLabel",null),s=l([a(0,x.NotNull)],s),tt.LexerDFASerializer=s,tt}var Er={},os;function to(){if(os)return Er;os=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Er&&Er.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(Er,"__esModule",{value:!0}),Er.StarLoopEntryState=void 0;const a=Te(),p=er(),x=un(),h=z();let s=class extends x.DecisionState{constructor(){super(...arguments),this.precedenceRuleDecision=!1,this.precedenceLoopbackStates=new p.BitSet}get stateType(){return a.ATNStateType.STAR_LOOP_ENTRY}};return l([h.Override],s.prototype,"stateType",null),Er.StarLoopEntryState=s,Er}var ss;function kl(){if(ss)return Qe;ss=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Qe&&Qe.__decorate||function(u,c,f,A){var d=arguments.length,_=d<3?c:A===null?A=Object.getOwnPropertyDescriptor(c,f):A,m;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")_=Reflect.decorate(u,c,f,A);else for(var S=u.length-1;S>=0;S--)(m=u[S])&&(_=(d<3?m(_):d>3?m(c,f,_):m(c,f))||_);return d>3&&_&&Object.defineProperty(c,f,_),_},a=Qe&&Qe.__param||function(u,c){return function(f,A){c(f,A,u)}};Object.defineProperty(Qe,"__esModule",{value:!0}),Qe.DFA=void 0;const p=Jt(),x=Yn(),h=Ml(),s=li(),r=Pa(),n=z(),t=qe(),o=to(),e=ln();let i=class{constructor(c,f=0){if(this.states=new p.Array2DHashSet(t.ObjectEqualityComparator.INSTANCE),this.nextStateNumber=0,!c.atn)throw new Error("The ATNState must be associated with an ATN");this.atnStartState=c,this.atn=c.atn,this.decision=f;let A=!1;c instanceof o.StarLoopEntryState&&c.precedenceRuleDecision&&(A=!0,this.s0=new s.DFAState(new x.ATNConfigSet),this.s0full=new s.DFAState(new x.ATNConfigSet)),this.precedenceDfa=A}get isPrecedenceDfa(){return this.precedenceDfa}getPrecedenceStartState(c,f){if(!this.isPrecedenceDfa)throw new Error("Only precedence DFAs may contain a precedence start state.");return f?this.s0full.getTarget(c):this.s0.getTarget(c)}setPrecedenceStartState(c,f,A){if(!this.isPrecedenceDfa)throw new Error("Only precedence DFAs may contain a precedence start state.");c<0||(f?this.s0full.setTarget(c,A):this.s0.setTarget(c,A))}get isEmpty(){return this.isPrecedenceDfa?this.s0.getEdgeMap().size===0&&this.s0full.getEdgeMap().size===0:this.s0==null&&this.s0full==null}get isContextSensitive(){return this.isPrecedenceDfa?this.s0full.getEdgeMap().size>0:this.s0full!=null}addState(c){return c.stateNumber=this.nextStateNumber++,this.states.getOrAdd(c)}toString(c,f){if(c||(c=e.VocabularyImpl.EMPTY_VOCABULARY),!this.s0)return"";let A;return f?A=new h.DFASerializer(this,c,f,this.atnStartState.atn):A=new h.DFASerializer(this,c),A.toString()}toLexerString(){return this.s0?new r.LexerDFASerializer(this).toString():""}};return l([n.NotNull],i.prototype,"states",void 0),l([n.NotNull],i.prototype,"atnStartState",void 0),l([n.NotNull],i.prototype,"atn",void 0),i=l([a(0,n.NotNull)],i),Qe.DFA=i,Qe}var Tr={},gr={},us;function jl(){if(us)return gr;us=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=gr&&gr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(gr,"__esModule",{value:!0}),gr.BasicState=void 0;const a=Yt(),p=Te(),x=z();let h=class extends a.ATNState{get stateType(){return p.ATNStateType.BASIC}};return l([x.Override],h.prototype,"stateType",null),gr.BasicState=h,gr}var ls;function ql(){if(ls)return Tr;ls=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Tr&&Tr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Tr,"__esModule",{value:!0}),Tr.InvalidState=void 0;const a=Te(),p=jl(),x=z();let h=class extends p.BasicState{get stateType(){return a.ATNStateType.INVALID_TYPE}};return l([x.Override],h.prototype,"stateType",null),Tr.InvalidState=h,Tr}var rt={},nt={},it={},as;function ro(){if(as)return it;as=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=it&&it.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u},a=it&&it.__param||function(n,t){return function(o,e){t(o,e,n)}};Object.defineProperty(it,"__esModule",{value:!0}),it.SetTransition=void 0;const p=an(),x=z(),h=pe(),s=Zt();let r=class extends s.Transition{constructor(t,o){super(t),o==null&&(o=p.IntervalSet.of(h.Token.INVALID_TYPE)),this.set=o}get serializationType(){return 7}get label(){return this.set}matches(t,o,e){return this.set.contains(t)}toString(){return this.set.toString()}};return l([x.NotNull],r.prototype,"set",void 0),l([x.Override],r.prototype,"serializationType",null),l([x.Override,x.NotNull],r.prototype,"label",null),l([x.Override],r.prototype,"matches",null),l([x.Override,x.NotNull],r.prototype,"toString",null),r=l([a(0,x.NotNull),a(1,x.Nullable)],r),it.SetTransition=r,it}var cs;function no(){if(cs)return nt;cs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=nt&&nt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=nt&&nt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(nt,"__esModule",{value:!0}),nt.NotSetTransition=void 0;const p=z(),x=ro();let h=class extends x.SetTransition{constructor(r,n){super(r,n)}get serializationType(){return 8}matches(r,n,t){return r>=n&&r<=t&&!super.matches(r,n,t)}toString(){return"~"+super.toString()}};return l([p.Override],h.prototype,"serializationType",null),l([p.Override],h.prototype,"matches",null),l([p.Override],h.prototype,"toString",null),h=l([a(0,p.NotNull),a(1,p.Nullable)],h),nt.NotSetTransition=h,nt}var yr={},hs;function Wn(){if(hs)return yr;hs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=yr&&yr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(yr,"__esModule",{value:!0}),yr.RuleStopState=void 0;const a=Yt(),p=Te(),x=z();let h=class extends a.ATNState{get nonStopStateNumber(){return-1}get stateType(){return p.ATNStateType.RULE_STOP}};return l([x.Override],h.prototype,"nonStopStateNumber",null),l([x.Override],h.prototype,"stateType",null),yr.RuleStopState=h,yr}var ot={},fs;function io(){if(fs)return ot;fs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ot&&ot.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=ot&&ot.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(ot,"__esModule",{value:!0}),ot.RuleTransition=void 0;const p=z(),x=Zt();let h=class extends x.Transition{constructor(r,n,t,o){super(r),this.tailCall=!1,this.optimizedTailCall=!1,this.ruleIndex=n,this.precedence=t,this.followState=o}get serializationType(){return 3}get isEpsilon(){return!0}matches(r,n,t){return!1}};return l([p.NotNull],h.prototype,"followState",void 0),l([p.Override],h.prototype,"serializationType",null),l([p.Override],h.prototype,"isEpsilon",null),l([p.Override],h.prototype,"matches",null),h=l([a(0,p.NotNull),a(3,p.NotNull)],h),ot.RuleTransition=h,ot}var st={},ps;function zl(){if(ps)return st;ps=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=st&&st.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=st&&st.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(st,"__esModule",{value:!0}),st.WildcardTransition=void 0;const p=z(),x=Zt();let h=class extends x.Transition{constructor(r){super(r)}get serializationType(){return 9}matches(r,n,t){return r>=n&&r<=t}toString(){return"."}};return l([p.Override],h.prototype,"serializationType",null),l([p.Override],h.prototype,"matches",null),l([p.Override,p.NotNull],h.prototype,"toString",null),h=l([a(0,p.NotNull)],h),st.WildcardTransition=h,st}var ds;function La(){if(ds)return rt;ds=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=rt&&rt.__decorate||function(d,_,m,S){var E=arguments.length,g=E<3?_:S===null?S=Object.getOwnPropertyDescriptor(_,m):S,T;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")g=Reflect.decorate(d,_,m,S);else for(var N=d.length-1;N>=0;N--)(T=d[N])&&(g=(E<3?T(g):E>3?T(_,m,g):T(_,m))||g);return E>3&&g&&Object.defineProperty(_,m,g),g},a=rt&&rt.__param||function(d,_){return function(m,S){_(m,S,d)}};Object.defineProperty(rt,"__esModule",{value:!0}),rt.LL1Analyzer=void 0;const p=Xi(),x=Jt(),h=ui(),s=er(),r=an(),n=z(),t=no(),o=qe(),e=Be(),i=Wn(),u=io(),c=pe(),f=zl();let A=class zi{constructor(_){this.atn=_}getDecisionLookahead(_){if(_==null)return;let m=new Array(_.numberOfTransitions);for(let S=0;S<_.numberOfTransitions;S++){let E=new r.IntervalSet;m[S]=E;let g=new x.Array2DHashSet(o.ObjectEqualityComparator.INSTANCE);this._LOOK(_.transition(S).target,void 0,e.PredictionContext.EMPTY_LOCAL,E,g,new s.BitSet,!1,!1),(E.size===0||E.contains(zi.HIT_PRED))&&(E=void 0,m[S]=E)}return m}LOOK(_,m,S){if(S===void 0){if(_.atn==null)throw new Error("Illegal state");S=_.atn.ruleToStopState[_.ruleIndex]}else S===null&&(S=void 0);let E=new r.IntervalSet;return this._LOOK(_,S,m,E,new x.Array2DHashSet,new s.BitSet,!0,!0),E}_LOOK(_,m,S,E,g,T,N,y){let O=h.ATNConfig.create(_,0,S);if(!g.add(O))return;if(_===m){if(e.PredictionContext.isEmptyLocal(S)){E.add(c.Token.EPSILON);return}else if(S.isEmpty){y&&E.add(c.Token.EOF);return}}if(_ instanceof i.RuleStopState){if(S.isEmpty&&!e.PredictionContext.isEmptyLocal(S)){y&&E.add(c.Token.EOF);return}let w=T.get(_.ruleIndex);try{T.clear(_.ruleIndex);for(let M=0;M<S.size;M++){if(S.getReturnState(M)===e.PredictionContext.EMPTY_FULL_STATE_KEY)continue;let W=this.atn.states[S.getReturnState(M)];this._LOOK(W,m,S.getParent(M),E,g,T,N,y)}}finally{w&&T.set(_.ruleIndex)}}let F=_.numberOfTransitions;for(let w=0;w<F;w++){let M=_.transition(w);if(M instanceof u.RuleTransition){if(T.get(M.ruleIndex))continue;let W=S.getChild(M.followState.stateNumber);try{T.set(M.ruleIndex),this._LOOK(M.target,m,W,E,g,T,N,y)}finally{T.clear(M.ruleIndex)}}else if(M instanceof p.AbstractPredicateTransition)N?this._LOOK(M.target,m,S,E,g,T,N,y):E.add(zi.HIT_PRED);else if(M.isEpsilon)this._LOOK(M.target,m,S,E,g,T,N,y);else if(M instanceof f.WildcardTransition)E.addAll(r.IntervalSet.of(c.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType));else{let W=M.label;W!=null&&(M instanceof t.NotSetTransition&&(W=W.complement(r.IntervalSet.of(c.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType))),E.addAll(W))}}}};return A.HIT_PRED=c.Token.INVALID_TYPE,l([n.NotNull],A.prototype,"atn",void 0),l([n.NotNull,a(0,n.NotNull),a(1,n.NotNull)],A.prototype,"LOOK",null),l([a(0,n.NotNull),a(2,n.NotNull),a(3,n.NotNull),a(4,n.NotNull),a(5,n.NotNull)],A.prototype,"_LOOK",null),A=l([a(0,n.NotNull)],A),rt.LL1Analyzer=A,rt}var xs;function ze(){return xs||(xs=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=pr&&pr.__decorate||function(f,A,d,_){var m=arguments.length,S=m<3?A:_===null?_=Object.getOwnPropertyDescriptor(A,d):_,E;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")S=Reflect.decorate(f,A,d,_);else for(var g=f.length-1;g>=0;g--)(E=f[g])&&(S=(m<3?E(S):m>3?E(A,d,S):E(A,d))||S);return m>3&&S&&Object.defineProperty(A,d,S),S},p=pr&&pr.__param||function(f,A){return function(d,_){A(d,_,f)}};Object.defineProperty(l,"__esModule",{value:!0}),l.ATN=void 0;const x=pn(),h=kl(),s=an(),r=ql(),n=La(),t=z(),o=qe(),e=Be(),i=pe(),u=be();let c=class{constructor(A,d){this.states=[],this.decisionToState=[],this.modeNameToStartState=new Map,this.modeToStartState=[],this.contextCache=new x.Array2DHashMap(o.ObjectEqualityComparator.INSTANCE),this.decisionToDFA=[],this.modeToDFA=[],this.LL1Table=new Map,this.grammarType=A,this.maxTokenType=d}clearDFA(){this.decisionToDFA=new Array(this.decisionToState.length);for(let A=0;A<this.decisionToDFA.length;A++)this.decisionToDFA[A]=new h.DFA(this.decisionToState[A],A);this.modeToDFA=new Array(this.modeToStartState.length);for(let A=0;A<this.modeToDFA.length;A++)this.modeToDFA[A]=new h.DFA(this.modeToStartState[A]);this.contextCache.clear(),this.LL1Table.clear()}get contextCacheSize(){return this.contextCache.size}getCachedContext(A){return e.PredictionContext.getCachedContext(A,this.contextCache,new e.PredictionContext.IdentityHashMap)}getDecisionToDFA(){return u(this.decisionToDFA!=null&&this.decisionToDFA.length===this.decisionToState.length),this.decisionToDFA}nextTokens(A,d){return d?new n.LL1Analyzer(this).LOOK(A,d):(A.nextTokenWithinRule||(A.nextTokenWithinRule=this.nextTokens(A,e.PredictionContext.EMPTY_LOCAL),A.nextTokenWithinRule.setReadonly(!0)),A.nextTokenWithinRule)}addState(A){A.atn=this,A.stateNumber=this.states.length,this.states.push(A)}removeState(A){let d=new r.InvalidState;d.atn=this,d.stateNumber=A.stateNumber,this.states[A.stateNumber]=d}defineMode(A,d){this.modeNameToStartState.set(A,d),this.modeToStartState.push(d),this.modeToDFA.push(new h.DFA(d)),this.defineDecisionState(d)}defineDecisionState(A){return this.decisionToState.push(A),A.decision=this.decisionToState.length-1,this.decisionToDFA.push(new h.DFA(A,A.decision)),A.decision}getDecisionState(A){if(this.decisionToState.length>0)return this.decisionToState[A]}get numberOfDecisions(){return this.decisionToState.length}getExpectedTokens(A,d){if(A<0||A>=this.states.length)throw new RangeError("Invalid state number.");let _=d,m=this.states[A],S=this.nextTokens(m);if(!S.contains(i.Token.EPSILON))return S;let E=new s.IntervalSet;for(E.addAll(S),E.remove(i.Token.EPSILON);_!=null&&_.invokingState>=0&&S.contains(i.Token.EPSILON);){let T=this.states[_.invokingState].transition(0);S=this.nextTokens(T.followState),E.addAll(S),E.remove(i.Token.EPSILON),_=_._parent}return S.contains(i.Token.EPSILON)&&E.add(i.Token.EOF),E}};a([t.NotNull],c.prototype,"states",void 0),a([t.NotNull],c.prototype,"decisionToState",void 0),a([t.NotNull],c.prototype,"modeNameToStartState",void 0),a([t.NotNull],c.prototype,"modeToStartState",void 0),a([t.NotNull],c.prototype,"decisionToDFA",void 0),a([t.NotNull],c.prototype,"modeToDFA",void 0),a([t.NotNull],c.prototype,"nextTokens",null),a([p(0,t.NotNull)],c.prototype,"removeState",null),a([p(0,t.NotNull),p(1,t.NotNull)],c.prototype,"defineMode",null),a([p(0,t.NotNull)],c.prototype,"defineDecisionState",null),a([t.NotNull],c.prototype,"getExpectedTokens",null),c=a([p(0,t.NotNull)],c),l.ATN=c,function(f){f.INVALID_ALT_NUMBER=0}(c=l.ATN||(l.ATN={})),l.ATN=c}(pr)),pr}var ut={},lt={},_s;function Fa(){if(_s)return lt;_s=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=lt&&lt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=lt&&lt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(lt,"__esModule",{value:!0}),lt.LexerIndexedCustomAction=void 0;const p=xe(),x=z();let h=class Ul{constructor(r,n){this._offset=r,this._action=n}get offset(){return this._offset}get action(){return this._action}get actionType(){return this._action.actionType}get isPositionDependent(){return!0}execute(r){this._action.execute(r)}hashCode(){let r=p.MurmurHash.initialize();return r=p.MurmurHash.update(r,this._offset),r=p.MurmurHash.update(r,this._action),p.MurmurHash.finish(r,2)}equals(r){return r===this?!0:r instanceof Ul?this._offset===r._offset&&this._action.equals(r._action):!1}};return l([x.NotNull],h.prototype,"action",null),l([x.Override],h.prototype,"actionType",null),l([x.Override],h.prototype,"isPositionDependent",null),l([x.Override],h.prototype,"execute",null),l([x.Override],h.prototype,"hashCode",null),l([x.Override],h.prototype,"equals",null),h=l([a(1,x.NotNull)],h),lt.LexerIndexedCustomAction=h,lt}var As;function Ia(){if(As)return ut;As=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ut&&ut.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u},a=ut&&ut.__param||function(n,t){return function(o,e){t(o,e,n)}};Object.defineProperty(ut,"__esModule",{value:!0}),ut.LexerActionExecutor=void 0;const p=ii(),x=Fa(),h=xe(),s=z();let r=class Hn{constructor(t){this._lexerActions=t;let o=h.MurmurHash.initialize();for(let e of t)o=h.MurmurHash.update(o,e);this.cachedHashCode=h.MurmurHash.finish(o,t.length)}static append(t,o){if(!t)return new Hn([o]);let e=t._lexerActions.slice(0);return e.push(o),new Hn(e)}fixOffsetBeforeMatch(t){let o;for(let e=0;e<this._lexerActions.length;e++)this._lexerActions[e].isPositionDependent&&!(this._lexerActions[e]instanceof x.LexerIndexedCustomAction)&&(o||(o=this._lexerActions.slice(0)),o[e]=new x.LexerIndexedCustomAction(t,this._lexerActions[e]));return o?new Hn(o):this}get lexerActions(){return this._lexerActions}execute(t,o,e){let i=!1,u=o.index;try{for(let c of this._lexerActions){if(c instanceof x.LexerIndexedCustomAction){let f=c.offset;o.seek(e+f),c=c.action,i=e+f!==u}else c.isPositionDependent&&(o.seek(u),i=!1);c.execute(t)}}finally{i&&o.seek(u)}}hashCode(){return this.cachedHashCode}equals(t){return t===this?!0:t instanceof Hn?this.cachedHashCode===t.cachedHashCode&&p.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions,t._lexerActions):!1}};return l([s.NotNull],r.prototype,"_lexerActions",void 0),l([s.NotNull],r.prototype,"lexerActions",null),l([a(0,s.NotNull)],r.prototype,"execute",null),l([s.Override],r.prototype,"hashCode",null),l([s.Override],r.prototype,"equals",null),l([s.NotNull,a(1,s.NotNull)],r,"append",null),r=l([a(0,s.NotNull)],r),ut.LexerActionExecutor=r,ut}var at={},ms;function ci(){if(ms)return at;ms=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=at&&at.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u},a=at&&at.__param||function(n,t){return function(o,e){t(o,e,n)}};Object.defineProperty(at,"__esModule",{value:!0}),at.LexerNoViableAltException=void 0;const p=Qt(),x=z(),h=ye(),s=Xt();let r=class extends p.RecognitionException{constructor(t,o,e,i){super(t,o),this._startIndex=e,this._deadEndConfigs=i}get startIndex(){return this._startIndex}get deadEndConfigs(){return this._deadEndConfigs}get inputStream(){return super.inputStream}toString(){let t="";return this._startIndex>=0&&this._startIndex<this.inputStream.size&&(t=this.inputStream.getText(h.Interval.of(this._startIndex,this._startIndex)),t=s.escapeWhitespace(t,!1)),`LexerNoViableAltException('${t}')`}};return l([x.Override],r.prototype,"inputStream",null),l([x.Override],r.prototype,"toString",null),r=l([a(1,x.NotNull)],r),at.LexerNoViableAltException=r,at}var Nr={},Ss;function wa(){if(Ss)return Nr;Ss=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Nr&&Nr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(Nr,"__esModule",{value:!0}),Nr.OrderedATNConfigSet=void 0;const a=Yn(),p=z();let x=class Hl extends a.ATNConfigSet{constructor(s,r){s!=null&&r!=null?super(s,r):super()}clone(s){let r=new Hl(this,s);return!s&&this.isReadOnly&&r.addAll(this),r}getKey(s){return{state:0,alt:s.hashCode()}}canMerge(s,r,n){return s.equals(n)}};return l([p.Override],x.prototype,"clone",null),l([p.Override],x.prototype,"getKey",null),l([p.Override],x.prototype,"canMerge",null),Nr.OrderedATNConfigSet=x,Nr}var Es;function hi(){return Es||(Es=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=fr&&fr.__decorate||function(g,T,N,y){var O=arguments.length,F=O<3?T:y===null?y=Object.getOwnPropertyDescriptor(T,N):y,w;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")F=Reflect.decorate(g,T,N,y);else for(var M=g.length-1;M>=0;M--)(w=g[M])&&(F=(O<3?w(F):O>3?w(T,N,F):w(T,N))||F);return O>3&&F&&Object.defineProperty(T,N,F),F},p=fr&&fr.__param||function(g,T){return function(N,y){T(N,y,g)}};Object.defineProperty(l,"__esModule",{value:!0}),l.LexerATNSimulator=void 0;const x=dl(),h=ze(),s=ui(),r=Yn(),n=ai(),t=li(),o=ye(),e=$t(),i=tr(),u=Ia(),c=ci(),f=z(),A=wa(),d=Be(),_=Wn(),m=pe(),S=be();let E=class Oe extends n.ATNSimulator{constructor(T,N){super(T),this.optimize_tail_calls=!0,this.startIndex=-1,this._line=1,this._charPositionInLine=0,this.mode=i.Lexer.DEFAULT_MODE,this.prevAccept=new Oe.SimState,this.recog=N}copyState(T){this._charPositionInLine=T.charPositionInLine,this._line=T._line,this.mode=T.mode,this.startIndex=T.startIndex}match(T,N){this.mode=N;let y=T.mark();try{this.startIndex=T.index,this.prevAccept.reset();let O=this.atn.modeToDFA[N].s0;return O==null?this.matchATN(T):this.execATN(T,O)}finally{T.release(y)}}reset(){this.prevAccept.reset(),this.startIndex=-1,this._line=1,this._charPositionInLine=0,this.mode=i.Lexer.DEFAULT_MODE}matchATN(T){let N=this.atn.modeToStartState[this.mode];Oe.debug&&console.log(`matchATN mode ${this.mode} start: ${N}`);let y=this.mode,O=this.computeStartState(T,N),F=O.hasSemanticContext;F&&(O.hasSemanticContext=!1);let w=this.addDFAState(O);if(!F){let W=this.atn.modeToDFA[this.mode];W.s0?w=W.s0:W.s0=w}let M=this.execATN(T,w);return Oe.debug&&console.log(`DFA after matchATN: ${this.atn.modeToDFA[y].toLexerString()}`),M}execATN(T,N){Oe.debug&&console.log(`start state closure=${N.configs}`),N.isAcceptState&&this.captureSimState(this.prevAccept,T,N);let y=T.LA(1),O=N;for(;;){Oe.debug&&console.log(`execATN loop starting closure: ${O.configs}`);let F=this.getExistingTargetState(O,y);if(F==null&&(F=this.computeTargetState(T,O,y)),F===n.ATNSimulator.ERROR||(y!==e.IntStream.EOF&&this.consume(T),F.isAcceptState&&(this.captureSimState(this.prevAccept,T,F),y===e.IntStream.EOF)))break;y=T.LA(1),O=F}return this.failOrAccept(this.prevAccept,T,O.configs,y)}getExistingTargetState(T,N){let y=T.getTarget(N);return Oe.debug&&y!=null&&console.log("reuse state "+T.stateNumber+" edge to "+y.stateNumber),y}computeTargetState(T,N,y){let O=new A.OrderedATNConfigSet;return this.getReachableConfigSet(T,N.configs,O,y),O.isEmpty?(O.hasSemanticContext||this.addDFAEdge(N,y,n.ATNSimulator.ERROR),n.ATNSimulator.ERROR):this.addDFAEdge(N,y,O)}failOrAccept(T,N,y,O){if(T.dfaState!=null){let F=T.dfaState.lexerActionExecutor;return this.accept(N,F,this.startIndex,T.index,T.line,T.charPos),T.dfaState.prediction}else{if(O===e.IntStream.EOF&&N.index===this.startIndex)return m.Token.EOF;throw new c.LexerNoViableAltException(this.recog,N,this.startIndex,y)}}getReachableConfigSet(T,N,y,O){let F=h.ATN.INVALID_ALT_NUMBER;for(let w of N){let M=w.alt===F;if(M&&w.hasPassedThroughNonGreedyDecision)continue;Oe.debug&&console.log(`testing ${this.getTokenName(O)} at ${w.toString(this.recog,!0)}`);let W=w.state.numberOfOptimizedTransitions;for(let ee=0;ee<W;ee++){let J=w.state.getOptimizedTransition(ee),ae=this.getReachableTarget(J,O);if(ae!=null){let Se=w.lexerActionExecutor,ue;Se!=null?(Se=Se.fixOffsetBeforeMatch(T.index-this.startIndex),ue=w.transform(ae,!0,Se)):(S(w.lexerActionExecutor==null),ue=w.transform(ae,!0));let ke=O===e.IntStream.EOF;if(this.closure(T,ue,y,M,!0,ke)){F=w.alt;break}}}}}accept(T,N,y,O,F,w){Oe.debug&&console.log(`ACTION ${N}`),T.seek(O),this._line=F,this._charPositionInLine=w,N!=null&&this.recog!=null&&N.execute(this.recog,T,y)}getReachableTarget(T,N){if(T.matches(N,i.Lexer.MIN_CHAR_VALUE,i.Lexer.MAX_CHAR_VALUE))return T.target}computeStartState(T,N){let y=d.PredictionContext.EMPTY_FULL,O=new A.OrderedATNConfigSet;for(let F=0;F<N.numberOfTransitions;F++){let w=N.transition(F).target,M=s.ATNConfig.create(w,F+1,y);this.closure(T,M,O,!1,!1,!1)}return O}closure(T,N,y,O,F,w){if(Oe.debug&&console.log("closure("+N.toString(this.recog,!0)+")"),N.state instanceof _.RuleStopState){Oe.debug&&(this.recog!=null?console.log(`closure at ${this.recog.ruleNames[N.state.ruleIndex]} rule stop ${N}`):console.log(`closure at rule stop ${N}`));let W=N.context;if(W.isEmpty)return y.add(N),!0;W.hasEmpty&&(y.add(N.transform(N.state,!0,d.PredictionContext.EMPTY_FULL)),O=!0);for(let ee=0;ee<W.size;ee++){let J=W.getReturnState(ee);if(J===d.PredictionContext.EMPTY_FULL_STATE_KEY)continue;let ae=W.getParent(ee),Se=this.atn.states[J],ue=N.transform(Se,!1,ae);O=this.closure(T,ue,y,O,F,w)}return O}N.state.onlyHasEpsilonTransitions||(!O||!N.hasPassedThroughNonGreedyDecision)&&y.add(N);let M=N.state;for(let W=0;W<M.numberOfOptimizedTransitions;W++){let ee=M.getOptimizedTransition(W),J=this.getEpsilonTarget(T,N,ee,y,F,w);J!=null&&(O=this.closure(T,J,y,O,F,w))}return O}getEpsilonTarget(T,N,y,O,F,w){let M;switch(y.serializationType){case 3:let W=y;if(this.optimize_tail_calls&&W.optimizedTailCall&&!N.context.hasEmpty)M=N.transform(y.target,!0);else{let J=N.context.getChild(W.followState.stateNumber);M=N.transform(y.target,!0,J)}break;case 10:throw new Error("Precedence predicates are not supported in lexers.");case 4:let ee=y;Oe.debug&&console.log("EVAL rule "+ee.ruleIndex+":"+ee.predIndex),O.hasSemanticContext=!0,this.evaluatePredicate(T,ee.ruleIndex,ee.predIndex,F)?M=N.transform(y.target,!0):M=void 0;break;case 6:if(N.context.hasEmpty){let J=u.LexerActionExecutor.append(N.lexerActionExecutor,this.atn.lexerActions[y.actionIndex]);M=N.transform(y.target,!0,J);break}else{M=N.transform(y.target,!0);break}case 1:M=N.transform(y.target,!0);break;case 5:case 2:case 7:if(w&&y.matches(e.IntStream.EOF,i.Lexer.MIN_CHAR_VALUE,i.Lexer.MAX_CHAR_VALUE)){M=N.transform(y.target,!1);break}M=void 0;break;default:M=void 0;break}return M}evaluatePredicate(T,N,y,O){if(this.recog==null)return!0;if(!O)return this.recog.sempred(void 0,N,y);let F=this._charPositionInLine,w=this._line,M=T.index,W=T.mark();try{return this.consume(T),this.recog.sempred(void 0,N,y)}finally{this._charPositionInLine=F,this._line=w,T.seek(M),T.release(W)}}captureSimState(T,N,y){T.index=N.index,T.line=this._line,T.charPos=this._charPositionInLine,T.dfaState=y}addDFAEdge(T,N,y){if(y instanceof r.ATNConfigSet){let O=y.hasSemanticContext;O&&(y.hasSemanticContext=!1);let F=this.addDFAState(y);return O||this.addDFAEdge(T,N,F),F}else Oe.debug&&console.log("EDGE "+T+" -> "+y+" upon "+String.fromCharCode(N)),T!=null&&T.setTarget(N,y)}addDFAState(T){S(!T.hasSemanticContext);let N=new t.DFAState(T),y=this.atn.modeToDFA[this.mode].states.get(N);if(y!=null)return y;T.optimizeConfigs(this);let O=new t.DFAState(T.clone(!0)),F;for(let w of T)if(w.state instanceof _.RuleStopState){F=w;break}if(F!=null){let w=this.atn.ruleToTokenType[F.state.ruleIndex],M=F.lexerActionExecutor;O.acceptStateInfo=new x.AcceptStateInfo(w,M)}return this.atn.modeToDFA[this.mode].addState(O)}getDFA(T){return this.atn.modeToDFA[T]}getText(T){return T.getText(o.Interval.of(this.startIndex,T.index-1))}get line(){return this._line}set line(T){this._line=T}get charPositionInLine(){return this._charPositionInLine}set charPositionInLine(T){this._charPositionInLine=T}consume(T){T.LA(1)===10?(this._line++,this._charPositionInLine=0):this._charPositionInLine++,T.consume()}getTokenName(T){return T===-1?"EOF":"'"+String.fromCharCode(T)+"'"}};a([f.NotNull],E.prototype,"prevAccept",void 0),a([p(0,f.NotNull)],E.prototype,"copyState",null),a([p(0,f.NotNull)],E.prototype,"match",null),a([f.Override],E.prototype,"reset",null),a([p(0,f.NotNull)],E.prototype,"matchATN",null),a([p(0,f.NotNull),p(1,f.NotNull)],E.prototype,"execATN",null),a([p(0,f.NotNull)],E.prototype,"getExistingTargetState",null),a([f.NotNull,p(0,f.NotNull),p(1,f.NotNull)],E.prototype,"computeTargetState",null),a([p(0,f.NotNull),p(1,f.NotNull),p(2,f.NotNull)],E.prototype,"getReachableConfigSet",null),a([p(0,f.NotNull)],E.prototype,"accept",null),a([f.NotNull,p(0,f.NotNull),p(1,f.NotNull)],E.prototype,"computeStartState",null),a([p(0,f.NotNull),p(1,f.NotNull),p(2,f.NotNull)],E.prototype,"closure",null),a([p(0,f.NotNull),p(1,f.NotNull),p(2,f.NotNull),p(3,f.NotNull)],E.prototype,"getEpsilonTarget",null),a([p(0,f.NotNull)],E.prototype,"evaluatePredicate",null),a([p(0,f.NotNull),p(1,f.NotNull),p(2,f.NotNull)],E.prototype,"captureSimState",null),a([f.NotNull,p(0,f.NotNull)],E.prototype,"addDFAState",null),a([f.NotNull],E.prototype,"getDFA",null),a([f.NotNull,p(0,f.NotNull)],E.prototype,"getText",null),a([p(0,f.NotNull)],E.prototype,"consume",null),a([f.NotNull],E.prototype,"getTokenName",null),E=a([p(0,f.NotNull)],E),l.LexerATNSimulator=E,function(g){g.debug=!1,g.dfa_debug=!1;class T{constructor(){this.index=-1,this.line=0,this.charPos=-1}reset(){this.index=-1,this.line=0,this.charPos=-1,this.dfaState=void 0}}g.SimState=T}(E=l.LexerATNSimulator||(l.LexerATNSimulator={})),l.LexerATNSimulator=E}(fr)),fr}var Ts;function tr(){if(Ts)return hr;Ts=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=hr&&hr.__decorate||function(i,u,c,f){var A=arguments.length,d=A<3?u:f===null?f=Object.getOwnPropertyDescriptor(u,c):f,_;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")d=Reflect.decorate(i,u,c,f);else for(var m=i.length-1;m>=0;m--)(_=i[m])&&(d=(A<3?_(d):A>3?_(u,c,d):_(u,c))||d);return A>3&&d&&Object.defineProperty(u,c,d),d};Object.defineProperty(hr,"__esModule",{value:!0}),hr.Lexer=void 0;const a=Gi(),p=pl(),x=ye(),h=$t(),s=hi(),r=ci(),n=z(),t=Xn(),o=pe();let e=class Kt extends t.Recognizer{constructor(u){super(),this._factory=a.CommonTokenFactory.DEFAULT,this._tokenStartCharIndex=-1,this._tokenStartLine=0,this._tokenStartCharPositionInLine=0,this._hitEOF=!1,this._channel=0,this._type=0,this._modeStack=new p.IntegerStack,this._mode=Kt.DEFAULT_MODE,this._input=u,this._tokenFactorySourcePair={source:this,stream:u}}static get DEFAULT_TOKEN_CHANNEL(){return o.Token.DEFAULT_CHANNEL}static get HIDDEN(){return o.Token.HIDDEN_CHANNEL}reset(u){(u===void 0||u)&&this._input.seek(0),this._token=void 0,this._type=o.Token.INVALID_TYPE,this._channel=o.Token.DEFAULT_CHANNEL,this._tokenStartCharIndex=-1,this._tokenStartCharPositionInLine=-1,this._tokenStartLine=-1,this._text=void 0,this._hitEOF=!1,this._mode=Kt.DEFAULT_MODE,this._modeStack.clear(),this.interpreter.reset()}nextToken(){if(this._input==null)throw new Error("nextToken requires a non-null input stream.");let u=this._input.mark();try{e:for(;;){if(this._hitEOF)return this.emitEOF();this._token=void 0,this._channel=o.Token.DEFAULT_CHANNEL,this._tokenStartCharIndex=this._input.index,this._tokenStartCharPositionInLine=this.interpreter.charPositionInLine,this._tokenStartLine=this.interpreter.line,this._text=void 0;do{this._type=o.Token.INVALID_TYPE;let c;try{c=this.interpreter.match(this._input,this._mode)}catch(f){if(f instanceof r.LexerNoViableAltException)this.notifyListeners(f),this.recover(f),c=Kt.SKIP;else throw f}if(this._input.LA(1)===h.IntStream.EOF&&(this._hitEOF=!0),this._type===o.Token.INVALID_TYPE&&(this._type=c),this._type===Kt.SKIP)continue e}while(this._type===Kt.MORE);return this._token==null?this.emit():this._token}}finally{this._input.release(u)}}skip(){this._type=Kt.SKIP}more(){this._type=Kt.MORE}mode(u){this._mode=u}pushMode(u){s.LexerATNSimulator.debug&&console.log("pushMode "+u),this._modeStack.push(this._mode),this.mode(u)}popMode(){if(this._modeStack.isEmpty)throw new Error("EmptyStackException");return s.LexerATNSimulator.debug&&console.log("popMode back to "+this._modeStack.peek()),this.mode(this._modeStack.pop()),this._mode}get tokenFactory(){return this._factory}set tokenFactory(u){this._factory=u}get inputStream(){return this._input}set inputStream(u){this.reset(!1),this._input=u,this._tokenFactorySourcePair={source:this,stream:this._input}}get sourceName(){return this._input.sourceName}emit(u){return u||(u=this._factory.create(this._tokenFactorySourcePair,this._type,this._text,this._channel,this._tokenStartCharIndex,this.charIndex-1,this._tokenStartLine,this._tokenStartCharPositionInLine)),this._token=u,u}emitEOF(){let u=this.charPositionInLine,c=this.line,f=this._factory.create(this._tokenFactorySourcePair,o.Token.EOF,void 0,o.Token.DEFAULT_CHANNEL,this._input.index,this._input.index-1,c,u);return this.emit(f),f}get line(){return this.interpreter.line}set line(u){this.interpreter.line=u}get charPositionInLine(){return this.interpreter.charPositionInLine}set charPositionInLine(u){this.interpreter.charPositionInLine=u}get charIndex(){return this._input.index}get text(){return this._text!=null?this._text:this.interpreter.getText(this._input)}set text(u){this._text=u}get token(){return this._token}set token(u){this._token=u}set type(u){this._type=u}get type(){return this._type}set channel(u){this._channel=u}get channel(){return this._channel}getAllTokens(){let u=[],c=this.nextToken();for(;c.type!==o.Token.EOF;)u.push(c),c=this.nextToken();return u}notifyListeners(u){let c=this._input.getText(x.Interval.of(this._tokenStartCharIndex,this._input.index)),f="token recognition error at: '"+this.getErrorDisplay(c)+"'",A=this.getErrorListenerDispatch();A.syntaxError&&A.syntaxError(this,void 0,this._tokenStartLine,this._tokenStartCharPositionInLine,f,u)}getErrorDisplay(u){if(typeof u=="number"){switch(u){case o.Token.EOF:return"<EOF>";case 10:return"\\n";case 9:return"\\t";case 13:return"\\r"}return String.fromCharCode(u)}return u.replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")}getCharErrorDisplay(u){return"'"+this.getErrorDisplay(u)+"'"}recover(u){u instanceof r.LexerNoViableAltException?this._input.LA(1)!==h.IntStream.EOF&&this.interpreter.consume(this._input):this._input.consume()}};return e.DEFAULT_MODE=0,e.MORE=-2,e.SKIP=-3,e.MIN_CHAR_VALUE=0,e.MAX_CHAR_VALUE=1114111,l([n.Override],e.prototype,"nextToken",null),l([n.Override],e.prototype,"tokenFactory",null),l([n.Override],e.prototype,"inputStream",null),l([n.Override],e.prototype,"sourceName",null),l([n.Override],e.prototype,"line",null),l([n.Override],e.prototype,"charPositionInLine",null),hr.Lexer=e,hr}var gs;function an(){if(gs)return Ge;gs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ge&&Ge.__decorate||function(e,i,u,c){var f=arguments.length,A=f<3?i:c===null?c=Object.getOwnPropertyDescriptor(i,u):c,d;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")A=Reflect.decorate(e,i,u,c);else for(var _=e.length-1;_>=0;_--)(d=e[_])&&(A=(f<3?d(A):f>3?d(i,u,A):d(i,u))||A);return f>3&&A&&Object.defineProperty(i,u,A),A},a=Ge&&Ge.__param||function(e,i){return function(u,c){i(u,c,e)}};Object.defineProperty(Ge,"__esModule",{value:!0}),Ge.IntervalSet=void 0;const p=ii(),x=Ki(),h=ye(),s=tr(),r=xe(),n=z(),t=pe();let o=class ce{constructor(i){this.readonly=!1,i!=null?this._intervals=i.slice(0):this._intervals=[]}static get COMPLETE_CHAR_SET(){return ce._COMPLETE_CHAR_SET===void 0&&(ce._COMPLETE_CHAR_SET=ce.of(s.Lexer.MIN_CHAR_VALUE,s.Lexer.MAX_CHAR_VALUE),ce._COMPLETE_CHAR_SET.setReadonly(!0)),ce._COMPLETE_CHAR_SET}static get EMPTY_SET(){return ce._EMPTY_SET==null&&(ce._EMPTY_SET=new ce,ce._EMPTY_SET.setReadonly(!0)),ce._EMPTY_SET}static of(i,u=i){let c=new ce;return c.add(i,u),c}clear(){if(this.readonly)throw new Error("can't alter readonly IntervalSet");this._intervals.length=0}add(i,u=i){this.addRange(h.Interval.of(i,u))}addRange(i){if(this.readonly)throw new Error("can't alter readonly IntervalSet");if(!(i.b<i.a)){for(let u=0;u<this._intervals.length;u++){let c=this._intervals[u];if(i.equals(c))return;if(i.adjacent(c)||!i.disjoint(c)){let f=i.union(c);for(this._intervals[u]=f;u<this._intervals.length-1;){u++;let A=this._intervals[u];if(!f.adjacent(A)&&f.disjoint(A))break;this._intervals.splice(u,1),u--,this._intervals[u]=f.union(A)}return}if(i.startsBeforeDisjoint(c)){this._intervals.splice(u,0,i);return}}this._intervals.push(i)}}static or(i){let u=new ce;for(let c of i)u.addAll(c);return u}addAll(i){if(i==null)return this;if(i instanceof ce){let u=i,c=u._intervals.length;for(let f=0;f<c;f++){let A=u._intervals[f];this.add(A.a,A.b)}}else for(let u of i.toArray())this.add(u);return this}complementRange(i,u){return this.complement(ce.of(i,u))}complement(i){if(i.isNil)return ce.EMPTY_SET;let u;return i instanceof ce?u=i:(u=new ce,u.addAll(i)),u.subtract(this)}subtract(i){if(i==null||i.isNil)return new ce(this._intervals);if(i instanceof ce)return ce.subtract(this,i);let u=new ce;return u.addAll(i),ce.subtract(this,u)}static subtract(i,u){if(i.isNil)return new ce;let c=new ce(i._intervals);if(u.isNil)return c;let f=0,A=0;for(;f<c._intervals.length&&A<u._intervals.length;){let d=c._intervals[f],_=u._intervals[A];if(_.b<d.a){A++;continue}if(_.a>d.b){f++;continue}let m,S;if(_.a>d.a&&(m=new h.Interval(d.a,_.a-1)),_.b<d.b&&(S=new h.Interval(_.b+1,d.b)),m)if(S){c._intervals[f]=m,c._intervals.splice(f+1,0,S),f++,A++;continue}else{c._intervals[f]=m,f++;continue}else if(S){c._intervals[f]=S,A++;continue}else{c._intervals.splice(f,1);continue}}return c}or(i){let u=new ce;return u.addAll(this),u.addAll(i),u}and(i){if(i.isNil)return new ce;let u=this._intervals,c=i._intervals,f,A=u.length,d=c.length,_=0,m=0;for(;_<A&&m<d;){let S=u[_],E=c[m];S.startsBeforeDisjoint(E)?_++:E.startsBeforeDisjoint(S)?m++:S.properlyContains(E)?(f||(f=new ce),f.addRange(S.intersection(E)),m++):E.properlyContains(S)?(f||(f=new ce),f.addRange(S.intersection(E)),_++):S.disjoint(E)||(f||(f=new ce),f.addRange(S.intersection(E)),S.startsAfterNonDisjoint(E)?m++:E.startsAfterNonDisjoint(S)&&_++)}return f||new ce}contains(i){let u=this._intervals.length,c=0,f=u-1;for(;c<=f;){let A=c+f>>1,d=this._intervals[A],_=d.a;if(d.b<i)c=A+1;else if(_>i)f=A-1;else return!0}return!1}get isNil(){return this._intervals==null||this._intervals.length===0}get maxElement(){if(this.isNil)throw new RangeError("set is empty");return this._intervals[this._intervals.length-1].b}get minElement(){if(this.isNil)throw new RangeError("set is empty");return this._intervals[0].a}get intervals(){return this._intervals}hashCode(){let i=r.MurmurHash.initialize();for(let u of this._intervals)i=r.MurmurHash.update(i,u.a),i=r.MurmurHash.update(i,u.b);return i=r.MurmurHash.finish(i,this._intervals.length*2),i}equals(i){return i==null||!(i instanceof ce)?!1:p.ArrayEqualityComparator.INSTANCE.equals(this._intervals,i._intervals)}toString(i=!1){let u="";if(this._intervals==null||this._intervals.length===0)return"{}";this.size>1&&(u+="{");let c=!0;for(let f of this._intervals){c?c=!1:u+=", ";let A=f.a,d=f.b;A===d?A===t.Token.EOF?u+="<EOF>":i?u+="'"+String.fromCodePoint(A)+"'":u+=A:i?u+="'"+String.fromCodePoint(A)+"'..'"+String.fromCodePoint(d)+"'":u+=A+".."+d}return this.size>1&&(u+="}"),u}toStringVocabulary(i){if(this._intervals==null||this._intervals.length===0)return"{}";let u="";this.size>1&&(u+="{");let c=!0;for(let f of this._intervals){c?c=!1:u+=", ";let A=f.a,d=f.b;if(A===d)u+=this.elementName(i,A);else for(let _=A;_<=d;_++)_>A&&(u+=", "),u+=this.elementName(i,_)}return this.size>1&&(u+="}"),u}elementName(i,u){return u===t.Token.EOF?"<EOF>":u===t.Token.EPSILON?"<EPSILON>":i.getDisplayName(u)}get size(){let i=0,u=this._intervals.length;if(u===1){let c=this._intervals[0];return c.b-c.a+1}for(let c=0;c<u;c++){let f=this._intervals[c];i+=f.b-f.a+1}return i}toIntegerList(){let i=new x.IntegerList(this.size),u=this._intervals.length;for(let c=0;c<u;c++){let f=this._intervals[c],A=f.a,d=f.b;for(let _=A;_<=d;_++)i.add(_)}return i}toSet(){let i=new Set;for(let u of this._intervals){let c=u.a,f=u.b;for(let A=c;A<=f;A++)i.add(A)}return i}toArray(){let i=new Array,u=this._intervals.length;for(let c=0;c<u;c++){let f=this._intervals[c],A=f.a,d=f.b;for(let _=A;_<=d;_++)i.push(_)}return i}remove(i){if(this.readonly)throw new Error("can't alter readonly IntervalSet");let u=this._intervals.length;for(let c=0;c<u;c++){let f=this._intervals[c],A=f.a,d=f.b;if(i<A)break;if(i===A&&i===d){this._intervals.splice(c,1);break}if(i===A){this._intervals[c]=h.Interval.of(f.a+1,f.b);break}if(i===d){this._intervals[c]=h.Interval.of(f.a,f.b-1);break}if(i>A&&i<d){let _=f.b;this._intervals[c]=h.Interval.of(f.a,i-1),this.add(i+1,_)}}}get isReadonly(){return this.readonly}setReadonly(i){if(this.readonly&&!i)throw new Error("can't alter readonly IntervalSet");this.readonly=i}};return l([n.Override],o.prototype,"addAll",null),l([n.Override],o.prototype,"complement",null),l([n.Override],o.prototype,"subtract",null),l([n.Override],o.prototype,"or",null),l([n.Override],o.prototype,"and",null),l([n.Override],o.prototype,"contains",null),l([n.Override],o.prototype,"isNil",null),l([n.Override],o.prototype,"hashCode",null),l([n.Override],o.prototype,"equals",null),l([a(0,n.NotNull)],o.prototype,"toStringVocabulary",null),l([n.NotNull,a(0,n.NotNull)],o.prototype,"elementName",null),l([n.Override],o.prototype,"size",null),l([n.Override],o.prototype,"remove",null),l([n.NotNull],o,"of",null),l([n.NotNull],o,"subtract",null),Ge.IntervalSet=o,Ge}var vr={},we={},Cr={},ys;function Vl(){if(ys)return Cr;ys=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Cr&&Cr.__decorate||function(x,h,s,r){var n=arguments.length,t=n<3?h:r===null?r=Object.getOwnPropertyDescriptor(h,s):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")t=Reflect.decorate(x,h,s,r);else for(var e=x.length-1;e>=0;e--)(o=x[e])&&(t=(n<3?o(t):n>3?o(h,s,t):o(h,s))||t);return n>3&&t&&Object.defineProperty(h,s,t),t};Object.defineProperty(Cr,"__esModule",{value:!0}),Cr.ATNDeserializationOptions=void 0;const a=z();let p=class hn{constructor(h){this.readOnly=!1,h?(this.verifyATN=h.verifyATN,this.generateRuleBypassTransitions=h.generateRuleBypassTransitions,this.optimize=h.optimize):(this.verifyATN=!0,this.generateRuleBypassTransitions=!1,this.optimize=!0)}static get defaultOptions(){return hn._defaultOptions==null&&(hn._defaultOptions=new hn,hn._defaultOptions.makeReadOnly()),hn._defaultOptions}get isReadOnly(){return this.readOnly}makeReadOnly(){this.readOnly=!0}get isVerifyATN(){return this.verifyATN}set isVerifyATN(h){this.throwIfReadOnly(),this.verifyATN=h}get isGenerateRuleBypassTransitions(){return this.generateRuleBypassTransitions}set isGenerateRuleBypassTransitions(h){this.throwIfReadOnly(),this.generateRuleBypassTransitions=h}get isOptimize(){return this.optimize}set isOptimize(h){this.throwIfReadOnly(),this.optimize=h}throwIfReadOnly(){if(this.isReadOnly)throw new Error("The object is read only.")}};return l([a.NotNull],p,"defaultOptions",null),Cr.ATNDeserializationOptions=p,Cr}var ct={},ht={},Ns;function Yl(){if(Ns)return ht;Ns=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ht&&ht.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=ht&&ht.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(ht,"__esModule",{value:!0}),ht.ActionTransition=void 0;const p=z(),x=Zt();let h=class extends x.Transition{constructor(r,n,t=-1,o=!1){super(r),this.ruleIndex=n,this.actionIndex=t,this.isCtxDependent=o}get serializationType(){return 6}get isEpsilon(){return!0}matches(r,n,t){return!1}toString(){return"action_"+this.ruleIndex+":"+this.actionIndex}};return l([p.Override],h.prototype,"serializationType",null),l([p.Override],h.prototype,"isEpsilon",null),l([p.Override],h.prototype,"matches",null),l([p.Override],h.prototype,"toString",null),h=l([a(0,p.NotNull)],h),ht.ActionTransition=h,ht}var ft={},vs;function Xl(){if(vs)return ft;vs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ft&&ft.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=ft&&ft.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(ft,"__esModule",{value:!0}),ft.AtomTransition=void 0;const p=an(),x=z(),h=Zt();let s=class extends h.Transition{constructor(n,t){super(n),this._label=t}get serializationType(){return 5}get label(){return p.IntervalSet.of(this._label)}matches(n,t,o){return this._label===n}toString(){return String(this.label)}};return l([x.Override],s.prototype,"serializationType",null),l([x.Override,x.NotNull],s.prototype,"label",null),l([x.Override],s.prototype,"matches",null),l([x.Override,x.NotNull],s.prototype,"toString",null),s=l([a(0,x.NotNull)],s),ft.AtomTransition=s,ft}var Or={},On={},Cs;function fi(){if(Cs)return On;Cs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(On,"__esModule",{value:!0}),On.BlockStartState=void 0;const l=un();let a=class extends l.DecisionState{};return On.BlockStartState=a,On}var Os;function Ba(){if(Os)return Or;Os=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Or&&Or.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Or,"__esModule",{value:!0}),Or.BasicBlockStartState=void 0;const a=Te(),p=fi(),x=z();let h=class extends p.BlockStartState{get stateType(){return a.ATNStateType.BLOCK_START}};return l([x.Override],h.prototype,"stateType",null),Or.BasicBlockStartState=h,Or}var Dr={},Ds;function Ma(){if(Ds)return Dr;Ds=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Dr&&Dr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Dr,"__esModule",{value:!0}),Dr.BlockEndState=void 0;const a=Yt(),p=Te(),x=z();let h=class extends a.ATNState{get stateType(){return p.ATNStateType.BLOCK_END}};return l([x.Override],h.prototype,"stateType",null),Dr.BlockEndState=h,Dr}var pt={},bs;function ka(){if(bs)return pt;bs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=pt&&pt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=pt&&pt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(pt,"__esModule",{value:!0}),pt.EpsilonTransition=void 0;const p=z(),x=Zt();let h=class extends x.Transition{constructor(r,n=-1){super(r),this._outermostPrecedenceReturn=n}get outermostPrecedenceReturn(){return this._outermostPrecedenceReturn}get serializationType(){return 1}get isEpsilon(){return!0}matches(r,n,t){return!1}toString(){return"epsilon"}};return l([p.Override],h.prototype,"serializationType",null),l([p.Override],h.prototype,"isEpsilon",null),l([p.Override],h.prototype,"matches",null),l([p.Override,p.NotNull],h.prototype,"toString",null),h=l([a(0,p.NotNull)],h),pt.EpsilonTransition=h,pt}var dt={},Rs;function ja(){if(Rs)return dt;Rs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=dt&&dt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=dt&&dt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(dt,"__esModule",{value:!0}),dt.LexerChannelAction=void 0;const p=xe(),x=z();let h=class Wl{constructor(r){this._channel=r}get channel(){return this._channel}get actionType(){return 0}get isPositionDependent(){return!1}execute(r){r.channel=this._channel}hashCode(){let r=p.MurmurHash.initialize();return r=p.MurmurHash.update(r,this.actionType),r=p.MurmurHash.update(r,this._channel),p.MurmurHash.finish(r,2)}equals(r){return r===this?!0:r instanceof Wl?this._channel===r._channel:!1}toString(){return`channel(${this._channel})`}};return l([x.Override],h.prototype,"actionType",null),l([x.Override],h.prototype,"isPositionDependent",null),l([x.Override,a(0,x.NotNull)],h.prototype,"execute",null),l([x.Override],h.prototype,"hashCode",null),l([x.Override],h.prototype,"equals",null),l([x.Override],h.prototype,"toString",null),dt.LexerChannelAction=h,dt}var xt={},Ps;function qa(){if(Ps)return xt;Ps=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=xt&&xt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=xt&&xt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(xt,"__esModule",{value:!0}),xt.LexerCustomAction=void 0;const p=xe(),x=z();let h=class Kl{constructor(r,n){this._ruleIndex=r,this._actionIndex=n}get ruleIndex(){return this._ruleIndex}get actionIndex(){return this._actionIndex}get actionType(){return 1}get isPositionDependent(){return!0}execute(r){r.action(void 0,this._ruleIndex,this._actionIndex)}hashCode(){let r=p.MurmurHash.initialize();return r=p.MurmurHash.update(r,this.actionType),r=p.MurmurHash.update(r,this._ruleIndex),r=p.MurmurHash.update(r,this._actionIndex),p.MurmurHash.finish(r,3)}equals(r){return r===this?!0:r instanceof Kl?this._ruleIndex===r._ruleIndex&&this._actionIndex===r._actionIndex:!1}};return l([x.Override],h.prototype,"actionType",null),l([x.Override],h.prototype,"isPositionDependent",null),l([x.Override,a(0,x.NotNull)],h.prototype,"execute",null),l([x.Override],h.prototype,"hashCode",null),l([x.Override],h.prototype,"equals",null),xt.LexerCustomAction=h,xt}var _t={},Ls;function za(){if(Ls)return _t;Ls=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=_t&&_t.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=_t&&_t.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(_t,"__esModule",{value:!0}),_t.LexerModeAction=void 0;const p=xe(),x=z();let h=class Gl{constructor(r){this._mode=r}get mode(){return this._mode}get actionType(){return 2}get isPositionDependent(){return!1}execute(r){r.mode(this._mode)}hashCode(){let r=p.MurmurHash.initialize();return r=p.MurmurHash.update(r,this.actionType),r=p.MurmurHash.update(r,this._mode),p.MurmurHash.finish(r,2)}equals(r){return r===this?!0:r instanceof Gl?this._mode===r._mode:!1}toString(){return`mode(${this._mode})`}};return l([x.Override],h.prototype,"actionType",null),l([x.Override],h.prototype,"isPositionDependent",null),l([x.Override,a(0,x.NotNull)],h.prototype,"execute",null),l([x.Override],h.prototype,"hashCode",null),l([x.Override],h.prototype,"equals",null),l([x.Override],h.prototype,"toString",null),_t.LexerModeAction=h,_t}var br={},Fs;function Ua(){return Fs||(Fs=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=br&&br.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},p=br&&br.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(l,"__esModule",{value:!0}),l.LexerMoreAction=void 0;const x=xe(),h=z();let s=class{constructor(){}get actionType(){return 3}get isPositionDependent(){return!1}execute(n){n.more()}hashCode(){let n=x.MurmurHash.initialize();return n=x.MurmurHash.update(n,this.actionType),x.MurmurHash.finish(n,1)}equals(n){return n===this}toString(){return"more"}};a([h.Override],s.prototype,"actionType",null),a([h.Override],s.prototype,"isPositionDependent",null),a([h.Override,p(0,h.NotNull)],s.prototype,"execute",null),a([h.Override],s.prototype,"hashCode",null),a([h.Override],s.prototype,"equals",null),a([h.Override],s.prototype,"toString",null),l.LexerMoreAction=s,function(r){r.INSTANCE=new r}(s=l.LexerMoreAction||(l.LexerMoreAction={}))}(br)),br}var Rr={},Is;function Ha(){return Is||(Is=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=Rr&&Rr.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},p=Rr&&Rr.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(l,"__esModule",{value:!0}),l.LexerPopModeAction=void 0;const x=xe(),h=z();let s=class{constructor(){}get actionType(){return 4}get isPositionDependent(){return!1}execute(n){n.popMode()}hashCode(){let n=x.MurmurHash.initialize();return n=x.MurmurHash.update(n,this.actionType),x.MurmurHash.finish(n,1)}equals(n){return n===this}toString(){return"popMode"}};a([h.Override],s.prototype,"actionType",null),a([h.Override],s.prototype,"isPositionDependent",null),a([h.Override,p(0,h.NotNull)],s.prototype,"execute",null),a([h.Override],s.prototype,"hashCode",null),a([h.Override],s.prototype,"equals",null),a([h.Override],s.prototype,"toString",null),l.LexerPopModeAction=s,function(r){r.INSTANCE=new r}(s=l.LexerPopModeAction||(l.LexerPopModeAction={}))}(Rr)),Rr}var At={},ws;function Va(){if(ws)return At;ws=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=At&&At.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=At&&At.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(At,"__esModule",{value:!0}),At.LexerPushModeAction=void 0;const p=xe(),x=z();let h=class $l{constructor(r){this._mode=r}get mode(){return this._mode}get actionType(){return 5}get isPositionDependent(){return!1}execute(r){r.pushMode(this._mode)}hashCode(){let r=p.MurmurHash.initialize();return r=p.MurmurHash.update(r,this.actionType),r=p.MurmurHash.update(r,this._mode),p.MurmurHash.finish(r,2)}equals(r){return r===this?!0:r instanceof $l?this._mode===r._mode:!1}toString(){return`pushMode(${this._mode})`}};return l([x.Override],h.prototype,"actionType",null),l([x.Override],h.prototype,"isPositionDependent",null),l([x.Override,a(0,x.NotNull)],h.prototype,"execute",null),l([x.Override],h.prototype,"hashCode",null),l([x.Override],h.prototype,"equals",null),l([x.Override],h.prototype,"toString",null),At.LexerPushModeAction=h,At}var Pr={},Bs;function Ya(){return Bs||(Bs=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=Pr&&Pr.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},p=Pr&&Pr.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(l,"__esModule",{value:!0}),l.LexerSkipAction=void 0;const x=xe(),h=z();let s=class{constructor(){}get actionType(){return 6}get isPositionDependent(){return!1}execute(n){n.skip()}hashCode(){let n=x.MurmurHash.initialize();return n=x.MurmurHash.update(n,this.actionType),x.MurmurHash.finish(n,1)}equals(n){return n===this}toString(){return"skip"}};a([h.Override],s.prototype,"actionType",null),a([h.Override],s.prototype,"isPositionDependent",null),a([h.Override,p(0,h.NotNull)],s.prototype,"execute",null),a([h.Override],s.prototype,"hashCode",null),a([h.Override],s.prototype,"equals",null),a([h.Override],s.prototype,"toString",null),l.LexerSkipAction=s,function(r){r.INSTANCE=new r}(s=l.LexerSkipAction||(l.LexerSkipAction={}))}(Pr)),Pr}var mt={},Ms;function Xa(){if(Ms)return mt;Ms=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=mt&&mt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=mt&&mt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(mt,"__esModule",{value:!0}),mt.LexerTypeAction=void 0;const p=xe(),x=z();let h=class Ql{constructor(r){this._type=r}get type(){return this._type}get actionType(){return 7}get isPositionDependent(){return!1}execute(r){r.type=this._type}hashCode(){let r=p.MurmurHash.initialize();return r=p.MurmurHash.update(r,this.actionType),r=p.MurmurHash.update(r,this._type),p.MurmurHash.finish(r,2)}equals(r){return r===this?!0:r instanceof Ql?this._type===r._type:!1}toString(){return`type(${this._type})`}};return l([x.Override],h.prototype,"actionType",null),l([x.Override],h.prototype,"isPositionDependent",null),l([x.Override,a(0,x.NotNull)],h.prototype,"execute",null),l([x.Override],h.prototype,"hashCode",null),l([x.Override],h.prototype,"equals",null),l([x.Override],h.prototype,"toString",null),mt.LexerTypeAction=h,mt}var Lr={},ks;function Zl(){if(ks)return Lr;ks=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Lr&&Lr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Lr,"__esModule",{value:!0}),Lr.LoopEndState=void 0;const a=Yt(),p=Te(),x=z();let h=class extends a.ATNState{get stateType(){return p.ATNStateType.LOOP_END}};return l([x.Override],h.prototype,"stateType",null),Lr.LoopEndState=h,Lr}var St={},Fr={},js;function Wa(){if(js)return Fr;js=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Fr&&Fr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(Fr,"__esModule",{value:!0}),Fr.ConflictInfo=void 0;const a=z(),p=Xt();let x=class Jl{constructor(s,r){this._conflictedAlts=s,this.exact=r}get conflictedAlts(){return this._conflictedAlts}get isExact(){return this.exact}equals(s){return s===this?!0:s instanceof Jl?this.isExact===s.isExact&&p.equals(this.conflictedAlts,s.conflictedAlts):!1}hashCode(){return this.conflictedAlts.hashCode()}};return l([a.Override],x.prototype,"equals",null),l([a.Override],x.prototype,"hashCode",null),Fr.ConflictInfo=x,Fr}var Ir={},wr={},Br={},qs;function dn(){if(qs)return Br;qs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Br&&Br.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Br,"__esModule",{value:!0}),Br.TerminalNode=void 0;const a=ye(),p=z(),x=pe();let h=class{constructor(r){this._symbol=r}getChild(r){throw new RangeError("Terminal Node has no children.")}get symbol(){return this._symbol}get parent(){return this._parent}setParent(r){this._parent=r}get payload(){return this._symbol}get sourceInterval(){let r=this._symbol.tokenIndex;return new a.Interval(r,r)}get childCount(){return 0}accept(r){return r.visitTerminal(this)}get text(){return this._symbol.text||""}toStringTree(r){return this.toString()}toString(){return this._symbol.type===x.Token.EOF?"<EOF>":this._symbol.text||""}};return l([p.Override],h.prototype,"getChild",null),l([p.Override],h.prototype,"parent",null),l([p.Override],h.prototype,"setParent",null),l([p.Override],h.prototype,"payload",null),l([p.Override],h.prototype,"sourceInterval",null),l([p.Override],h.prototype,"childCount",null),l([p.Override],h.prototype,"accept",null),l([p.Override],h.prototype,"text",null),l([p.Override],h.prototype,"toStringTree",null),l([p.Override],h.prototype,"toString",null),Br.TerminalNode=h,Br}var zs;function oo(){if(zs)return wr;zs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=wr&&wr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(wr,"__esModule",{value:!0}),wr.ErrorNode=void 0;const a=z(),p=dn();let x=class extends p.TerminalNode{constructor(s){super(s)}accept(s){return s.visitErrorNode(this)}};return l([a.Override],x.prototype,"accept",null),wr.ErrorNode=x,wr}var Mr={},Dn={},Us;function so(){if(Us)return Dn;Us=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Dn,"__esModule",{value:!0}),Dn.RuleNode=void 0;let l=class{};return Dn.RuleNode=l,Dn}var Et={},Hs;function cn(){if(Hs)return Et;Hs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Et&&Et.__decorate||function(c,f,A,d){var _=arguments.length,m=_<3?f:d===null?d=Object.getOwnPropertyDescriptor(f,A):d,S;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")m=Reflect.decorate(c,f,A,d);else for(var E=c.length-1;E>=0;E--)(S=c[E])&&(m=(_<3?S(m):_>3?S(f,A,m):S(f,A))||m);return _>3&&m&&Object.defineProperty(f,A,m),m},a=Et&&Et.__param||function(c,f){return function(A,d){f(A,d,c)}};Object.defineProperty(Et,"__esModule",{value:!0}),Et.Trees=void 0;const p=ze(),x=Vn(),h=oo(),s=z(),r=$n(),n=Me(),t=so(),o=dn(),e=pe(),i=Xt();let u=class Gt{static toStringTree(f,A){let d;A instanceof r.Parser?d=A.ruleNames:d=A;let _=i.escapeWhitespace(this.getNodeText(f,d),!1);if(f.childCount===0)return _;let m="";m+="(",_=i.escapeWhitespace(this.getNodeText(f,d),!1),m+=_,m+=" ";for(let S=0;S<f.childCount;S++)S>0&&(m+=" "),m+=this.toStringTree(f.getChild(S),d);return m+=")",m}static getNodeText(f,A){let d;if(A instanceof r.Parser)d=A.ruleNames;else if(A)d=A;else{let _=f.payload;return typeof _.text=="string"?_.text:f.payload.toString()}if(f instanceof t.RuleNode){let _=f.ruleContext,m=_.ruleIndex,S=d[m],E=_.altNumber;return E!==p.ATN.INVALID_ALT_NUMBER?S+":"+E:S}else{if(f instanceof h.ErrorNode)return f.toString();if(f instanceof o.TerminalNode)return f.symbol.text||""}throw new TypeError("Unexpected node type")}static getChildren(f){let A=[];for(let d=0;d<f.childCount;d++)A.push(f.getChild(d));return A}static getAncestors(f){let A=[],d=f.parent;for(;d;)A.unshift(d),d=d.parent;return A}static isAncestorOf(f,A){if(!f||!A||!f.parent)return!1;let d=A.parent;for(;d;){if(f===d)return!0;d=d.parent}return!1}static findAllTokenNodes(f,A){return Gt.findAllNodes(f,A,!0)}static findAllRuleNodes(f,A){return Gt.findAllNodes(f,A,!1)}static findAllNodes(f,A,d){let _=[];return Gt._findAllNodes(f,A,d,_),_}static _findAllNodes(f,A,d,_){d&&f instanceof o.TerminalNode?f.symbol.type===A&&_.push(f):!d&&f instanceof n.ParserRuleContext&&f.ruleIndex===A&&_.push(f);for(let m=0;m<f.childCount;m++)Gt._findAllNodes(f.getChild(m),A,d,_)}static getDescendants(f){let A=[];function d(_){A.push(_);const m=_.childCount;for(let S=0;S<m;S++)d(_.getChild(S))}return d(f),A}static getRootOfSubtreeEnclosingRegion(f,A,d){let _=f.childCount;for(let m=0;m<_;m++){let S=f.getChild(m),E=Gt.getRootOfSubtreeEnclosingRegion(S,A,d);if(E)return E}if(f instanceof n.ParserRuleContext){let m=f.stop;if(A>=f.start.tokenIndex&&(m==null||d<=m.tokenIndex))return f}}static stripChildrenOutOfRange(f,A,d,_){if(!f)return;let m=f.childCount;for(let S=0;S<m;S++){let E=f.getChild(S),g=E.sourceInterval;if(E instanceof n.ParserRuleContext&&(g.b<d||g.a>_)&&Gt.isAncestorOf(E,A)){let T=new x.CommonToken(e.Token.INVALID_TYPE,"...");f.children[S]=new o.TerminalNode(T)}}}static findNodeSuchThat(f,A){if(A(f))return f;let d=f.childCount;for(let _=0;_<d;_++){let m=Gt.findNodeSuchThat(f.getChild(_),A);if(m!==void 0)return m}}};return l([a(0,s.NotNull)],u,"toStringTree",null),l([s.NotNull,a(0,s.NotNull)],u,"getAncestors",null),l([a(0,s.NotNull)],u,"getRootOfSubtreeEnclosingRegion",null),Et.Trees=u,Et}var Vs;function ta(){if(Vs)return Mr;Vs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Mr&&Mr.__decorate||function(o,e,i,u){var c=arguments.length,f=c<3?e:u===null?u=Object.getOwnPropertyDescriptor(e,i):u,A;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")f=Reflect.decorate(o,e,i,u);else for(var d=o.length-1;d>=0;d--)(A=o[d])&&(f=(c<3?A(f):c>3?A(e,i,f):A(e,i))||f);return c>3&&f&&Object.defineProperty(e,i,f),f};Object.defineProperty(Mr,"__esModule",{value:!0}),Mr.RuleContext=void 0;const a=ze(),p=Xn(),x=so(),h=ye(),s=z(),r=cn(),n=Me();let t=class ea extends x.RuleNode{constructor(e,i){super(),this._parent=e,this.invokingState=i??-1}static getChildContext(e,i){return new ea(e,i)}depth(){let e=0,i=this;for(;i;)i=i._parent,e++;return e}get isEmpty(){return this.invokingState===-1}get sourceInterval(){return h.Interval.INVALID}get ruleContext(){return this}get parent(){return this._parent}setParent(e){this._parent=e}get payload(){return this}get text(){if(this.childCount===0)return"";let e="";for(let i=0;i<this.childCount;i++)e+=this.getChild(i).text;return e.toString()}get ruleIndex(){return-1}get altNumber(){return a.ATN.INVALID_ALT_NUMBER}set altNumber(e){}getChild(e){throw new RangeError("i must be greater than or equal to 0 and less than childCount")}get childCount(){return 0}accept(e){return e.visitChildren(this)}toStringTree(e){return r.Trees.toStringTree(this,e)}toString(e,i){const u=e instanceof p.Recognizer?e.ruleNames:e;i=i||n.ParserRuleContext.emptyContext();let c="",f=this;for(c+="[";f&&f!==i;){if(!u)f.isEmpty||(c+=f.invokingState);else{let A=f.ruleIndex,d=A>=0&&A<u.length?u[A]:A.toString();c+=d}f._parent&&(u||!f._parent.isEmpty)&&(c+=" "),f=f._parent}return c+="]",c.toString()}};return l([s.Override],t.prototype,"sourceInterval",null),l([s.Override],t.prototype,"ruleContext",null),l([s.Override],t.prototype,"parent",null),l([s.Override],t.prototype,"setParent",null),l([s.Override],t.prototype,"payload",null),l([s.Override],t.prototype,"text",null),l([s.Override],t.prototype,"getChild",null),l([s.Override],t.prototype,"childCount",null),l([s.Override],t.prototype,"accept",null),l([s.Override],t.prototype,"toStringTree",null),Mr.RuleContext=t,Mr}var Ys;function Me(){if(Ys)return Ir;Ys=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ir&&Ir.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u};Object.defineProperty(Ir,"__esModule",{value:!0}),Ir.ParserRuleContext=void 0;const a=oo(),p=ye(),x=z(),h=ta(),s=dn();let r=class Ui extends h.RuleContext{constructor(t,o){o==null?super():super(t,o)}static emptyContext(){return Ui.EMPTY}copyFrom(t){if(this._parent=t._parent,this.invokingState=t.invokingState,this._start=t._start,this._stop=t._stop,t.children){this.children=[];for(let o of t.children)o instanceof a.ErrorNode&&this.addChild(o)}}enterRule(t){}exitRule(t){}addAnyChild(t){return this.children?this.children.push(t):this.children=[t],t}addChild(t){if(t instanceof s.TerminalNode){t.setParent(this),this.addAnyChild(t);return}else if(t instanceof h.RuleContext){this.addAnyChild(t);return}else return t=new s.TerminalNode(t),this.addAnyChild(t),t.setParent(this),t}addErrorNode(t){if(t instanceof a.ErrorNode){const o=t;return o.setParent(this),this.addAnyChild(o)}else{const o=t;let e=new a.ErrorNode(o);return this.addAnyChild(e),e.setParent(this),e}}removeLastChild(){this.children&&this.children.pop()}get parent(){let t=super.parent;if(t===void 0||t instanceof Ui)return t;throw new TypeError("Invalid parent type for ParserRuleContext")}getChild(t,o){if(!this.children||t<0||t>=this.children.length)throw new RangeError("index parameter must be between >= 0 and <= number of children.");if(o==null)return this.children[t];let e=this.tryGetChild(t,o);if(e===void 0)throw new Error("The specified node does not exist");return e}tryGetChild(t,o){if(!this.children||t<0||t>=this.children.length)return;let e=-1;for(let i of this.children)if(i instanceof o&&(e++,e===t))return i}getToken(t,o){let e=this.tryGetToken(t,o);if(e===void 0)throw new Error("The specified token does not exist");return e}tryGetToken(t,o){if(!this.children||o<0||o>=this.children.length)return;let e=-1;for(let i of this.children)if(i instanceof s.TerminalNode&&i.symbol.type===t&&(e++,e===o))return i}getTokens(t){let o=[];if(!this.children)return o;for(let e of this.children)e instanceof s.TerminalNode&&e.symbol.type===t&&o.push(e);return o}get ruleContext(){return this}getRuleContext(t,o){return this.getChild(t,o)}tryGetRuleContext(t,o){return this.tryGetChild(t,o)}getRuleContexts(t){let o=[];if(!this.children)return o;for(let e of this.children)e instanceof t&&o.push(e);return o}get childCount(){return this.children?this.children.length:0}get sourceInterval(){return this._start?!this._stop||this._stop.tokenIndex<this._start.tokenIndex?p.Interval.of(this._start.tokenIndex,this._start.tokenIndex-1):p.Interval.of(this._start.tokenIndex,this._stop.tokenIndex):p.Interval.INVALID}get start(){return this._start}get stop(){return this._stop}toInfoString(t){return"ParserRuleContext"+t.getRuleInvocationStack(this).reverse()+"{start="+this._start+", stop="+this._stop+"}"}};return r.EMPTY=new r,l([x.Override],r.prototype,"parent",null),l([x.Override],r.prototype,"childCount",null),l([x.Override],r.prototype,"sourceInterval",null),Ir.ParserRuleContext=r,Ir}var bn={},Xs;function Ka(){return Xs||(Xs=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=bn&&bn.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(l,"__esModule",{value:!0}),l.PredictionMode=void 0;const p=pn(),x=xe(),h=z(),s=Wn();(function(r){r[r.SLL=0]="SLL",r[r.LL=1]="LL",r[r.LL_EXACT_AMBIG_DETECTION=2]="LL_EXACT_AMBIG_DETECTION"})(l.PredictionMode||(l.PredictionMode={})),function(r){class n extends p.Array2DHashMap{constructor(){super(t.INSTANCE)}}class t{AltAndContextConfigEqualityComparator(){}hashCode(u){let c=x.MurmurHash.initialize(7);return c=x.MurmurHash.update(c,u.state.stateNumber),c=x.MurmurHash.update(c,u.context),c=x.MurmurHash.finish(c,2),c}equals(u,c){return u===c?!0:u==null||c==null?!1:u.state.stateNumber===c.state.stateNumber&&u.context.equals(c.context)}}t.INSTANCE=new t,a([h.Override],t.prototype,"hashCode",null),a([h.Override],t.prototype,"equals",null);function o(i){for(let u of i)if(u.state instanceof s.RuleStopState)return!0;return!1}r.hasConfigInRuleStopState=o;function e(i){for(let u of i)if(!(u.state instanceof s.RuleStopState))return!1;return!0}r.allConfigsInRuleStopStates=e}(l.PredictionMode||(l.PredictionMode={}))}(bn)),bn}var Tt={},Ws;function ra(){if(Ws)return Tt;Ws=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Tt&&Tt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=Tt&&Tt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(Tt,"__esModule",{value:!0}),Tt.SimulatorState=void 0;const p=z(),x=Me();let h=class{constructor(r,n,t,o){this.outerContext=r??x.ParserRuleContext.emptyContext(),this.s0=n,this.useContext=t,this.remainingOuterContext=o}};return h=l([a(1,p.NotNull)],h),Tt.SimulatorState=h,Tt}var Ks;function Kn(){if(Ks)return St;Ks=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=St&&St.__decorate||function(ve,v,C,D){var L=arguments.length,I=L<3?v:D===null?D=Object.getOwnPropertyDescriptor(v,C):D,P;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")I=Reflect.decorate(ve,v,C,D);else for(var j=ve.length-1;j>=0;j--)(P=ve[j])&&(I=(L<3?P(I):L>3?P(v,C,I):P(v,C))||I);return L>3&&I&&Object.defineProperty(v,C,I),I},a=St&&St.__param||function(ve,v){return function(C,D){v(C,D,ve)}};Object.defineProperty(St,"__esModule",{value:!0}),St.ParserATNSimulator=void 0;const p=dl(),x=Yl(),h=Jt(),s=Wi(),r=ze(),n=ui(),t=Yn(),o=ai(),e=Te(),i=Xl(),u=er(),c=Wa(),f=un(),A=li(),d=Ki(),_=ye(),m=$t(),S=z(),E=no(),g=pi(),T=qe(),N=Me(),y=Be(),O=$i(),F=Ka(),w=Wn(),M=io(),W=fn(),ee=ro(),J=ra(),ae=pe(),Se=ln(),ue=be(),ke=65535,Ne=-2147483648;let te=class oe extends o.ATNSimulator{constructor(v,C){super(v),this.predictionMode=F.PredictionMode.LL,this.force_global_context=!1,this.always_try_local_context=!0,this.enable_global_context_dfa=!1,this.optimize_unique_closure=!0,this.optimize_ll1=!0,this.optimize_tail_calls=!0,this.tail_call_preserves_sll=!0,this.treat_sllk1_conflict_as_ambiguity=!1,this.reportAmbiguities=!1,this.userWantsCtxSensitive=!0,this._parser=C}getPredictionMode(){return this.predictionMode}setPredictionMode(v){this.predictionMode=v}reset(){}adaptivePredict(v,C,D,L){L===void 0&&(L=!1);let I=this.atn.decisionToDFA[C];if(ue(I!=null),this.optimize_ll1&&!I.isPrecedenceDfa&&!I.isEmpty){let G=v.LA(1);if(G>=0&&G<=65535){let Y=(C<<16>>>0)+G,R=this.atn.LL1Table.get(Y);if(R!=null)return R}}this.dfa=I,this.force_global_context?L=!0:this.always_try_local_context||(L=L||I.isContextSensitive),this.userWantsCtxSensitive=L||this.predictionMode!==F.PredictionMode.SLL&&D!=null&&!this.atn.decisionToState[C].sll,D==null&&(D=N.ParserRuleContext.emptyContext());let P;I.isEmpty||(P=this.getStartState(I,v,D,L)),P==null&&(D==null&&(D=N.ParserRuleContext.emptyContext()),oe.debug&&console.log("ATN decision "+I.decision+" exec LA(1)=="+this.getLookaheadName(v)+", outerContext="+D.toString(this._parser)),P=this.computeStartState(I,D,L));let j=v.mark(),K=v.index;try{let G=this.execDFA(I,v,K,P);return oe.debug&&console.log("DFA after predictATN: "+I.toString(this._parser.vocabulary,this._parser.ruleNames)),G}finally{this.dfa=void 0,v.seek(K),v.release(j)}}getStartState(v,C,D,L){if(!L)if(v.isPrecedenceDfa){let j=v.getPrecedenceStartState(this._parser.precedence,!1);return j==null?void 0:new J.SimulatorState(D,j,!1,D)}else return v.s0==null?void 0:new J.SimulatorState(D,v.s0,!1,D);if(!this.enable_global_context_dfa)return;let I=D;ue(D!=null);let P;for(v.isPrecedenceDfa?P=v.getPrecedenceStartState(this._parser.precedence,!0):P=v.s0full;I!=null&&P!=null&&P.isContextSensitive;)I=this.skipTailCalls(I),P=P.getContextTarget(this.getReturnState(I)),I.isEmpty?ue(P==null||!P.isContextSensitive):I=I.parent;if(P!=null)return new J.SimulatorState(D,P,L,I)}execDFA(v,C,D,L){let I=L.outerContext;oe.dfa_debug&&console.log("DFA decision "+v.decision+" exec LA(1)=="+this.getLookaheadName(C)+", outerContext="+I.toString(this._parser)),oe.dfa_debug&&console.log(v.toString(this._parser.vocabulary,this._parser.ruleNames));let P=L.s0,j=C.LA(1),K=L.remainingOuterContext;for(;;){if(oe.dfa_debug&&console.log("DFA state "+P.stateNumber+" LA(1)=="+this.getLookaheadName(C)),L.useContext)for(;P.isContextSymbol(j);){let R;if(K!=null&&(K=this.skipTailCalls(K),R=P.getContextTarget(this.getReturnState(K))),R==null){let b=new J.SimulatorState(L.outerContext,P,L.useContext,K);return this.execATN(v,C,D,b)}ue(K!=null),K=K.parent,P=R}if(this.isAcceptState(P,L.useContext)){P.predicates!=null?oe.dfa_debug&&console.log("accept "+P):oe.dfa_debug&&console.log("accept; predict "+P.prediction+" in state "+P.stateNumber);break}ue(!this.isAcceptState(P,L.useContext));let Y=this.getExistingTargetState(P,j);if(Y==null){oe.dfa_debug&&j>=0&&console.log("no edge for "+this._parser.vocabulary.getDisplayName(j));let R;if(oe.dfa_debug){let B=_.Interval.of(D,this._parser.inputStream.index);console.log("ATN exec upon "+this._parser.inputStream.getText(B)+" at DFA state "+P.stateNumber)}let b=new J.SimulatorState(I,P,L.useContext,K);return R=this.execATN(v,C,D,b),oe.dfa_debug&&console.log("back from DFA update, alt="+R+`, dfa=
`+v.toString(this._parser.vocabulary,this._parser.ruleNames)),oe.dfa_debug&&console.log("DFA decision "+v.decision+" predicts "+R),R}else if(Y===o.ATNSimulator.ERROR){let R=new J.SimulatorState(I,P,L.useContext,K);return this.handleNoViableAlt(C,D,R)}P=Y,!this.isAcceptState(P,L.useContext)&&j!==m.IntStream.EOF&&(C.consume(),j=C.LA(1))}if(!L.useContext&&P.configs.conflictInfo!=null&&v.atnStartState instanceof f.DecisionState&&!(!this.userWantsCtxSensitive||!P.configs.dipsIntoOuterContext&&P.configs.isExactConflict||this.treat_sllk1_conflict_as_ambiguity&&C.index===D)){ue(!L.useContext);let Y,R=P.predicates;if(R!=null){let b=C.index;if(b!==D&&C.seek(D),Y=this.evalSemanticContext(R,I,!0),Y.cardinality()===1)return Y.nextSetBit(0);b!==D&&C.seek(b)}if(this.reportAmbiguities){let b=new J.SimulatorState(I,P,L.useContext,K);this.reportAttemptingFullContext(v,Y,b,D,C.index)}return C.seek(D),this.adaptivePredict(C,v.decision,I,!0)}let G=P.predicates;if(G!=null){let Y=C.index;D!==Y&&C.seek(D);let R=this.evalSemanticContext(G,I,this.reportAmbiguities&&this.predictionMode===F.PredictionMode.LL_EXACT_AMBIG_DETECTION);switch(R.cardinality()){case 0:throw this.noViableAlt(C,I,P.configs,D);case 1:return R.nextSetBit(0);default:return D!==Y&&C.seek(Y),this.reportAmbiguity(v,P,D,Y,P.configs.isExactConflict,R,P.configs),R.nextSetBit(0)}}return oe.dfa_debug&&console.log("DFA decision "+v.decision+" predicts "+P.prediction),P.prediction}isAcceptState(v,C){return v.isAcceptState?v.configs.conflictingAlts==null?!0:C&&this.predictionMode===F.PredictionMode.LL_EXACT_AMBIG_DETECTION?v.configs.isExactConflict:!0:!1}execATN(v,C,D,L){oe.debug&&console.log("execATN decision "+v.decision+" exec LA(1)=="+this.getLookaheadName(C));let I=L.outerContext,P=L.useContext,j=C.LA(1),K=L,G=new O.PredictionContextCache;for(;;){let Y=this.computeReachSet(v,K,j,G);if(Y==null)return this.setDFAEdge(K.s0,C.LA(1),o.ATNSimulator.ERROR),this.handleNoViableAlt(C,D,K);let R=Y.s0;if(ue(R.isAcceptState||R.prediction===r.ATN.INVALID_ALT_NUMBER),ue(R.isAcceptState||R.configs.conflictInfo==null),this.isAcceptState(R,P)){let b=R.configs.conflictingAlts,B=b==null?R.prediction:r.ATN.INVALID_ALT_NUMBER;if(B!==r.ATN.INVALID_ALT_NUMBER){if(this.optimize_ll1&&C.index===D&&!v.isPrecedenceDfa&&Y.outerContext===Y.remainingOuterContext&&v.decision>=0&&!R.configs.hasSemanticContext&&j>=0&&j<=ke){let H=(v.decision<<16>>>0)+j;this.atn.LL1Table.set(H,B)}P&&this.always_try_local_context&&this.reportContextSensitivity(v,B,Y,D,C.index)}B=R.prediction;let U=b!=null&&this.userWantsCtxSensitive;if(U&&(U=!P&&(R.configs.dipsIntoOuterContext||!R.configs.isExactConflict)&&(!this.treat_sllk1_conflict_as_ambiguity||C.index!==D)),R.configs.hasSemanticContext){let H=R.predicates;if(H!=null){let X=C.index;switch(X!==D&&C.seek(D),b=this.evalSemanticContext(H,I,U||this.reportAmbiguities),b.cardinality()){case 0:throw this.noViableAlt(C,I,R.configs,D);case 1:return b.nextSetBit(0)}X!==D&&C.seek(X)}}if(U){ue(!P),ue(this.isAcceptState(R,!1)),oe.debug&&console.log("RETRY with outerContext="+I);let H=this.computeStartState(v,I,!0);return this.reportAmbiguities&&this.reportAttemptingFullContext(v,b,Y,D,C.index),C.seek(D),this.execATN(v,C,D,H)}else return b!=null&&(this.reportAmbiguities&&b.cardinality()>1&&this.reportAmbiguity(v,R,D,C.index,R.configs.isExactConflict,b,R.configs),B=b.nextSetBit(0)),B}K=Y,j!==m.IntStream.EOF&&(C.consume(),j=C.LA(1))}}handleNoViableAlt(v,C,D){if(D.s0!=null){let L=new u.BitSet,I=0;for(let P of D.s0.configs)(P.reachesIntoOuterContext||P.state instanceof w.RuleStopState)&&(L.set(P.alt),I=Math.max(I,P.alt));switch(L.cardinality()){case 0:break;case 1:return L.nextSetBit(0);default:if(!D.s0.configs.hasSemanticContext)return L.nextSetBit(0);let P=new t.ATNConfigSet;for(let K of D.s0.configs)(K.reachesIntoOuterContext||K.state instanceof w.RuleStopState)&&P.add(K);let j=this.getPredsForAmbigAlts(L,P,I);if(j!=null){let K=this.getPredicatePredictions(L,j);if(K!=null){let G=v.index;try{v.seek(C);let Y=this.evalSemanticContext(K,D.outerContext,!1);if(!Y.isEmpty)return Y.nextSetBit(0)}finally{v.seek(G)}}}return L.nextSetBit(0)}}throw this.noViableAlt(v,D.outerContext,D.s0.configs,C)}computeReachSet(v,C,D,L){let I=C.useContext,P=C.remainingOuterContext,j=C.s0;if(I)for(;j.isContextSymbol(D);){let Y;if(P!=null&&(P=this.skipTailCalls(P),Y=j.getContextTarget(this.getReturnState(P))),Y==null)break;ue(P!=null),P=P.parent,j=Y}if(ue(!this.isAcceptState(j,I)),this.isAcceptState(j,I))return new J.SimulatorState(C.outerContext,j,I,P);let K=j,G=this.getExistingTargetState(K,D);if(G==null){let Y=this.computeTargetState(v,K,P,D,I,L);G=Y[0],P=Y[1]}if(G!==o.ATNSimulator.ERROR)return ue(!I||!G.configs.dipsIntoOuterContext),new J.SimulatorState(C.outerContext,G,I,P)}getExistingTargetState(v,C){return v.getTarget(C)}computeTargetState(v,C,D,L,I,P){let j=C.configs.toArray(),K,G=new t.ATNConfigSet,Y;do{let b=!I||D!=null;b||(G.isOutermostConfigSet=!0);let B=new t.ATNConfigSet,U;for(let $ of j){if(oe.debug&&console.log("testing "+this.getTokenName(L)+" at "+$.toString()),$.state instanceof w.RuleStopState){ue($.context.isEmpty),(I&&!$.reachesIntoOuterContext||L===m.IntStream.EOF)&&(U==null&&(U=[]),U.push($));continue}let k=$.state.numberOfOptimizedTransitions;for(let re=0;re<k;re++){let he=$.state.getOptimizedTransition(re),me=this.getReachableTarget($,he,L);me!=null&&B.add($.transform(me,!1),P)}}if(this.optimize_unique_closure&&U==null&&L!==ae.Token.EOF&&B.uniqueAlt!==r.ATN.INVALID_ALT_NUMBER){B.isOutermostConfigSet=G.isOutermostConfigSet,G=B;break}let H=!1,X=L===ae.Token.EOF;if(this.closure(B,G,H,b,P,X),Y=G.dipsIntoOuterContext,L===m.IntStream.EOF&&(G=this.removeAllConfigsNotInRuleStopState(G,P)),U!=null&&(!I||!F.PredictionMode.hasConfigInRuleStopState(G))){ue(U.length>0);for(let $ of U)G.add($,P)}if(I&&Y){G.clear(),D=D,D=this.skipTailCalls(D);let $=this.getReturnState(D);if(K==null&&(K=new d.IntegerList),D.isEmpty?D=void 0:D=D.parent,K.add($),$!==y.PredictionContext.EMPTY_FULL_STATE_KEY)for(let k=0;k<j.length;k++)j[k]=j[k].appendContext($,P)}}while(I&&Y);return G.isEmpty?(this.setDFAEdge(C,L,o.ATNSimulator.ERROR),[o.ATNSimulator.ERROR,D]):[this.addDFAEdge(v,C,L,K,G,P),D]}removeAllConfigsNotInRuleStopState(v,C){if(F.PredictionMode.allConfigsInRuleStopStates(v))return v;let D=new t.ATNConfigSet;for(let L of v)L.state instanceof w.RuleStopState&&D.add(L,C);return D}computeStartState(v,C,D){let L=v.isPrecedenceDfa?v.getPrecedenceStartState(this._parser.precedence,D):D?v.s0full:v.s0;if(L!=null){if(!D)return new J.SimulatorState(C,L,D,C);L.setContextSensitive(this.atn)}v.decision;let I=v.atnStartState,P=0,j=C,K=D?y.PredictionContext.EMPTY_FULL:y.PredictionContext.EMPTY_LOCAL,G=new O.PredictionContextCache;if(D){if(!this.enable_global_context_dfa)for(;j!=null;)j.isEmpty?(P=y.PredictionContext.EMPTY_FULL_STATE_KEY,j=void 0):(P=this.getReturnState(j),K=K.appendSingleContext(P,G),j=j.parent);for(;L!=null&&L.isContextSensitive&&j!=null;){let R;if(j=this.skipTailCalls(j),j.isEmpty?(R=L.getContextTarget(y.PredictionContext.EMPTY_FULL_STATE_KEY),P=y.PredictionContext.EMPTY_FULL_STATE_KEY,j=void 0):(P=this.getReturnState(j),R=L.getContextTarget(P),K=K.appendSingleContext(P,G),j=j.parent),R==null)break;L=R}}if(L!=null&&!L.isContextSensitive)return new J.SimulatorState(C,L,D,j);let Y=new t.ATNConfigSet;for(;;){let R=new t.ATNConfigSet,b=I.numberOfTransitions;for(let k=0;k<b;k++){let re=I.transition(k).target;R.add(n.ATNConfig.create(re,k+1,K))}let B=j!=null;B||(Y.isOutermostConfigSet=!0),this.closure(R,Y,!0,B,G,!1);let H=Y.dipsIntoOuterContext,X;if(D&&!this.enable_global_context_dfa){L=this.addDFAState(v,Y,G);break}else L==null?v.isPrecedenceDfa?(Y=this.applyPrecedenceFilter(Y,C,G),X=this.addDFAState(v,Y,G),v.setPrecedenceStartState(this._parser.precedence,D,X)):(X=this.addDFAState(v,Y,G),D?v.s0full?X=v.s0full:v.s0full=X:v.s0?X=v.s0:v.s0=X):(v.isPrecedenceDfa&&(Y=this.applyPrecedenceFilter(Y,C,G)),X=this.addDFAState(v,Y,G),L.setContextTarget(P,X));if(L=X,!D||!H)break;X.setContextSensitive(this.atn),j=j,Y.clear(),j=this.skipTailCalls(j);let $=this.getReturnState(j);j.isEmpty?j=void 0:j=j.parent,$!==y.PredictionContext.EMPTY_FULL_STATE_KEY&&(K=K.appendSingleContext($,G)),P=$}return new J.SimulatorState(C,L,D,j)}applyPrecedenceFilter(v,C,D){let L=new Map,I=new t.ATNConfigSet;for(let P of v){if(P.alt!==1)continue;let j=P.semanticContext.evalPrecedence(this._parser,C);j!=null&&(L.set(P.state.stateNumber,P.context),j!==P.semanticContext?I.add(P.transform(P.state,!1,j),D):I.add(P,D))}for(let P of v)if(P.alt!==1){if(!P.isPrecedenceFilterSuppressed){let j=L.get(P.state.stateNumber);if(j!=null&&j.equals(P.context))continue}I.add(P,D)}return I}getReachableTarget(v,C,D){if(C.matches(D,0,this.atn.maxTokenType))return C.target}predicateDFAState(v,C,D){let L=this.getConflictingAltsFromConfigSet(C);if(!L)throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");oe.debug&&console.log("predicateDFAState "+v);let I=this.getPredsForAmbigAlts(L,C,D),P;return I!=null&&(P=this.getPredicatePredictions(L,I),v.predicates=P),P}getPredsForAmbigAlts(v,C,D){let L=new Array(D+1),I=L.length;for(let K of C)v.get(K.alt)&&(L[K.alt]=W.SemanticContext.or(L[K.alt],K.semanticContext));let P=0;for(let K=0;K<I;K++)L[K]==null?L[K]=W.SemanticContext.NONE:L[K]!==W.SemanticContext.NONE&&P++;let j=L;return P===0&&(j=void 0),oe.debug&&console.log("getPredsForAmbigAlts result "+(j?s.Arrays.toString(j):"undefined")),j}getPredicatePredictions(v,C){let D=[],L=!1;for(let I=1;I<C.length;I++){let P=C[I];ue(P!=null),v!=null&&v.get(I)&&P===W.SemanticContext.NONE?D.push(new A.DFAState.PredPrediction(P,I)):P!==W.SemanticContext.NONE&&(L=!0,D.push(new A.DFAState.PredPrediction(P,I)))}if(L)return D}evalSemanticContext(v,C,D){let L=new u.BitSet;for(let I of v){if(I.pred===W.SemanticContext.NONE){if(L.set(I.alt),!D)break;continue}let P=this.evalSemanticContextImpl(I.pred,C,I.alt);if((oe.debug||oe.dfa_debug)&&console.log("eval pred "+I+"="+P),P&&((oe.debug||oe.dfa_debug)&&console.log("PREDICT "+I.alt),L.set(I.alt),!D))break}return L}evalSemanticContextImpl(v,C,D){return v.eval(this._parser,C)}closure(v,C,D,L,I,P){I==null&&(I=O.PredictionContextCache.UNCACHED);let j=v,K=new h.Array2DHashSet(T.ObjectEqualityComparator.INSTANCE);for(;j.size>0;){let G=new t.ATNConfigSet;for(let Y of j)this.closureImpl(Y,C,G,K,D,L,I,0,P);j=G}}closureImpl(v,C,D,L,I,P,j,K,G){if(oe.debug&&console.log("closure("+v.toString(this._parser,!0)+")"),v.state instanceof w.RuleStopState)if(v.context.isEmpty)if(P)oe.debug&&console.log("FALLING off rule "+this.getRuleName(v.state.ruleIndex)),v.context===y.PredictionContext.EMPTY_FULL?v=v.transform(v.state,!1,y.PredictionContext.EMPTY_LOCAL):!v.reachesIntoOuterContext&&y.PredictionContext.isEmptyLocal(v.context)&&C.add(v,j);else{C.add(v,j);return}else{let R=v.context.hasEmpty,b=v.context.size-(R?1:0);for(let B=0;B<b;B++){let U=v.context.getParent(B),H=this.atn.states[v.context.getReturnState(B)],X=n.ATNConfig.create(H,v.alt,U,v.semanticContext);X.outerContextDepth=v.outerContextDepth,X.isPrecedenceFilterSuppressed=v.isPrecedenceFilterSuppressed,ue(K>Ne),this.closureImpl(X,C,D,L,I,P,j,K-1,G)}if(!R||!P)return;v=v.transform(v.state,!1,y.PredictionContext.EMPTY_LOCAL)}let Y=v.state;Y.onlyHasEpsilonTransitions||(C.add(v,j),oe.debug&&console.log("added config "+C));for(let R=0;R<Y.numberOfOptimizedTransitions;R++){if(R===0&&Y.stateType===e.ATNStateType.STAR_LOOP_ENTRY&&Y.precedenceRuleDecision&&!v.context.hasEmpty){let H=Y,X=!0;for(let $=0;$<v.context.size;$++)if(!H.precedenceLoopbackStates.get(v.context.getReturnState($))){X=!1;break}if(X)continue}let b=Y.getOptimizedTransition(R),B=!(b instanceof x.ActionTransition)&&I,U=this.getEpsilonTarget(v,b,B,K===0,j,G);if(U!=null){if(b instanceof M.RuleTransition&&D!=null&&!I){D.add(U,j);continue}let H=K;if(v.state instanceof w.RuleStopState){if(this.dfa!=null&&this.dfa.isPrecedenceDfa&&b.outermostPrecedenceReturn===this.dfa.atnStartState.ruleIndex&&(U.isPrecedenceFilterSuppressed=!0),U.outerContextDepth=U.outerContextDepth+1,!L.add(U))continue;ue(H>Ne),H--,oe.debug&&console.log("dips into outer ctx: "+U)}else if(b instanceof M.RuleTransition)this.optimize_tail_calls&&b.optimizedTailCall&&(!this.tail_call_preserves_sll||!y.PredictionContext.isEmptyLocal(v.context))?(ue(U.context===v.context),H===0&&(H--,!this.tail_call_preserves_sll&&y.PredictionContext.isEmptyLocal(v.context)&&(U.outerContextDepth=U.outerContextDepth+1))):H>=0&&H++;else if(!b.isEpsilon&&!L.add(U))continue;this.closureImpl(U,C,D,L,B,P,j,H,G)}}}getRuleName(v){return this._parser!=null&&v>=0?this._parser.ruleNames[v]:"<rule "+v+">"}getEpsilonTarget(v,C,D,L,I,P){switch(C.serializationType){case 3:return this.ruleTransition(v,C,I);case 10:return this.precedenceTransition(v,C,D,L);case 4:return this.predTransition(v,C,D,L);case 6:return this.actionTransition(v,C);case 1:return v.transform(C.target,!1);case 5:case 2:case 7:return P&&C.matches(ae.Token.EOF,0,1)?v.transform(C.target,!1):void 0;default:return}}actionTransition(v,C){return oe.debug&&console.log("ACTION edge "+C.ruleIndex+":"+C.actionIndex),v.transform(C.target,!1)}precedenceTransition(v,C,D,L){oe.debug&&(console.log("PRED (collectPredicates="+D+") "+C.precedence+">=_p, ctx dependent=true"),this._parser!=null&&console.log("context surrounding pred is "+this._parser.getRuleInvocationStack()));let I;if(D&&L){let P=W.SemanticContext.and(v.semanticContext,C.predicate);I=v.transform(C.target,!1,P)}else I=v.transform(C.target,!1);return oe.debug&&console.log("config from pred transition="+I),I}predTransition(v,C,D,L){oe.debug&&(console.log("PRED (collectPredicates="+D+") "+C.ruleIndex+":"+C.predIndex+", ctx dependent="+C.isCtxDependent),this._parser!=null&&console.log("context surrounding pred is "+this._parser.getRuleInvocationStack()));let I;if(D&&(!C.isCtxDependent||C.isCtxDependent&&L)){let P=W.SemanticContext.and(v.semanticContext,C.predicate);I=v.transform(C.target,!1,P)}else I=v.transform(C.target,!1);return oe.debug&&console.log("config from pred transition="+I),I}ruleTransition(v,C,D){oe.debug&&console.log("CALL rule "+this.getRuleName(C.target.ruleIndex)+", ctx="+v.context);let L=C.followState,I;return this.optimize_tail_calls&&C.optimizedTailCall&&(!this.tail_call_preserves_sll||!y.PredictionContext.isEmptyLocal(v.context))?I=v.context:D!=null?I=D.getChild(v.context,L.stateNumber):I=v.context.getChild(L.stateNumber),v.transform(C.target,!1,I)}isConflicted(v,C){if(v.uniqueAlt!==r.ATN.INVALID_ALT_NUMBER||v.size<=1)return;let D=v.toArray();D.sort(oe.STATE_ALT_SORT_COMPARATOR);let L=!v.dipsIntoOuterContext,I=new u.BitSet,P=D[0].alt;I.set(P);let j=D[0].state.nonStopStateNumber;for(let b of D){let B=b.state.nonStopStateNumber;if(B!==j){if(b.alt!==P)return;j=B}}let K;if(L){j=D[0].state.nonStopStateNumber,K=new u.BitSet;let b=P;for(let U of D){if(U.state.nonStopStateNumber!==j)break;let H=U.alt;K.set(H),b=H}j=D[0].state.nonStopStateNumber;let B=P;for(let U of D){let H=U.state.nonStopStateNumber,X=U.alt;if(H!==j){if(B!==b){L=!1;break}j=H,B=P}else if(X!==B){if(X!==K.nextSetBit(B+1)){L=!1;break}B=X}}}j=D[0].state.nonStopStateNumber;let G=0,Y=0,R=D[0].context;for(let b=1;b<D.length;b++){let B=D[b];if(B.alt!==P||B.state.nonStopStateNumber!==j)break;Y=b,R=C.join(R,D[b].context)}for(let b=Y+1;b<D.length;b++){let B=D[b],U=B.state;if(I.set(B.alt),U.nonStopStateNumber!==j){j=U.nonStopStateNumber,G=b,Y=b,R=B.context;for(let re=G+1;re<D.length;re++){let he=D[re];if(he.alt!==P||he.state.nonStopStateNumber!==j)break;Y=re,R=C.join(R,he.context)}b=Y;continue}let H=B.context,X=B.alt,$=b;for(let re=$+1;re<D.length;re++){let he=D[re];if(he.alt!==X||he.state.nonStopStateNumber!==j)break;$=re,H=C.join(H,he.context)}b=$;let k=C.join(R,H);if(!R.equals(k))return;L=L&&R.equals(H)}return new c.ConflictInfo(I,L)}getConflictingAltsFromConfigSet(v){let C=v.conflictingAlts;return C==null&&v.uniqueAlt!==r.ATN.INVALID_ALT_NUMBER&&(C=new u.BitSet,C.set(v.uniqueAlt)),C}getTokenName(v){if(v===ae.Token.EOF)return"EOF";let D=(this._parser!=null?this._parser.vocabulary:Se.VocabularyImpl.EMPTY_VOCABULARY).getDisplayName(v);return D===String(v)?D:D+"<"+v+">"}getLookaheadName(v){return this.getTokenName(v.LA(1))}dumpDeadEndConfigs(v){console.log("dead end configs: ");let C=v.deadEndConfigs;if(C)for(let D of C){let L="no edges";if(D.state.numberOfOptimizedTransitions>0){let I=D.state.getOptimizedTransition(0);I instanceof i.AtomTransition?L="Atom "+this.getTokenName(I._label):I instanceof ee.SetTransition&&(L=(I instanceof E.NotSetTransition?"~":"")+"Set "+I.set.toString())}console.log(D.toString(this._parser,!0)+":"+L)}}noViableAlt(v,C,D,L){return new g.NoViableAltException(this._parser,v,v.get(L),v.LT(1),D,C)}getUniqueAlt(v){let C=r.ATN.INVALID_ALT_NUMBER;for(let D of v)if(C===r.ATN.INVALID_ALT_NUMBER)C=D.alt;else if(D.alt!==C)return r.ATN.INVALID_ALT_NUMBER;return C}configWithAltAtStopState(v,C){for(let D of v)if(D.alt===C&&D.state instanceof w.RuleStopState)return!0;return!1}addDFAEdge(v,C,D,L,I,P){ue(L==null||L.isEmpty||v.isContextSensitive);let j=C,K=this.addDFAState(v,I,P);if(L!=null)for(let G of L.toArray()){if(G===y.PredictionContext.EMPTY_FULL_STATE_KEY&&j.configs.isOutermostConfigSet)continue;j.setContextSensitive(this.atn),j.setContextSymbol(D);let Y=j.getContextTarget(G);if(Y!=null){j=Y;continue}Y=this.addDFAContextState(v,j.configs,G,P),ue(G!==y.PredictionContext.EMPTY_FULL_STATE_KEY||Y.configs.isOutermostConfigSet),j.setContextTarget(G,Y),j=Y}return oe.debug&&console.log("EDGE "+j+" -> "+K+" upon "+this.getTokenName(D)),this.setDFAEdge(j,D,K),oe.debug&&console.log(`DFA=
`+v.toString(this._parser!=null?this._parser.vocabulary:Se.VocabularyImpl.EMPTY_VOCABULARY,this._parser!=null?this._parser.ruleNames:void 0)),K}setDFAEdge(v,C,D){v!=null&&v.setTarget(C,D)}addDFAContextState(v,C,D,L){if(D!==y.PredictionContext.EMPTY_FULL_STATE_KEY){let I=new t.ATNConfigSet;for(let P of C)I.add(P.appendContext(D,L));return this.addDFAState(v,I,L)}else return ue(!C.isOutermostConfigSet,"Shouldn't be adding a duplicate edge."),C=C.clone(!0),C.isOutermostConfigSet=!0,this.addDFAState(v,C,L)}addDFAState(v,C,D){let L=this.enable_global_context_dfa||!C.isOutermostConfigSet;if(L){C.isReadOnly||C.optimizeConfigs(this);let G=this.createDFAState(v,C),Y=v.states.get(G);if(Y!=null)return Y}C.isReadOnly||C.conflictInfo==null&&(C.conflictInfo=this.isConflicted(C,D));let I=this.createDFAState(v,C.clone(!0)),P=this.atn.getDecisionState(v.decision),j=this.getUniqueAlt(C);if(j!==r.ATN.INVALID_ALT_NUMBER)I.acceptStateInfo=new p.AcceptStateInfo(j);else if(C.conflictingAlts!=null){let G=C.conflictingAlts;G&&(I.acceptStateInfo=new p.AcceptStateInfo(G.nextSetBit(0)))}if(I.isAcceptState&&C.hasSemanticContext&&this.predicateDFAState(I,C,P.numberOfTransitions),!L)return I;let K=v.addState(I);return oe.debug&&K===I&&console.log("adding new DFA state: "+I),K}createDFAState(v,C){return new A.DFAState(C)}reportAttemptingFullContext(v,C,D,L,I){if(oe.debug||oe.retry_debug){let P=_.Interval.of(L,I);console.log("reportAttemptingFullContext decision="+v.decision+":"+D.s0.configs+", input="+this._parser.inputStream.getText(P))}if(this._parser!=null){let P=this._parser.getErrorListenerDispatch();P.reportAttemptingFullContext&&P.reportAttemptingFullContext(this._parser,v,L,I,C,D)}}reportContextSensitivity(v,C,D,L,I){if(oe.debug||oe.retry_debug){let P=_.Interval.of(L,I);console.log("reportContextSensitivity decision="+v.decision+":"+D.s0.configs+", input="+this._parser.inputStream.getText(P))}if(this._parser!=null){let P=this._parser.getErrorListenerDispatch();P.reportContextSensitivity&&P.reportContextSensitivity(this._parser,v,L,I,C,D)}}reportAmbiguity(v,C,D,L,I,P,j){if(oe.debug||oe.retry_debug){let K=_.Interval.of(D,L);console.log("reportAmbiguity "+P+":"+j+", input="+this._parser.inputStream.getText(K))}if(this._parser!=null){let K=this._parser.getErrorListenerDispatch();K.reportAmbiguity&&K.reportAmbiguity(this._parser,v,D,L,I,P,j)}}getReturnState(v){return v.isEmpty?y.PredictionContext.EMPTY_FULL_STATE_KEY:this.atn.states[v.invokingState].transition(0).followState.stateNumber}skipTailCalls(v){if(!this.optimize_tail_calls)return v;for(;!v.isEmpty;){let C=this.atn.states[v.invokingState];if(ue(C.numberOfTransitions===1&&C.transition(0).serializationType===3),!C.transition(0).tailCall)break;v=v.parent}return v}get parser(){return this._parser}};return te.debug=!1,te.dfa_debug=!1,te.retry_debug=!1,te.STATE_ALT_SORT_COMPARATOR=(ve,v)=>{let C=ve.state.nonStopStateNumber-v.state.nonStopStateNumber;return C!==0||(C=ve.alt-v.alt,C!==0)?C:0},l([S.NotNull],te.prototype,"predictionMode",void 0),l([S.NotNull],te.prototype,"getPredictionMode",null),l([a(0,S.NotNull)],te.prototype,"setPredictionMode",null),l([S.Override],te.prototype,"reset",null),l([a(0,S.NotNull)],te.prototype,"adaptivePredict",null),l([a(0,S.NotNull),a(1,S.NotNull),a(2,S.NotNull)],te.prototype,"getStartState",null),l([a(0,S.NotNull),a(1,S.NotNull),a(3,S.NotNull)],te.prototype,"execDFA",null),l([a(0,S.NotNull),a(1,S.NotNull),a(3,S.NotNull)],te.prototype,"execATN",null),l([a(0,S.NotNull),a(2,S.NotNull)],te.prototype,"handleNoViableAlt",null),l([a(0,S.NotNull)],te.prototype,"getExistingTargetState",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"computeTargetState",null),l([S.NotNull,a(0,S.NotNull)],te.prototype,"removeAllConfigsNotInRuleStopState",null),l([S.NotNull],te.prototype,"computeStartState",null),l([S.NotNull,a(0,S.NotNull)],te.prototype,"applyPrecedenceFilter",null),l([a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"getReachableTarget",null),l([a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"getPredsForAmbigAlts",null),l([a(0,S.NotNull)],te.prototype,"evalSemanticContext",null),l([a(0,S.NotNull)],te.prototype,"evalSemanticContextImpl",null),l([a(1,S.NotNull),a(4,S.Nullable)],te.prototype,"closure",null),l([a(0,S.NotNull),a(1,S.NotNull),a(2,S.Nullable),a(3,S.NotNull),a(6,S.NotNull)],te.prototype,"closureImpl",null),l([S.NotNull],te.prototype,"getRuleName",null),l([a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"getEpsilonTarget",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"actionTransition",null),l([S.Nullable,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"precedenceTransition",null),l([S.Nullable,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"predTransition",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull),a(2,S.Nullable)],te.prototype,"ruleTransition",null),l([a(0,S.NotNull)],te.prototype,"isConflicted",null),l([S.NotNull],te.prototype,"getTokenName",null),l([a(0,S.NotNull)],te.prototype,"dumpDeadEndConfigs",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull),a(2,S.NotNull)],te.prototype,"noViableAlt",null),l([a(0,S.NotNull)],te.prototype,"getUniqueAlt",null),l([a(0,S.NotNull)],te.prototype,"configWithAltAtStopState",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull),a(4,S.NotNull)],te.prototype,"addDFAEdge",null),l([a(0,S.Nullable),a(2,S.Nullable)],te.prototype,"setDFAEdge",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"addDFAContextState",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"addDFAState",null),l([S.NotNull,a(0,S.NotNull),a(1,S.NotNull)],te.prototype,"createDFAState",null),l([a(0,S.NotNull),a(2,S.NotNull)],te.prototype,"reportAttemptingFullContext",null),l([a(0,S.NotNull),a(2,S.NotNull)],te.prototype,"reportContextSensitivity",null),l([a(0,S.NotNull),a(5,S.NotNull),a(6,S.NotNull)],te.prototype,"reportAmbiguity",null),te=l([a(0,S.NotNull)],te),St.ParserATNSimulator=te,St}var kr={},Gs;function Ga(){if(Gs)return kr;Gs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=kr&&kr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(kr,"__esModule",{value:!0}),kr.PlusBlockStartState=void 0;const a=Te(),p=fi(),x=z();let h=class extends p.BlockStartState{get stateType(){return a.ATNStateType.PLUS_BLOCK_START}};return l([x.Override],h.prototype,"stateType",null),kr.PlusBlockStartState=h,kr}var jr={},$s;function $a(){if($s)return jr;$s=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=jr&&jr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(jr,"__esModule",{value:!0}),jr.PlusLoopbackState=void 0;const a=Te(),p=un(),x=z();let h=class extends p.DecisionState{get stateType(){return a.ATNStateType.PLUS_LOOP_BACK}};return l([x.Override],h.prototype,"stateType",null),jr.PlusLoopbackState=h,jr}var gt={},Qs;function Qa(){if(Qs)return gt;Qs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=gt&&gt.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=gt&&gt.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(gt,"__esModule",{value:!0}),gt.PrecedencePredicateTransition=void 0;const p=Xi(),x=z(),h=fn();let s=class extends p.AbstractPredicateTransition{constructor(n,t){super(n),this.precedence=t}get serializationType(){return 10}get isEpsilon(){return!0}matches(n,t,o){return!1}get predicate(){return new h.SemanticContext.PrecedencePredicate(this.precedence)}toString(){return this.precedence+" >= _p"}};return l([x.Override],s.prototype,"serializationType",null),l([x.Override],s.prototype,"isEpsilon",null),l([x.Override],s.prototype,"matches",null),l([x.Override],s.prototype,"toString",null),s=l([a(0,x.NotNull)],s),gt.PrecedencePredicateTransition=s,gt}var yt={},Zs;function Za(){if(Zs)return yt;Zs=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=yt&&yt.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=yt&&yt.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(yt,"__esModule",{value:!0}),yt.RangeTransition=void 0;const p=an(),x=z(),h=Zt();let s=class extends h.Transition{constructor(n,t,o){super(n),this.from=t,this.to=o}get serializationType(){return 2}get label(){return p.IntervalSet.of(this.from,this.to)}matches(n,t,o){return n>=this.from&&n<=this.to}toString(){return"'"+String.fromCodePoint(this.from)+"'..'"+String.fromCodePoint(this.to)+"'"}};return l([x.Override],s.prototype,"serializationType",null),l([x.Override,x.NotNull],s.prototype,"label",null),l([x.Override],s.prototype,"matches",null),l([x.Override,x.NotNull],s.prototype,"toString",null),s=l([a(0,x.NotNull)],s),yt.RangeTransition=s,yt}var qr={},Js;function Ja(){if(Js)return qr;Js=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=qr&&qr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(qr,"__esModule",{value:!0}),qr.RuleStartState=void 0;const a=Yt(),p=Te(),x=z();let h=class extends a.ATNState{constructor(){super(...arguments),this.isPrecedenceRule=!1,this.leftFactored=!1}get stateType(){return p.ATNStateType.RULE_START}};return l([x.Override],h.prototype,"stateType",null),qr.RuleStartState=h,qr}var zr={},eu;function ec(){if(eu)return zr;eu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=zr&&zr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(zr,"__esModule",{value:!0}),zr.StarBlockStartState=void 0;const a=Te(),p=fi(),x=z();let h=class extends p.BlockStartState{get stateType(){return a.ATNStateType.STAR_BLOCK_START}};return l([x.Override],h.prototype,"stateType",null),zr.StarBlockStartState=h,zr}var Ur={},tu;function tc(){if(tu)return Ur;tu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ur&&Ur.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Ur,"__esModule",{value:!0}),Ur.StarLoopbackState=void 0;const a=Yt(),p=Te(),x=z();let h=class extends a.ATNState{get loopEntryState(){return this.transition(0).target}get stateType(){return p.ATNStateType.STAR_LOOP_BACK}};return l([x.Override],h.prototype,"stateType",null),Ur.StarLoopbackState=h,Ur}var Hr={},ru;function rc(){if(ru)return Hr;ru=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Hr&&Hr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Hr,"__esModule",{value:!0}),Hr.TokensStartState=void 0;const a=Te(),p=un(),x=z();let h=class extends p.DecisionState{get stateType(){return a.ATNStateType.TOKEN_START}};return l([x.Override],h.prototype,"stateType",null),Hr.TokensStartState=h,Hr}var Rn={},nu;function nc(){if(nu)return Rn;nu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Rn,"__esModule",{value:!0}),Rn.UUID=void 0;const l=xe();let a=class Hi{constructor(x,h,s,r){this.data=new Uint32Array(4),this.data[0]=x,this.data[1]=h,this.data[2]=s,this.data[3]=r}static fromString(x){if(!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(x))throw new Error("Incorrectly formatted UUID");let h=x.split("-"),s=parseInt(h[0],16),r=(parseInt(h[1],16)<<16>>>0)+parseInt(h[2],16),n=(parseInt(h[3],16)<<16>>>0)+parseInt(h[4].substr(0,4),16),t=parseInt(h[4].substr(-8),16);return new Hi(s,r,n,t)}hashCode(){return l.MurmurHash.hashCode([this.data[0],this.data[1],this.data[2],this.data[3]])}equals(x){return x===this?!0:x instanceof Hi?this.data[0]===x.data[0]&&this.data[1]===x.data[1]&&this.data[2]===x.data[2]&&this.data[3]===x.data[3]:!1}toString(){return("00000000"+this.data[0].toString(16)).substr(-8)+"-"+("0000"+(this.data[1]>>>16).toString(16)).substr(-4)+"-"+("0000"+this.data[1].toString(16)).substr(-4)+"-"+("0000"+(this.data[2]>>>16).toString(16)).substr(-4)+"-"+("0000"+this.data[2].toString(16)).substr(-4)+("00000000"+this.data[3].toString(16)).substr(-8)}};return Rn.UUID=a,Rn}var iu;function uo(){if(iu)return ct;iu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ct&&ct.__decorate||function(Y,R,b,B){var U=arguments.length,H=U<3?R:B===null?B=Object.getOwnPropertyDescriptor(R,b):B,X;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")H=Reflect.decorate(Y,R,b,B);else for(var $=Y.length-1;$>=0;$--)(X=Y[$])&&(H=(U<3?X(H):U>3?X(R,b,H):X(R,b))||H);return U>3&&H&&Object.defineProperty(R,b,H),H},a=ct&&ct.__param||function(Y,R){return function(b,B){R(b,B,Y)}};Object.defineProperty(ct,"__esModule",{value:!0}),ct.ATNDeserializer=void 0;const p=Yl(),x=Jt(),h=ze(),s=Vl(),r=Te(),n=Xl(),t=Ba(),o=jl(),e=er(),i=Ma(),u=fi(),c=un(),f=kl(),A=ka(),d=an(),_=ql(),m=ja(),S=qa(),E=za(),g=Ua(),T=Ha(),N=Va(),y=Ya(),O=Xa(),F=Zl(),w=z(),M=no(),W=Kn(),ee=Ga(),J=$a(),ae=Qa(),Se=hl(),ue=Za(),ke=Ja(),Ne=Wn(),te=io(),ve=ro(),v=ec(),C=tc(),D=to(),L=pe(),I=rc(),P=nc(),j=zl();var K;(function(Y){Y[Y.UNICODE_BMP=0]="UNICODE_BMP",Y[Y.UNICODE_SMP=1]="UNICODE_SMP"})(K||(K={}));let G=class Z{constructor(R){R===void 0&&(R=s.ATNDeserializationOptions.defaultOptions),this.deserializationOptions=R}static get SERIALIZED_VERSION(){return 3}static isFeatureSupported(R,b){let B=Z.SUPPORTED_UUIDS.findIndex(U=>U.equals(R));return B<0?!1:Z.SUPPORTED_UUIDS.findIndex(U=>U.equals(b))>=B}static getUnicodeDeserializer(R){return R===0?{readUnicode:(b,B)=>Z.toInt(b[B]),size:1}:{readUnicode:(b,B)=>Z.toInt32(b,B),size:2}}deserialize(R){R=R.slice(0);for(let q=1;q<R.length;q++)R[q]=R[q]-2&65535;let b=0,B=Z.toInt(R[b++]);if(B!==Z.SERIALIZED_VERSION){let q=`Could not deserialize ATN with version ${B} (expected ${Z.SERIALIZED_VERSION}).`;throw new Error(q)}let U=Z.toUUID(R,b);if(b+=8,Z.SUPPORTED_UUIDS.findIndex(q=>q.equals(U))<0){let q=`Could not deserialize ATN with UUID ${U} (expected ${Z.SERIALIZED_UUID} or a legacy UUID).`;throw new Error(q)}let H=Z.isFeatureSupported(Z.ADDED_LEXER_ACTIONS,U),X=Z.toInt(R[b++]),$=Z.toInt(R[b++]),k=new h.ATN(X,$),re=[],he=[],me=Z.toInt(R[b++]);for(let q=0;q<me;q++){let ne=Z.toInt(R[b++]);if(ne===r.ATNStateType.INVALID_TYPE){k.addState(new _.InvalidState);continue}let se=Z.toInt(R[b++]);se===65535&&(se=-1);let le=this.stateFactory(ne,se);if(ne===r.ATNStateType.LOOP_END){let _e=Z.toInt(R[b++]);re.push([le,_e])}else if(le instanceof u.BlockStartState){let _e=Z.toInt(R[b++]);he.push([le,_e])}k.addState(le)}for(let q of re)q[0].loopBackState=k.states[q[1]];for(let q of he)q[0].endState=k.states[q[1]];let fe=Z.toInt(R[b++]);for(let q=0;q<fe;q++){let ne=Z.toInt(R[b++]);k.states[ne].nonGreedy=!0}let Ue=Z.toInt(R[b++]);for(let q=0;q<Ue;q++){let ne=Z.toInt(R[b++]);k.states[ne].sll=!0}let je=Z.toInt(R[b++]);for(let q=0;q<je;q++){let ne=Z.toInt(R[b++]);k.states[ne].isPrecedenceRule=!0}let Qn=Z.toInt(R[b++]);k.grammarType===0&&(k.ruleToTokenType=new Int32Array(Qn)),k.ruleToStartState=new Array(Qn);for(let q=0;q<Qn;q++){let ne=Z.toInt(R[b++]),se=k.states[ne];if(se.leftFactored=Z.toInt(R[b++])!==0,k.ruleToStartState[q]=se,k.grammarType===0){let le=Z.toInt(R[b++]);le===65535&&(le=L.Token.EOF),k.ruleToTokenType[q]=le,Z.isFeatureSupported(Z.ADDED_LEXER_ACTIONS,U)||Z.toInt(R[b++])}}k.ruleToStopState=new Array(Qn);for(let q of k.states)q instanceof Ne.RuleStopState&&(k.ruleToStopState[q.ruleIndex]=q,k.ruleToStartState[q.ruleIndex].stopState=q);let di=Z.toInt(R[b++]);for(let q=0;q<di;q++){let ne=Z.toInt(R[b++]);k.modeToStartState.push(k.states[ne])}k.modeToDFA=new Array(di);for(let q=0;q<di;q++)k.modeToDFA[q]=new f.DFA(k.modeToStartState[q]);let xi=[];b=this.deserializeSets(R,b,xi,Z.getUnicodeDeserializer(0)),Z.isFeatureSupported(Z.ADDED_UNICODE_SMP,U)&&(b=this.deserializeSets(R,b,xi,Z.getUnicodeDeserializer(1)));let Sa=Z.toInt(R[b++]);for(let q=0;q<Sa;q++){let ne=Z.toInt(R[b]),se=Z.toInt(R[b+1]),le=Z.toInt(R[b+2]),_e=Z.toInt(R[b+3]),Wt=Z.toInt(R[b+4]),Ee=Z.toInt(R[b+5]),Re=this.edgeFactory(k,le,ne,se,_e,Wt,Ee,xi);k.states[ne].addTransition(Re),b+=6}let Ea=new x.Array2DHashSet({hashCode:q=>q.stopState^q.returnState^q.outermostPrecedenceReturn,equals:(q,ne)=>q.stopState===ne.stopState&&q.returnState===ne.returnState&&q.outermostPrecedenceReturn===ne.outermostPrecedenceReturn}),po=[];for(let q of k.states){let ne=q.ruleIndex>=0&&k.ruleToStartState[q.ruleIndex].leftFactored;for(let se=0;se<q.numberOfTransitions;se++){let le=q.transition(se);if(!(le instanceof te.RuleTransition))continue;let _e=le;if(!k.ruleToStartState[_e.target.ruleIndex].leftFactored&&ne)continue;let Ee=-1;k.ruleToStartState[_e.target.ruleIndex].isPrecedenceRule&&_e.precedence===0&&(Ee=_e.target.ruleIndex);let Re={stopState:_e.target.ruleIndex,returnState:_e.followState.stateNumber,outermostPrecedenceReturn:Ee};Ea.add(Re)&&po.push(Re)}}for(let q of po){let ne=new A.EpsilonTransition(k.states[q.returnState],q.outermostPrecedenceReturn);k.ruleToStopState[q.stopState].addTransition(ne)}for(let q of k.states){if(q instanceof u.BlockStartState){if(q.endState===void 0)throw new Error("IllegalStateException");if(q.endState.startState!==void 0)throw new Error("IllegalStateException");q.endState.startState=q}if(q instanceof J.PlusLoopbackState){let ne=q;for(let se=0;se<ne.numberOfTransitions;se++){let le=ne.transition(se).target;le instanceof ee.PlusBlockStartState&&(le.loopBackState=ne)}}else if(q instanceof C.StarLoopbackState){let ne=q;for(let se=0;se<ne.numberOfTransitions;se++){let le=ne.transition(se).target;le instanceof D.StarLoopEntryState&&(le.loopBackState=ne)}}}let _i=Z.toInt(R[b++]);for(let q=1;q<=_i;q++){let ne=Z.toInt(R[b++]),se=k.states[ne];k.decisionToState.push(se),se.decision=q-1}if(k.grammarType===0)if(H){k.lexerActions=new Array(Z.toInt(R[b++]));for(let q=0;q<k.lexerActions.length;q++){let ne=Z.toInt(R[b++]),se=Z.toInt(R[b++]);se===65535&&(se=-1);let le=Z.toInt(R[b++]);le===65535&&(le=-1);let _e=this.lexerActionFactory(ne,se,le);k.lexerActions[q]=_e}}else{let q=[];for(let ne of k.states)for(let se=0;se<ne.numberOfTransitions;se++){let le=ne.transition(se);if(!(le instanceof p.ActionTransition))continue;let _e=le.ruleIndex,Wt=le.actionIndex,Ee=new S.LexerCustomAction(_e,Wt);ne.setTransition(se,new p.ActionTransition(le.target,_e,q.length,!1)),q.push(Ee)}k.lexerActions=q}this.markPrecedenceDecisions(k),k.decisionToDFA=new Array(_i);for(let q=0;q<_i;q++)k.decisionToDFA[q]=new f.DFA(k.decisionToState[q],q);if(this.deserializationOptions.isVerifyATN&&this.verifyATN(k),this.deserializationOptions.isGenerateRuleBypassTransitions&&k.grammarType===1){k.ruleToTokenType=new Int32Array(k.ruleToStartState.length);for(let q=0;q<k.ruleToStartState.length;q++)k.ruleToTokenType[q]=k.maxTokenType+q+1;for(let q=0;q<k.ruleToStartState.length;q++){let ne=new t.BasicBlockStartState;ne.ruleIndex=q,k.addState(ne);let se=new i.BlockEndState;se.ruleIndex=q,k.addState(se),ne.endState=se,k.defineDecisionState(ne),se.startState=ne;let le,_e;if(k.ruleToStartState[q].isPrecedenceRule){le=void 0;for(let Ee of k.states){if(Ee.ruleIndex!==q||!(Ee instanceof D.StarLoopEntryState))continue;let Re=Ee.transition(Ee.numberOfTransitions-1).target;if(Re instanceof F.LoopEndState&&Re.epsilonOnlyTransitions&&Re.transition(0).target instanceof Ne.RuleStopState){le=Ee;break}}if(!le)throw new Error("Couldn't identify final state of the precedence rule prefix section.");_e=le.loopBackState.transition(0)}else le=k.ruleToStopState[q];for(let Ee of k.states)for(let Re=0;Re<Ee.numberOfTransitions;Re++){let Zn=Ee.transition(Re);Zn!==_e&&Zn.target===le&&(Zn.target=se)}for(;k.ruleToStartState[q].numberOfTransitions>0;){let Ee=k.ruleToStartState[q].removeTransition(k.ruleToStartState[q].numberOfTransitions-1);ne.addTransition(Ee)}k.ruleToStartState[q].addTransition(new A.EpsilonTransition(ne)),se.addTransition(new A.EpsilonTransition(le));let Wt=new o.BasicState;k.addState(Wt),Wt.addTransition(new n.AtomTransition(se,k.ruleToTokenType[q])),ne.addTransition(new A.EpsilonTransition(Wt))}this.deserializationOptions.isVerifyATN&&this.verifyATN(k)}if(this.deserializationOptions.isOptimize){for(;;){let q=0;q+=Z.inlineSetRules(k),q+=Z.combineChainedEpsilons(k);let ne=k.grammarType===0;if(q+=Z.optimizeSets(k,ne),q===0)break}this.deserializationOptions.isVerifyATN&&this.verifyATN(k)}return Z.identifyTailCalls(k),k}deserializeSets(R,b,B,U){let H=Z.toInt(R[b++]);for(let X=0;X<H;X++){let $=Z.toInt(R[b]);b++;let k=new d.IntervalSet;B.push(k),Z.toInt(R[b++])!==0&&k.add(-1);for(let he=0;he<$;he++){let me=U.readUnicode(R,b);b+=U.size;let fe=U.readUnicode(R,b);b+=U.size,k.add(me,fe)}}return b}markPrecedenceDecisions(R){let b=new Map;for(let B of R.states)if(B instanceof D.StarLoopEntryState&&R.ruleToStartState[B.ruleIndex].isPrecedenceRule){let U=B.transition(B.numberOfTransitions-1).target;U instanceof F.LoopEndState&&U.epsilonOnlyTransitions&&U.transition(0).target instanceof Ne.RuleStopState&&(b.set(B.ruleIndex,B),B.precedenceRuleDecision=!0,B.precedenceLoopbackStates=new e.BitSet(R.states.length))}for(let B of b)for(let U of R.ruleToStopState[B[0]].getTransitions())U.serializationType!==1||U.outermostPrecedenceReturn!==-1||B[1].precedenceLoopbackStates.set(U.target.stateNumber)}verifyATN(R){for(let b of R.states)if(this.checkCondition(b!==void 0,"ATN states should not be undefined."),b.stateType!==r.ATNStateType.INVALID_TYPE){if(this.checkCondition(b.onlyHasEpsilonTransitions||b.numberOfTransitions<=1),b instanceof ee.PlusBlockStartState&&this.checkCondition(b.loopBackState!==void 0),b instanceof D.StarLoopEntryState){let B=b;if(this.checkCondition(B.loopBackState!==void 0),this.checkCondition(B.numberOfTransitions===2),B.transition(0).target instanceof v.StarBlockStartState)this.checkCondition(B.transition(1).target instanceof F.LoopEndState),this.checkCondition(!B.nonGreedy);else if(B.transition(0).target instanceof F.LoopEndState)this.checkCondition(B.transition(1).target instanceof v.StarBlockStartState),this.checkCondition(B.nonGreedy);else throw new Error("IllegalStateException")}if(b instanceof C.StarLoopbackState&&(this.checkCondition(b.numberOfTransitions===1),this.checkCondition(b.transition(0).target instanceof D.StarLoopEntryState)),b instanceof F.LoopEndState&&this.checkCondition(b.loopBackState!==void 0),b instanceof ke.RuleStartState&&this.checkCondition(b.stopState!==void 0),b instanceof u.BlockStartState&&this.checkCondition(b.endState!==void 0),b instanceof i.BlockEndState&&this.checkCondition(b.startState!==void 0),b instanceof c.DecisionState){let B=b;this.checkCondition(B.numberOfTransitions<=1||B.decision>=0)}else this.checkCondition(b.numberOfTransitions<=1||b instanceof Ne.RuleStopState)}}checkCondition(R,b){if(!R)throw new Error("IllegalStateException: "+b)}static inlineSetRules(R){let b=0,B=new Array(R.ruleToStartState.length);for(let U=0;U<R.ruleToStartState.length;U++){let X=R.ruleToStartState[U];for(;X.onlyHasEpsilonTransitions&&X.numberOfOptimizedTransitions===1&&X.getOptimizedTransition(0).serializationType===1;)X=X.getOptimizedTransition(0).target;if(X.numberOfOptimizedTransitions!==1)continue;let $=X.getOptimizedTransition(0),k=$.target;if(!($.isEpsilon||!k.onlyHasEpsilonTransitions||k.numberOfOptimizedTransitions!==1||!(k.getOptimizedTransition(0).target instanceof Ne.RuleStopState)))switch($.serializationType){case 5:case 2:case 7:B[U]=$;break;case 8:case 9:continue;default:continue}}for(let U of R.states){if(U.ruleIndex<0)continue;let H;for(let X=0;X<U.numberOfOptimizedTransitions;X++){let $=U.getOptimizedTransition(X);if(!($ instanceof te.RuleTransition)){H!==void 0&&H.push($);continue}let k=$,re=B[k.target.ruleIndex];if(re===void 0){H!==void 0&&H.push($);continue}if(H===void 0){H=[];for(let fe=0;fe<X;fe++)H.push(U.getOptimizedTransition(X))}b++;let he=k.followState,me=new o.BasicState;switch(me.setRuleIndex(he.ruleIndex),R.addState(me),H.push(new A.EpsilonTransition(me)),re.serializationType){case 5:me.addTransition(new n.AtomTransition(he,re._label));break;case 2:me.addTransition(new ue.RangeTransition(he,re.from,re.to));break;case 7:me.addTransition(new ve.SetTransition(he,re.label));break;default:throw new Error("UnsupportedOperationException")}}if(H!==void 0){if(U.isOptimized)for(;U.numberOfOptimizedTransitions>0;)U.removeOptimizedTransition(U.numberOfOptimizedTransitions-1);for(let X of H)U.addOptimizedTransition(X)}}return W.ParserATNSimulator.debug&&console.log("ATN runtime optimizer removed "+b+" rule invocations by inlining sets."),b}static combineChainedEpsilons(R){let b=0;for(let B of R.states){if(!B.onlyHasEpsilonTransitions||B instanceof Ne.RuleStopState)continue;let U;e:for(let H=0;H<B.numberOfOptimizedTransitions;H++){let X=B.getOptimizedTransition(H),$=X.target;if(X.serializationType!==1||X.outermostPrecedenceReturn!==-1||$.stateType!==r.ATNStateType.BASIC||!$.onlyHasEpsilonTransitions){U!==void 0&&U.push(X);continue e}for(let k=0;k<$.numberOfOptimizedTransitions;k++)if($.getOptimizedTransition(k).serializationType!==1||$.getOptimizedTransition(k).outermostPrecedenceReturn!==-1){U!==void 0&&U.push(X);continue e}if(b++,U===void 0){U=[];for(let k=0;k<H;k++)U.push(B.getOptimizedTransition(k))}for(let k=0;k<$.numberOfOptimizedTransitions;k++){let re=$.getOptimizedTransition(k).target;U.push(new A.EpsilonTransition(re))}}if(U!==void 0){if(B.isOptimized)for(;B.numberOfOptimizedTransitions>0;)B.removeOptimizedTransition(B.numberOfOptimizedTransitions-1);for(let H of U)B.addOptimizedTransition(H)}}return W.ParserATNSimulator.debug&&console.log("ATN runtime optimizer removed "+b+" transitions by combining chained epsilon transitions."),b}static optimizeSets(R,b){if(b)return 0;let B=0,U=R.decisionToState;for(let H of U){let X=new d.IntervalSet;for(let fe=0;fe<H.numberOfOptimizedTransitions;fe++){let Ue=H.getOptimizedTransition(fe);if(!(Ue instanceof A.EpsilonTransition)||Ue.target.numberOfOptimizedTransitions!==1)continue;let je=Ue.target.getOptimizedTransition(0);je.target instanceof i.BlockEndState&&(je instanceof M.NotSetTransition||(je instanceof n.AtomTransition||je instanceof ue.RangeTransition||je instanceof ve.SetTransition)&&X.add(fe))}if(X.size<=1)continue;let $=[];for(let fe=0;fe<H.numberOfOptimizedTransitions;fe++)X.contains(fe)||$.push(H.getOptimizedTransition(fe));let k=H.getOptimizedTransition(X.minElement).target.getOptimizedTransition(0).target,re=new d.IntervalSet;for(let fe of X.intervals)for(let Ue=fe.a;Ue<=fe.b;Ue++){let je=H.getOptimizedTransition(Ue).target.getOptimizedTransition(0);if(je instanceof M.NotSetTransition)throw new Error("Not yet implemented.");re.addAll(je.label)}let he;if(re.intervals.length===1)if(re.size===1)he=new n.AtomTransition(k,re.minElement);else{let fe=re.intervals[0];he=new ue.RangeTransition(k,fe.a,fe.b)}else he=new ve.SetTransition(k,re);let me=new o.BasicState;if(me.setRuleIndex(H.ruleIndex),R.addState(me),me.addTransition(he),$.push(new A.EpsilonTransition(me)),B+=H.numberOfOptimizedTransitions-$.length,H.isOptimized)for(;H.numberOfOptimizedTransitions>0;)H.removeOptimizedTransition(H.numberOfOptimizedTransitions-1);for(let fe of $)H.addOptimizedTransition(fe)}return W.ParserATNSimulator.debug&&console.log("ATN runtime optimizer removed "+B+" paths by collapsing sets."),B}static identifyTailCalls(R){for(let b of R.states){for(let B=0;B<b.numberOfTransitions;B++){let U=b.transition(B);U instanceof te.RuleTransition&&(U.tailCall=this.testTailCall(R,U,!1),U.optimizedTailCall=this.testTailCall(R,U,!0))}if(b.isOptimized)for(let B=0;B<b.numberOfOptimizedTransitions;B++){let U=b.getOptimizedTransition(B);U instanceof te.RuleTransition&&(U.tailCall=this.testTailCall(R,U,!1),U.optimizedTailCall=this.testTailCall(R,U,!0))}}}static testTailCall(R,b,B){if(!B&&b.tailCall||B&&b.optimizedTailCall)return!0;let U=new e.BitSet(R.states.length),H=[];for(H.push(b.followState);;){let X=H.pop();if(!X)break;if(U.get(X.stateNumber)||X instanceof Ne.RuleStopState)continue;if(!X.onlyHasEpsilonTransitions)return!1;let $=B?X.numberOfOptimizedTransitions:X.numberOfTransitions;for(let k=0;k<$;k++){let re=B?X.getOptimizedTransition(k):X.transition(k);if(re.serializationType!==1)return!1;H.push(re.target)}}return!0}static toInt(R){return R}static toInt32(R,b){return(R[b]|R[b+1]<<16)>>>0}static toUUID(R,b){let B=Z.toInt32(R,b),U=Z.toInt32(R,b+2),H=Z.toInt32(R,b+4),X=Z.toInt32(R,b+6);return new P.UUID(X,H,U,B)}edgeFactory(R,b,B,U,H,X,$,k){let re=R.states[U];switch(b){case 1:return new A.EpsilonTransition(re);case 2:return $!==0?new ue.RangeTransition(re,L.Token.EOF,X):new ue.RangeTransition(re,H,X);case 3:return new te.RuleTransition(R.states[H],X,$,re);case 4:return new Se.PredicateTransition(re,H,X,$!==0);case 10:return new ae.PrecedencePredicateTransition(re,H);case 5:return $!==0?new n.AtomTransition(re,L.Token.EOF):new n.AtomTransition(re,H);case 6:return new p.ActionTransition(re,H,X,$!==0);case 7:return new ve.SetTransition(re,k[H]);case 8:return new M.NotSetTransition(re,k[H]);case 9:return new j.WildcardTransition(re)}throw new Error("The specified transition type is not valid.")}stateFactory(R,b){let B;switch(R){case r.ATNStateType.INVALID_TYPE:return new _.InvalidState;case r.ATNStateType.BASIC:B=new o.BasicState;break;case r.ATNStateType.RULE_START:B=new ke.RuleStartState;break;case r.ATNStateType.BLOCK_START:B=new t.BasicBlockStartState;break;case r.ATNStateType.PLUS_BLOCK_START:B=new ee.PlusBlockStartState;break;case r.ATNStateType.STAR_BLOCK_START:B=new v.StarBlockStartState;break;case r.ATNStateType.TOKEN_START:B=new I.TokensStartState;break;case r.ATNStateType.RULE_STOP:B=new Ne.RuleStopState;break;case r.ATNStateType.BLOCK_END:B=new i.BlockEndState;break;case r.ATNStateType.STAR_LOOP_BACK:B=new C.StarLoopbackState;break;case r.ATNStateType.STAR_LOOP_ENTRY:B=new D.StarLoopEntryState;break;case r.ATNStateType.PLUS_LOOP_BACK:B=new J.PlusLoopbackState;break;case r.ATNStateType.LOOP_END:B=new F.LoopEndState;break;default:let U=`The specified state type ${R} is not valid.`;throw new Error(U)}return B.ruleIndex=b,B}lexerActionFactory(R,b,B){switch(R){case 0:return new m.LexerChannelAction(b);case 1:return new S.LexerCustomAction(b,B);case 2:return new E.LexerModeAction(b);case 3:return g.LexerMoreAction.INSTANCE;case 4:return T.LexerPopModeAction.INSTANCE;case 5:return new N.LexerPushModeAction(b);case 6:return y.LexerSkipAction.INSTANCE;case 7:return new O.LexerTypeAction(b);default:let U=`The specified lexer action type ${R} is not valid.`;throw new Error(U)}}};return G.BASE_SERIALIZED_UUID=P.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3"),G.ADDED_LEXER_ACTIONS=P.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D"),G.ADDED_UNICODE_SMP=P.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B"),G.SUPPORTED_UUIDS=[G.BASE_SERIALIZED_UUID,G.ADDED_LEXER_ACTIONS,G.ADDED_UNICODE_SMP],G.SERIALIZED_UUID=G.ADDED_UNICODE_SMP,l([w.NotNull],G.prototype,"deserializationOptions",void 0),l([a(0,w.NotNull)],G.prototype,"deserialize",null),l([a(0,w.NotNull)],G.prototype,"markPrecedenceDecisions",null),l([w.NotNull,a(0,w.NotNull)],G.prototype,"edgeFactory",null),ct.ATNDeserializer=G,ct}var Nt={},ou;function ic(){if(ou)return Nt;ou=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Nt&&Nt.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o},a=Nt&&Nt.__param||function(h,s){return function(r,n){s(r,n,h)}};Object.defineProperty(Nt,"__esModule",{value:!0}),Nt.ParseInfo=void 0;const p=z();let x=class{constructor(s){this.atnSimulator=s}getDecisionInfo(){return this.atnSimulator.getDecisionInfo()}getLLDecisions(){let s=this.atnSimulator.getDecisionInfo(),r=[];for(let n=0;n<s.length;n++)s[n].LL_Fallback>0&&r.push(n);return r}getTotalTimeInPrediction(){let s=this.atnSimulator.getDecisionInfo(),r=0;for(let n of s)r+=n.timeInPrediction;return r}getTotalSLLLookaheadOps(){let s=this.atnSimulator.getDecisionInfo(),r=0;for(let n of s)r+=n.SLL_TotalLook;return r}getTotalLLLookaheadOps(){let s=this.atnSimulator.getDecisionInfo(),r=0;for(let n of s)r+=n.LL_TotalLook;return r}getTotalSLLATNLookaheadOps(){let s=this.atnSimulator.getDecisionInfo(),r=0;for(let n of s)r+=n.SLL_ATNTransitions;return r}getTotalLLATNLookaheadOps(){let s=this.atnSimulator.getDecisionInfo(),r=0;for(let n of s)r+=n.LL_ATNTransitions;return r}getTotalATNLookaheadOps(){let s=this.atnSimulator.getDecisionInfo(),r=0;for(let n of s)r+=n.SLL_ATNTransitions,r+=n.LL_ATNTransitions;return r}getDFASize(s){if(s)return this.atnSimulator.atn.decisionToDFA[s].states.size;{let r=0,n=this.atnSimulator.atn.decisionToDFA;for(let t=0;t<n.length;t++)r+=this.getDFASize(t);return r}}};return l([p.NotNull],x.prototype,"getDecisionInfo",null),l([p.NotNull],x.prototype,"getLLDecisions",null),x=l([a(0,p.NotNull)],x),Nt.ParseInfo=x,Nt}var Vr={},su;function na(){if(su)return Vr;su=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Vr&&Vr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(Vr,"__esModule",{value:!0}),Vr.ProxyParserErrorListener=void 0;const a=eo(),p=z();let x=class extends a.ProxyErrorListener{constructor(s){super(s)}reportAmbiguity(s,r,n,t,o,e,i){this.getDelegates().forEach(u=>{u.reportAmbiguity&&u.reportAmbiguity(s,r,n,t,o,e,i)})}reportAttemptingFullContext(s,r,n,t,o,e){this.getDelegates().forEach(i=>{i.reportAttemptingFullContext&&i.reportAttemptingFullContext(s,r,n,t,o,e)})}reportContextSensitivity(s,r,n,t,o,e){this.getDelegates().forEach(i=>{i.reportContextSensitivity&&i.reportContextSensitivity(s,r,n,t,o,e)})}};return l([p.Override],x.prototype,"reportAmbiguity",null),l([p.Override],x.prototype,"reportAttemptingFullContext",null),l([p.Override],x.prototype,"reportContextSensitivity",null),Vr.ProxyParserErrorListener=x,Vr}var Yr={},vi={},Ci={},vt={},uu;function oc(){if(uu)return vt;uu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(vt,"__esModule",{value:!0}),vt.isSupplementaryCodePoint=vt.isLowSurrogate=vt.isHighSurrogate=void 0;function l(x){return x>=55296&&x<=56319}vt.isHighSurrogate=l;function a(x){return x>=56320&&x<=57343}vt.isLowSurrogate=a;function p(x){return x>=65536}return vt.isSupplementaryCodePoint=p,vt}var lu;function ia(){return lu||(lu=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.CodePointBuffer=void 0;const a=be(),p=oc();class x{constructor(s,r){this.buffer=s,this._position=0,this._size=r}static withArray(s){return new x(s,s.length)}get position(){return this._position}set position(s){if(s<0||s>this._size)throw new RangeError;this._position=s}get remaining(){return this._size-this.position}get(s){return this.buffer[s]}array(){return this.buffer.slice(0,this._size)}static builder(s){return new x.Builder(s)}}l.CodePointBuffer=x,function(h){let s;(function(n){n[n.BYTE=0]="BYTE",n[n.CHAR=1]="CHAR",n[n.INT=2]="INT"})(s||(s={}));class r{constructor(t){this.type=0,this.buffer=new Uint8Array(t),this.prevHighSurrogate=-1,this.position=0}build(){return new h(this.buffer,this.position)}static roundUpToNextPowerOfTwo(t){let o=32-Math.clz32(t-1);return Math.pow(2,o)}ensureRemaining(t){switch(this.type){case 0:if(this.buffer.length-this.position<t){let o=r.roundUpToNextPowerOfTwo(this.buffer.length+t),e=new Uint8Array(o);e.set(this.buffer.subarray(0,this.position),0),this.buffer=e}break;case 1:if(this.buffer.length-this.position<t){let o=r.roundUpToNextPowerOfTwo(this.buffer.length+t),e=new Uint16Array(o);e.set(this.buffer.subarray(0,this.position),0),this.buffer=e}break;case 2:if(this.buffer.length-this.position<t){let o=r.roundUpToNextPowerOfTwo(this.buffer.length+t),e=new Int32Array(o);e.set(this.buffer.subarray(0,this.position),0),this.buffer=e}break}}append(t){this.ensureRemaining(t.length),this.appendArray(t)}appendArray(t){switch(this.type){case 0:this.appendArrayByte(t);break;case 1:this.appendArrayChar(t);break;case 2:this.appendArrayInt(t);break}}appendArrayByte(t){a(this.prevHighSurrogate===-1);let o=t,e=0,i=t.length,u=this.buffer,c=this.position;for(;e<i;){let f=o[e];if(f<=255)u[c]=f;else if(t=t.subarray(e,i),this.position=c,p.isHighSurrogate(f)){this.byteToIntBuffer(t.length),this.appendArrayInt(t);return}else{this.byteToCharBuffer(t.length),this.appendArrayChar(t);return}e++,c++}this.position=c}appendArrayChar(t){a(this.prevHighSurrogate===-1);let o=t,e=0,i=t.length,u=this.buffer,c=this.position;for(;e<i;){let f=o[e];if(!p.isHighSurrogate(f))u[c]=f;else{t=t.subarray(e,i),this.position=c,this.charToIntBuffer(t.length),this.appendArrayInt(t);return}e++,c++}this.position=c}appendArrayInt(t){let o=t,e=0,i=t.length,u=this.buffer,c=this.position;for(;e<i;){let f=o[e];e++,this.prevHighSurrogate!==-1?p.isLowSurrogate(f)?(u[c]=String.fromCharCode(this.prevHighSurrogate,f).codePointAt(0),c++,this.prevHighSurrogate=-1):(u[c]=this.prevHighSurrogate,c++,p.isHighSurrogate(f)?this.prevHighSurrogate=f:(u[c]=f,c++,this.prevHighSurrogate=-1)):p.isHighSurrogate(f)?this.prevHighSurrogate=f:(u[c]=f,c++)}this.prevHighSurrogate!==-1&&(u[c]=this.prevHighSurrogate,c++),this.position=c}byteToCharBuffer(t){let o=new Uint16Array(Math.max(this.position+t,this.buffer.length>>1));o.set(this.buffer.subarray(0,this.position),0),this.type=1,this.buffer=o}byteToIntBuffer(t){let o=new Int32Array(Math.max(this.position+t,this.buffer.length>>2));o.set(this.buffer.subarray(0,this.position),0),this.type=2,this.buffer=o}charToIntBuffer(t){let o=new Int32Array(Math.max(this.position+t,this.buffer.length>>1));o.set(this.buffer.subarray(0,this.position),0),this.type=2,this.buffer=o}}h.Builder=r}(x=l.CodePointBuffer||(l.CodePointBuffer={}))}(Ci)),Ci}var Xr={},au;function sa(){if(au)return Xr;au=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Xr&&Xr.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(Xr,"__esModule",{value:!0}),Xr.CodePointCharStream=void 0;const a=be(),p=$t(),x=ye(),h=z();let s=class oa{constructor(n,t,o,e){a(t===0),this._array=n,this._size=o,this._name=e,this._position=0}get internalStorage(){return this._array}static fromBuffer(n,t){return(t===void 0||t.length===0)&&(t=p.IntStream.UNKNOWN_SOURCE_NAME),new oa(n.array(),n.position,n.remaining,t)}consume(){if(this._size-this._position===0)throw a(this.LA(1)===p.IntStream.EOF),new RangeError("cannot consume EOF");this._position++}get index(){return this._position}get size(){return this._size}mark(){return-1}release(n){}seek(n){this._position=n}get sourceName(){return this._name}toString(){return this.getText(x.Interval.of(0,this.size-1))}LA(n){let t;switch(Math.sign(n)){case-1:return t=this.index+n,t<0?p.IntStream.EOF:this._array[t];case 0:return 0;case 1:return t=this.index+n-1,t>=this.size?p.IntStream.EOF:this._array[t]}throw new RangeError("Not reached")}getText(n){const t=Math.min(n.a,this.size),o=Math.min(n.b-n.a+1,this.size-t);return this._array instanceof Int32Array?String.fromCodePoint(...Array.from(this._array.subarray(t,t+o))):String.fromCharCode(...Array.from(this._array.subarray(t,t+o)))}};return l([h.Override],s.prototype,"consume",null),l([h.Override],s.prototype,"index",null),l([h.Override],s.prototype,"size",null),l([h.Override],s.prototype,"mark",null),l([h.Override],s.prototype,"release",null),l([h.Override],s.prototype,"seek",null),l([h.Override],s.prototype,"sourceName",null),l([h.Override],s.prototype,"toString",null),l([h.Override],s.prototype,"LA",null),l([h.Override],s.prototype,"getText",null),Xr.CodePointCharStream=s,Xr}var cu;function lo(){return cu||(cu=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.CharStreams=void 0;const a=ia(),p=sa(),x=$t();(function(h){function s(r,n){(n===void 0||n.length===0)&&(n=x.IntStream.UNKNOWN_SOURCE_NAME);let t=a.CodePointBuffer.builder(r.length),o=new Uint16Array(r.length);for(let e=0;e<r.length;e++)o[e]=r.charCodeAt(e);return t.append(o),p.CodePointCharStream.fromBuffer(t.build(),n)}h.fromString=s})(l.CharStreams||(l.CharStreams={}))}(vi)),vi}var Ct={},Ot={},hu;function ua(){if(hu)return Ot;hu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ot&&Ot.__decorate||function(o,e,i,u){var c=arguments.length,f=c<3?e:u===null?u=Object.getOwnPropertyDescriptor(e,i):u,A;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")f=Reflect.decorate(o,e,i,u);else for(var d=o.length-1;d>=0;d--)(A=o[d])&&(f=(c<3?A(f):c>3?A(e,i,f):A(e,i))||f);return c>3&&f&&Object.defineProperty(e,i,f),f},a=Ot&&Ot.__param||function(o,e){return function(i,u){e(i,u,o)}};Object.defineProperty(Ot,"__esModule",{value:!0}),Ot.BufferedTokenStream=void 0;const p=be(),x=Vn(),h=ye(),s=tr(),r=z(),n=pe();let t=class{constructor(e){if(this.tokens=[],this.p=-1,this.fetchedEOF=!1,e==null)throw new Error("tokenSource cannot be null");this._tokenSource=e}get tokenSource(){return this._tokenSource}set tokenSource(e){this._tokenSource=e,this.tokens.length=0,this.p=-1,this.fetchedEOF=!1}get index(){return this.p}mark(){return 0}release(e){}seek(e){this.lazyInit(),this.p=this.adjustSeekIndex(e)}get size(){return this.tokens.length}consume(){let e;if(this.p>=0?this.fetchedEOF?e=this.p<this.tokens.length-1:e=this.p<this.tokens.length:e=!1,!e&&this.LA(1)===n.Token.EOF)throw new Error("cannot consume EOF");this.sync(this.p+1)&&(this.p=this.adjustSeekIndex(this.p+1))}sync(e){p(e>=0);let i=e-this.tokens.length+1;return i>0?this.fetch(i)>=i:!0}fetch(e){if(this.fetchedEOF)return 0;for(let i=0;i<e;i++){let u=this.tokenSource.nextToken();if(this.isWritableToken(u)&&(u.tokenIndex=this.tokens.length),this.tokens.push(u),u.type===n.Token.EOF)return this.fetchedEOF=!0,i+1}return e}get(e){if(e<0||e>=this.tokens.length)throw new RangeError("token index "+e+" out of range 0.."+(this.tokens.length-1));return this.tokens[e]}getRange(e,i){if(e<0||i<0)return[];this.lazyInit();let u=new Array;i>=this.tokens.length&&(i=this.tokens.length-1);for(let c=e;c<=i;c++){let f=this.tokens[c];if(f.type===n.Token.EOF)break;u.push(f)}return u}LA(e){let i=this.LT(e);return i?i.type:n.Token.INVALID_TYPE}tryLB(e){if(!(this.p-e<0))return this.tokens[this.p-e]}LT(e){let i=this.tryLT(e);if(i===void 0)throw new RangeError("requested lookback index out of range");return i}tryLT(e){if(this.lazyInit(),e===0)throw new RangeError("0 is not a valid lookahead index");if(e<0)return this.tryLB(-e);let i=this.p+e-1;return this.sync(i),i>=this.tokens.length?this.tokens[this.tokens.length-1]:this.tokens[i]}adjustSeekIndex(e){return e}lazyInit(){this.p===-1&&this.setup()}setup(){this.sync(0),this.p=this.adjustSeekIndex(0)}getTokens(e,i,u){if(this.lazyInit(),e===void 0)return p(i===void 0&&u===void 0),this.tokens;if(i===void 0&&(i=this.tokens.length-1),e<0||i>=this.tokens.length||i<0||e>=this.tokens.length)throw new RangeError("start "+e+" or stop "+i+" not in 0.."+(this.tokens.length-1));if(e>i)return[];if(u===void 0)return this.tokens.slice(e,i+1);typeof u=="number"&&(u=new Set().add(u));let c=u,f=this.tokens.slice(e,i+1);return f=f.filter(A=>c.has(A.type)),f}nextTokenOnChannel(e,i){if(this.sync(e),e>=this.size)return this.size-1;let u=this.tokens[e];for(;u.channel!==i;){if(u.type===n.Token.EOF)return e;e++,this.sync(e),u=this.tokens[e]}return e}previousTokenOnChannel(e,i){if(this.sync(e),e>=this.size)return this.size-1;for(;e>=0;){let u=this.tokens[e];if(u.type===n.Token.EOF||u.channel===i)return e;e--}return e}getHiddenTokensToRight(e,i=-1){if(this.lazyInit(),e<0||e>=this.tokens.length)throw new RangeError(e+" not in 0.."+(this.tokens.length-1));let u=this.nextTokenOnChannel(e+1,s.Lexer.DEFAULT_TOKEN_CHANNEL),c,f=e+1;return u===-1?c=this.size-1:c=u,this.filterForChannel(f,c,i)}getHiddenTokensToLeft(e,i=-1){if(this.lazyInit(),e<0||e>=this.tokens.length)throw new RangeError(e+" not in 0.."+(this.tokens.length-1));if(e===0)return[];let u=this.previousTokenOnChannel(e-1,s.Lexer.DEFAULT_TOKEN_CHANNEL);if(u===e-1)return[];let c=u+1,f=e-1;return this.filterForChannel(c,f,i)}filterForChannel(e,i,u){let c=new Array;for(let f=e;f<=i;f++){let A=this.tokens[f];u===-1?A.channel!==s.Lexer.DEFAULT_TOKEN_CHANNEL&&c.push(A):A.channel===u&&c.push(A)}return c}get sourceName(){return this.tokenSource.sourceName}getText(e){e===void 0?e=h.Interval.of(0,this.size-1):e instanceof h.Interval||(e=e.sourceInterval);let i=e.a,u=e.b;if(i<0||u<0)return"";this.fill(),u>=this.tokens.length&&(u=this.tokens.length-1);let c="";for(let f=i;f<=u;f++){let A=this.tokens[f];if(A.type===n.Token.EOF)break;c+=A.text}return c.toString()}getTextFromRange(e,i){return this.isToken(e)&&this.isToken(i)?this.getText(h.Interval.of(e.tokenIndex,i.tokenIndex)):""}fill(){this.lazyInit();const e=1e3;for(;;)if(this.fetch(e)<e)return}isWritableToken(e){return e instanceof x.CommonToken}isToken(e){return e instanceof x.CommonToken}};return l([r.NotNull],t.prototype,"_tokenSource",void 0),l([r.Override],t.prototype,"tokenSource",null),l([r.Override],t.prototype,"index",null),l([r.Override],t.prototype,"mark",null),l([r.Override],t.prototype,"release",null),l([r.Override],t.prototype,"seek",null),l([r.Override],t.prototype,"size",null),l([r.Override],t.prototype,"consume",null),l([r.Override],t.prototype,"get",null),l([r.Override],t.prototype,"LA",null),l([r.NotNull,r.Override],t.prototype,"LT",null),l([r.Override],t.prototype,"sourceName",null),l([r.NotNull,r.Override],t.prototype,"getText",null),l([r.NotNull,r.Override],t.prototype,"getTextFromRange",null),t=l([a(0,r.NotNull)],t),Ot.BufferedTokenStream=t,Ot}var fu;function ao(){if(fu)return Ct;fu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ct&&Ct.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=Ct&&Ct.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(Ct,"__esModule",{value:!0}),Ct.CommonTokenStream=void 0;const p=ua(),x=z(),h=pe();let s=class extends p.BufferedTokenStream{constructor(n,t=h.Token.DEFAULT_CHANNEL){super(n),this.channel=t}adjustSeekIndex(n){return this.nextTokenOnChannel(n,this.channel)}tryLB(n){if(this.p-n<0)return;let t=this.p,o=1;for(;o<=n&&t>0;)t=this.previousTokenOnChannel(t-1,this.channel),o++;if(!(t<0))return this.tokens[t]}tryLT(n){if(this.lazyInit(),n===0)throw new RangeError("0 is not a valid lookahead index");if(n<0)return this.tryLB(-n);let t=this.p,o=1;for(;o<n;)this.sync(t+1)&&(t=this.nextTokenOnChannel(t+1,this.channel)),o++;return this.tokens[t]}getNumberOfOnChannelTokens(){let n=0;this.fill();for(let t of this.tokens)if(t.channel===this.channel&&n++,t.type===h.Token.EOF)break;return n}};return l([x.Override],s.prototype,"adjustSeekIndex",null),l([x.Override],s.prototype,"tryLB",null),l([x.Override],s.prototype,"tryLT",null),s=l([a(0,x.NotNull)],s),Ct.CommonTokenStream=s,Ct}var Dt={},pu;function la(){if(pu)return Dt;pu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Dt&&Dt.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=Dt&&Dt.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(Dt,"__esModule",{value:!0}),Dt.ListTokenSource=void 0;const p=Gi(),x=z(),h=pe();let s=class{constructor(n,t){if(this.i=0,this._factory=p.CommonTokenFactory.DEFAULT,n==null)throw new Error("tokens cannot be null");this.tokens=n,this._sourceName=t}get charPositionInLine(){if(this.i<this.tokens.length)return this.tokens[this.i].charPositionInLine;if(this.eofToken!=null)return this.eofToken.charPositionInLine;if(this.tokens.length>0){let n=this.tokens[this.tokens.length-1],t=n.text;if(t!=null){let o=t.lastIndexOf(`
`);if(o>=0)return t.length-o-1}return n.charPositionInLine+n.stopIndex-n.startIndex+1}return 0}nextToken(){if(this.i>=this.tokens.length){if(this.eofToken==null){let t=-1;if(this.tokens.length>0){let e=this.tokens[this.tokens.length-1].stopIndex;e!==-1&&(t=e+1)}let o=Math.max(-1,t-1);this.eofToken=this._factory.create({source:this,stream:this.inputStream},h.Token.EOF,"EOF",h.Token.DEFAULT_CHANNEL,t,o,this.line,this.charPositionInLine)}return this.eofToken}let n=this.tokens[this.i];return this.i===this.tokens.length-1&&n.type===h.Token.EOF&&(this.eofToken=n),this.i++,n}get line(){if(this.i<this.tokens.length)return this.tokens[this.i].line;if(this.eofToken!=null)return this.eofToken.line;if(this.tokens.length>0){let n=this.tokens[this.tokens.length-1],t=n.line,o=n.text;if(o!=null)for(let e=0;e<o.length;e++)o.charAt(e)===`
`&&t++;return t}return 1}get inputStream(){if(this.i<this.tokens.length)return this.tokens[this.i].inputStream;if(this.eofToken!=null)return this.eofToken.inputStream;if(this.tokens.length>0)return this.tokens[this.tokens.length-1].inputStream}get sourceName(){if(this._sourceName)return this._sourceName;let n=this.inputStream;return n!=null?n.sourceName:"List"}set tokenFactory(n){this._factory=n}get tokenFactory(){return this._factory}};return l([x.Override],s.prototype,"charPositionInLine",null),l([x.Override],s.prototype,"nextToken",null),l([x.Override],s.prototype,"line",null),l([x.Override],s.prototype,"inputStream",null),l([x.Override],s.prototype,"sourceName",null),l([x.Override,x.NotNull,a(0,x.NotNull)],s.prototype,"tokenFactory",null),s=l([a(0,x.NotNull)],s),Dt.ListTokenSource=s,Dt}var Pn={},du;function sc(){if(du)return Pn;du=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Pn,"__esModule",{value:!0}),Pn.MultiMap=void 0;let l=class extends Map{constructor(){super()}map(p,x){let h=super.get(p);h||(h=[],super.set(p,h)),h.push(x)}getPairs(){let p=[];return this.forEach((x,h)=>{x.forEach(s=>{p.push([h,s])})}),p}};return Pn.MultiMap=l,Pn}var Ln={},xu;function aa(){if(xu)return Ln;xu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Ln,"__esModule",{value:!0}),Ln.ParseCancellationException=void 0;let l=class extends Error{constructor(p){super(p.message),this.cause=p,this.stack=p.stack}getCause(){return this.cause}};return Ln.ParseCancellationException=l,Ln}var bt={},Wr={},_u;function ca(){if(_u)return Wr;_u=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Wr&&Wr.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(Wr,"__esModule",{value:!0}),Wr.InterpreterRuleContext=void 0;const a=z(),p=Me();let x=class extends p.ParserRuleContext{constructor(s,r,n){n!==void 0?super(r,n):super(),this._ruleIndex=s}get ruleIndex(){return this._ruleIndex}};return l([a.Override],x.prototype,"ruleIndex",null),Wr.InterpreterRuleContext=x,Wr}var Au;function ha(){if(Au)return bt;Au=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=bt&&bt.__decorate||function(_,m,S,E){var g=arguments.length,T=g<3?m:E===null?E=Object.getOwnPropertyDescriptor(m,S):E,N;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")T=Reflect.decorate(_,m,S,E);else for(var y=_.length-1;y>=0;y--)(N=_[y])&&(T=(g<3?N(T):g>3?N(m,S,T):N(m,S))||T);return g>3&&T&&Object.defineProperty(m,S,T),T},a=bt&&bt.__param||function(_,m){return function(S,E){m(S,E,_)}};Object.defineProperty(bt,"__esModule",{value:!0}),bt.ParserInterpreter=void 0;const p=Yt(),x=Te(),h=er(),s=oi(),r=si(),n=ca(),t=Zl(),o=z(),e=z(),i=$n(),u=Kn(),c=Qt(),f=to(),A=pe();let d=class Vi extends i.Parser{constructor(m,S,E,g,T){if(super(m instanceof Vi?m.inputStream:T),this._parentContextStack=[],this.overrideDecision=-1,this.overrideDecisionInputIndex=-1,this.overrideDecisionAlt=-1,this.overrideDecisionReached=!1,this._overrideDecisionRoot=void 0,m instanceof Vi){let N=m;this._grammarFileName=N._grammarFileName,this._atn=N._atn,this.pushRecursionContextStates=N.pushRecursionContextStates,this._ruleNames=N._ruleNames,this._vocabulary=N._vocabulary,this.interpreter=new u.ParserATNSimulator(this._atn,this)}else{S=S,E=E,g=g,this._grammarFileName=m,this._atn=g,this._ruleNames=E.slice(0),this._vocabulary=S,this.pushRecursionContextStates=new h.BitSet(g.states.length);for(let N of g.states)N instanceof f.StarLoopEntryState&&N.precedenceRuleDecision&&this.pushRecursionContextStates.set(N.stateNumber);this.interpreter=new u.ParserATNSimulator(g,this)}}reset(m){m===void 0?super.reset():super.reset(m),this.overrideDecisionReached=!1,this._overrideDecisionRoot=void 0}get atn(){return this._atn}get vocabulary(){return this._vocabulary}get ruleNames(){return this._ruleNames}get grammarFileName(){return this._grammarFileName}parse(m){let S=this._atn.ruleToStartState[m];for(this._rootContext=this.createInterpreterRuleContext(void 0,p.ATNState.INVALID_STATE_NUMBER,m),S.isPrecedenceRule?this.enterRecursionRule(this._rootContext,S.stateNumber,m,0):this.enterRule(this._rootContext,S.stateNumber,m);;){let E=this.atnState;switch(E.stateType){case x.ATNStateType.RULE_STOP:if(this._ctx.isEmpty)if(S.isPrecedenceRule){let g=this._ctx,T=this._parentContextStack.pop();return this.unrollRecursionContexts(T[0]),g}else return this.exitRule(),this._rootContext;this.visitRuleStopState(E);break;default:try{this.visitState(E)}catch(g){if(g instanceof c.RecognitionException)this.state=this._atn.ruleToStopState[E.ruleIndex].stateNumber,this.context.exception=g,this.errorHandler.reportError(this,g),this.recover(g);else throw g}break}}}enterRecursionRule(m,S,E,g){this._parentContextStack.push([this._ctx,m.invokingState]),super.enterRecursionRule(m,S,E,g)}get atnState(){return this._atn.states[this.state]}visitState(m){let S=1;m.numberOfTransitions>1&&(S=this.visitDecisionState(m));let E=m.transition(S-1);switch(E.serializationType){case 1:if(this.pushRecursionContextStates.get(m.stateNumber)&&!(E.target instanceof t.LoopEndState)){let F=this._parentContextStack[this._parentContextStack.length-1],w=this.createInterpreterRuleContext(F[0],F[1],this._ctx.ruleIndex);this.pushNewRecursionContext(w,this._atn.ruleToStartState[m.ruleIndex].stateNumber,this._ctx.ruleIndex)}break;case 5:this.match(E._label);break;case 2:case 7:case 8:E.matches(this._input.LA(1),A.Token.MIN_USER_TOKEN_TYPE,65535)||this.recoverInline(),this.matchWildcard();break;case 9:this.matchWildcard();break;case 3:let g=E.target,T=g.ruleIndex,N=this.createInterpreterRuleContext(this._ctx,m.stateNumber,T);g.isPrecedenceRule?this.enterRecursionRule(N,g.stateNumber,T,E.precedence):this.enterRule(N,E.target.stateNumber,T);break;case 4:let y=E;if(!this.sempred(this._ctx,y.ruleIndex,y.predIndex))throw new s.FailedPredicateException(this);break;case 6:let O=E;this.action(this._ctx,O.ruleIndex,O.actionIndex);break;case 10:if(!this.precpred(this._ctx,E.precedence)){let F=E.precedence;throw new s.FailedPredicateException(this,`precpred(_ctx, ${F})`)}break;default:throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.")}this.state=E.target.stateNumber}visitDecisionState(m){let S;this.errorHandler.sync(this);let E=m.decision;return E===this.overrideDecision&&this._input.index===this.overrideDecisionInputIndex&&!this.overrideDecisionReached?(S=this.overrideDecisionAlt,this.overrideDecisionReached=!0):S=this.interpreter.adaptivePredict(this._input,E,this._ctx),S}createInterpreterRuleContext(m,S,E){return new n.InterpreterRuleContext(E,m,S)}visitRuleStopState(m){if(this._atn.ruleToStartState[m.ruleIndex].isPrecedenceRule){let g=this._parentContextStack.pop();this.unrollRecursionContexts(g[0]),this.state=g[1]}else this.exitRule();let E=this._atn.states[this.state].transition(0);this.state=E.followState.stateNumber}addDecisionOverride(m,S,E){this.overrideDecision=m,this.overrideDecisionInputIndex=S,this.overrideDecisionAlt=E}get overrideDecisionRoot(){return this._overrideDecisionRoot}recover(m){let S=this._input.index;if(this.errorHandler.recover(this,m),this._input.index===S){let E=m.getOffendingToken();if(!E)throw new Error("Expected exception to have an offending token");let g=E.tokenSource,T=g!==void 0?g.inputStream:void 0,N={source:g,stream:T};if(m instanceof r.InputMismatchException){let y=m.expectedTokens;if(y===void 0)throw new Error("Expected the exception to provide expected tokens");let O=A.Token.INVALID_TYPE;y.isNil||(O=y.minElement);let F=this.tokenFactory.create(N,O,E.text,A.Token.DEFAULT_CHANNEL,-1,-1,E.line,E.charPositionInLine);this._ctx.addErrorNode(this.createErrorNode(this._ctx,F))}else{E.tokenSource;let y=this.tokenFactory.create(N,A.Token.INVALID_TYPE,E.text,A.Token.DEFAULT_CHANNEL,-1,-1,E.line,E.charPositionInLine);this._ctx.addErrorNode(this.createErrorNode(this._ctx,y))}}}recoverInline(){return this._errHandler.recoverInline(this)}get rootContext(){return this._rootContext}};return l([o.NotNull],d.prototype,"_vocabulary",void 0),l([e.Override],d.prototype,"reset",null),l([e.Override],d.prototype,"atn",null),l([e.Override],d.prototype,"vocabulary",null),l([e.Override],d.prototype,"ruleNames",null),l([e.Override],d.prototype,"grammarFileName",null),l([e.Override],d.prototype,"enterRecursionRule",null),d=l([a(1,o.NotNull)],d),bt.ParserInterpreter=d,bt}var Rt={},mu;function uc(){if(mu)return Rt;mu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Rt&&Rt.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o},a=Rt&&Rt.__param||function(h,s){return function(r,n){s(r,n,h)}};Object.defineProperty(Rt,"__esModule",{value:!0}),Rt.ParseTreeMatch=void 0;const p=z();let x=class{constructor(s,r,n,t){if(!s)throw new Error("tree cannot be null");if(!r)throw new Error("pattern cannot be null");if(!n)throw new Error("labels cannot be null");this._tree=s,this._pattern=r,this._labels=n,this._mismatchedNode=t}get(s){let r=this._labels.get(s);if(!(!r||r.length===0))return r[r.length-1]}getAll(s){const r=this._labels.get(s);return r||[]}get labels(){return this._labels}get mismatchedNode(){return this._mismatchedNode}get succeeded(){return!this._mismatchedNode}get pattern(){return this._pattern}get tree(){return this._tree}toString(){return`Match ${this.succeeded?"succeeded":"failed"}; found ${this.labels.size} labels`}};return l([p.NotNull,a(0,p.NotNull)],x.prototype,"getAll",null),l([p.NotNull],x.prototype,"labels",null),l([p.NotNull],x.prototype,"pattern",null),l([p.NotNull],x.prototype,"tree",null),l([p.Override],x.prototype,"toString",null),x=l([a(0,p.NotNull),a(1,p.NotNull),a(2,p.NotNull)],x),Rt.ParseTreeMatch=x,Rt}var Pt={},Fn={},In={},Su;function lc(){if(Su)return In;Su=1,Object.defineProperty(In,"__esModule",{value:!0}),In.XPathLexer=void 0;const l=uo(),a=tr(),p=hi(),x=ln(),h=Xt();let s=class De extends a.Lexer{constructor(n){super(n),this._interp=new p.LexerATNSimulator(De._ATN,this)}get vocabulary(){return De.VOCABULARY}get grammarFileName(){return"XPathLexer.g4"}get ruleNames(){return De.ruleNames}get serializedATN(){return De._serializedATN}get channelNames(){return De.channelNames}get modeNames(){return De.modeNames}action(n,t,o){switch(t){case 4:this.ID_action(n,o);break}}ID_action(n,t){switch(t){case 0:let o=this.text;o.charAt(0)===o.charAt(0).toUpperCase()?this.type=De.TOKEN_REF:this.type=De.RULE_REF;break}}static get _ATN(){return De.__ATN||(De.__ATN=new l.ATNDeserializer().deserialize(h.toCharArray(De._serializedATN))),De.__ATN}};return In.XPathLexer=s,s.TOKEN_REF=1,s.RULE_REF=2,s.ANYWHERE=3,s.ROOT=4,s.WILDCARD=5,s.BANG=6,s.ID=7,s.STRING=8,s.channelNames=["DEFAULT_TOKEN_CHANNEL","HIDDEN"],s.modeNames=["DEFAULT_MODE"],s.ruleNames=["ANYWHERE","ROOT","WILDCARD","BANG","ID","NameChar","NameStartChar","STRING"],s._LITERAL_NAMES=[void 0,void 0,void 0,"'//'","'/'","'*'","'!'"],s._SYMBOLIC_NAMES=[void 0,"TOKEN_REF","RULE_REF","ANYWHERE","ROOT","WILDCARD","BANG","ID","STRING"],s.VOCABULARY=new x.VocabularyImpl(s._LITERAL_NAMES,s._SYMBOLIC_NAMES,[]),s._serializedATNSegments=2,s._serializedATNSegment0=`ì¤ìªºÖê¾ºä½Øîªì
2\b					\x07	\x07\b	\b			\x07
\f"\v\x07\x07\b\b		\x07	,
	\f		/\v			-
\x07\x07	\b\v	\r
Ê¶
2;C\\aac|ÂÂ¡Â¬Â¬Â¯Â¯Â·Â·Â¼Â¼ÃÃÃÃ¸ÃºËËËË¢Ë¦Ë®Ë®Ë°Ë°ÌÍ¶Í¸Í¹Í¼Í¿ÎÎÎÎÎÎÎÎÎÎ£Î¥Ï·Ï¹ÒÒÒÒÔ±Ô³ÕÕÕÕ£ÖÖÖ¿××××××××××¬×²×´ØØØØØØØ¢Ù«Ù°ÛÛÛÛ¡ÛªÛ¬Û¾ÜÜÜÝÝÞ³ßß·ß¼ß¼à à ¯à¡à¡à¢¢à¢¶à¢¸à¢¿à£à¥¥à¥¨à¥±à¥³à¦à¦à¦à¦à¦à¦à¦ªà¦¬à¦²à¦´à¦´à¦¸à¦»à¦¾à§à§à§à§à§à§à§à§à§à§¡à§¥à§¨à§³à¨à¨à¨à¨à¨à¨à¨à¨ªà¨¬à¨²à¨´à¨µà¨·à¨¸à¨ºà¨»à¨¾à¨¾à©à©à©à©à©à©à©à©à©à©à© à© à©¨à©·àªàªàªàªàªàªàªàªªàª¬àª²àª´àªµàª·àª»àª¾à«à«à«à«à«à«à«à«¢à«¥à«¨à«±à«»à«»à¬à¬à¬à¬à¬à¬à¬à¬ªà¬¬à¬²à¬´à¬µà¬·à¬»à¬¾à­à­à­à­à­à­à­à­à­à­¡à­¥à­¨à­±à­³à­³à®à®à®à®à®à®à®à®à®à®à®à®à® à®¡à®¥à®¦à®ªà®¬à®°à®»à¯à¯à¯à¯à¯à¯à¯à¯à¯à¯à¯¨à¯±à°à°à°à°à°à°à°à°ªà°¬à°»à°¿à±à±à±à±à±à±à±à±à±à±¢à±¥à±¨à±±à²à²à²à²à²à²à²à²ªà²¬à²µà²·à²»à²¾à³à³à³à³à³à³à³à³ à³ à³¢à³¥à³¨à³±à³³à³´à´à´à´à´à´à´à´à´¼à´¿àµàµàµàµàµàµàµàµ¡àµ¥àµ¨àµ±àµ¼à¶à¶à¶à¶à¶à¶à¶³à¶µà¶½à¶¿à¶¿à·à·à·à·à·à·à·à·à·à·¡à·¨à·±à·´à·µà¸à¸¼à¹à¹à¹à¹àºàºàºàºàºàºàºàºàºàºàºàºàºàº¡àº£àº¥àº§àº§àº©àº©àº¬àº­àº¯àº»àº½àº¿à»à»à»à»à»à»à»à»à»à»¡à¼à¼à¼à¼à¼¢à¼«à¼·à¼·à¼¹à¼¹à¼»à¼»à½à½à½à½®à½³à¾à¾à¾à¾à¾¾à¿à¿ááááá¢ááááááá¼á¾áááááááááá¢ááááá²á´á·áºááááááááááááááá¡ááá¢á·áºá¿áá®á±áááá¢á¬á°áºááááá¢á¶ááá¢á®á°á²á´áµááááááá¢á«á á á á á ¢á¡¹á¢á¢¬á¢²á£·á¤á¤ á¤¢á¤­á¤²á¤½á¥á¥¯á¥²á¥¶á¦á¦­á¦²á§á§á§á¨á¨á¨¢á© á©¢á©¾áªáªáªáªáª©áª©áª²áª¿á¬á­á­á­á­­á­µá®á¯µá°á°¹á±á±á±á±¿á²á²á³á³á³á³¸á³ºá³»á´á··á·½á¼á¼á¼á¼¢á½á½á½á½á½á½á½á½á½á½á½á½¡á½¿á¾á¾¶á¾¸á¾¾á¿á¿á¿á¿á¿á¿á¿á¿á¿á¿á¿¢á¿®á¿´á¿¶á¿¸á¿¾âââ¬â°âââââ¢â¦â¨â±â³â³âââââââ£â£â§â²âââââââââââ¦â¦â¨â¨âªâªâ¬â¯â±â»â¾ââââââ¢ââ°â°°â°²â± â±¢â³¦â³­â³µâ´â´§â´©â´©â´¯â´¯â´²âµ©âµ±âµ±â¶â¶â¶¢â¶¨â¶ªâ¶°â¶²â¶¸â¶ºâ·â·â·â·â·â·â·â·â· â·¢â¸â¸±â¸±ããã£ã±ã³ã·ãºã¾ãããããã¡ã£ã¼ã¾ããã¯ã³ãã¢ã¼ã²ããä¶·ä¸é¿êêêê¿êêêê­êê±ê¶ê¿êê³êê¡ê¤êêê°ê²ê¹ê¹ê ©ê¡ê¡µê¢ê£ê£ê£ê£¢ê£¹ê£½ê£½ê£¿ê£¿ê¤ê¤¯ê¤²ê¥ê¥¢ê¥¾ê¦ê§ê§ê§ê§¢ê¨ê¨ê¨¸ê©ê©ê©ê©ê©¢ê©¸ê©¼ê«ê«ê«ê«¢ê«±ê«´ê«¸ê¬ê¬ê¬ê¬ê¬ê¬ê¬¢ê¬¨ê¬ªê¬°ê¬²ê­ê­ê­§ê­²ê¯¬ê¯®ê¯¯ê¯²ê¯»ê°í¥í²ííí½ï¤ï©¯ï©²ï«ï¬ï¬ï¬ï¬ï¬ï¬ªï¬¬ï¬¸ï¬ºï¬¾ï­ï­ï­ï­ï­ï­ï­ï®³ï¯ï´¿ïµï¶ï¶ï·ï·²ï·½ï¸ï¸ï¸¢ï¸±ï¸µï¸¶ï¹ï¹ï¹²ï¹¶ï¹¸ï»¾ï¼ï¼ï¼ï¼ï¼£ï¼¼ï½ï½ï½ï½ï½¨ï¿ï¿ï¿ï¿ï¿ï¿ï¿ï¿ï¿ï¿»ï¿½\r(*<>?AOR_ÂÃ¼ÅÅ¶Ç¿Ç¿ÊÊÊ¢ËË¢Ë¢ÌÌ¡Ì²ÍÍÍ¼ÎÎÎ¢ÏÏÏÏÏÐÒÒ¢Ò«Ò²ÓÓÓ½ÔÔ©Ô²Õ¥ØÜ¸ÝÝÝ¢Ý©à à à à à à ·à ¹à ºà ¾à ¾à¡à¡à¡¢à¡¸à¢à¢ à£¢à£´à£¶à£·à¤à¤à¤¢à¤»à¦à¦¹à§à§à¨à¨à¨à¨à¨à¨à¨à¨à¨à¨µà¨ºà¨¼à©à©à©¢à©¾àªàªà«à«à«à«¨à¬à¬·à­à­à­¢à­´à®à®à°à±à²à²´à³à³´ááá¨á±áá¼á¿á¿ááªá²á»áá¶á¸áááµá¸á¸áááááááááááá¹ááááááááááá¡áªá²á¬á²á»ááááááááªá¬á²á´áµá·á»á¾ááááááááááá¥á¨á®á²á¶áááááááááááá·áºááááááááááá¹áááááá­á²á»á¢¢á£«á¤á¤á«á«ºá°á°á°á°¸á°ºá±á±á±á±´á²á²á²©á²«á²¸ââââ°ââãã°ääæ æ¨ºæ©æ© æ©¢æ©«æ«æ«¯æ«²æ«¶æ¬æ¬¸æ­æ­æ­æ­æ­¥æ­¹æ­¿æ®æ¼æ½æ½æ¾æ¾æ¾¡æ¿¢æ¿¢çè®è è«´ëëë°ë±¬ë±²ë±¾ë²ë²ë²ë²ë²ë² ë²¢ë²¥í§í«í¯íííí¬í¯ííííííí í¡í¤í¤í§í¨í«í®í°í»í½í½í¿íííííííííí í»í½ííííííííí§íªííííí¼í¾ííí¶í¸ííí°í²íííªí¬íííí\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1îîîîîî£î¥î¦î¨î¬î î£î£î£î¤î¥î¥î¥î¸î¸î¸î¸¡î¸£î¸¤î¸¦î¸¦î¸©î¸©î¸«î¸´î¸¶î¸¹î¸»î¸»î¸½î¸½î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹¡î¹¡î¹£î¹¤î¹¦î¹¦î¹©î¹¬î¹®î¹´î¹¶î¹¹î¹»î¹¾îºîºîºîºîºîºîº£îº¥îº§îº«îº­îº½êêë¶ëë ë ¢ìº£ï ï¨"ÂÄÇ±ÉC\\c|Â¬Â¬Â·Â·Â¼Â¼ÃÃÃÃ¸ÃºËËËË¢Ë¦Ë®Ë®Ë°Ë°Í²Í¶Í¸Í¹Í¼Í¿ÎÎÎÎÎÎÎÎÎÎ£Î¥Ï·Ï¹ÒÒÔ±Ô³ÕÕÕÕ£Ö××¬×²×´Ø¢ÙÙ°Ù±Ù³ÛÛÛÛ§Û¨Û°Û±Û¼Û¾ÜÜÜÜÜÜ±ÝÞ§Þ³Þ³ßß¬ß¶ß·ß¼ß¼à à à à à ¦à ¦à ªà ªà¡à¡à¢¢à¢¶à¢¸à¢¿à¤à¤»à¤¿à¤¿à¥à¥à¥à¥£à¥³à¦à¦à¦à¦à¦à¦à¦ªà¦¬à¦²à¦´à¦´à¦¸à¦»à¦¿à¦¿à§à§à§à§à§¡à§£à§²à§³à¨à¨à¨à¨à¨à¨ªà¨¬à¨²à¨´à¨µà¨·à¨¸à¨ºà¨»à©à©à© à© à©´à©¶àªàªàªàªàªàªªàª¬àª²àª´àªµàª·àª»àª¿àª¿à«à«à«¢à«£à«»à«»à¬à¬à¬à¬à¬à¬ªà¬¬à¬²à¬´à¬µà¬·à¬»à¬¿à¬¿à­à­à­¡à­£à­³à­³à®à®à®à®à®à®à®à®à®à®à®à®à® à®¡à®¥à®¦à®ªà®¬à®°à®»à¯à¯à°à°à°à°à°à°ªà°¬à°»à°¿à°¿à±à±à±¢à±£à²à²à²à²à²à²à²à²ªà²¬à²µà²·à²»à²¿à²¿à³ à³ à³¢à³£à³³à³´à´à´à´à´à´à´¼à´¿à´¿àµàµàµàµàµ¡àµ£àµ¼à¶à¶à¶à¶à¶³à¶µà¶½à¶¿à¶¿à·à·à¸à¸²à¸´à¸µà¹à¹àºàºàºàºàºàºàºàºàºàºàºàºàºàº¡àº£àº¥àº§àº§àº©àº©àº¬àº­àº¯àº²àº´àºµàº¿àº¿à»à»à»à»à»à»¡à¼à¼à½à½à½à½®à¾à¾áá¬ááááááá£á£á§á¨á°á²á·áááá¢ááááááá¼á¾áááááááááá¢ááááá²á´á·áºáááááááááááááááá¢á·áºá¿áá®á±áááá¢á¬á°áºááááá¢á³ááá¢á®á°á²ááµááááá ¢á¡¹á¢á¢á¢á¢ªá¢¬á¢¬á¢²á£·á¤á¤ á¥á¥¯á¥²á¥¶á¦á¦­á¦²á§á¨á¨á¨¢á©áª©áª©á¬á¬µá­á­á®á®¢á®°á®±á®¼á¯§á°á°¥á±á±á±á±¿á²á²á³«á³®á³°á³³á³·á³¸á´á·á¸á¼á¼á¼á¼¢á½á½á½á½á½á½á½á½á½á½á½á½¡á½¿á¾á¾¶á¾¸á¾¾á¿á¿á¿á¿á¿á¿á¿á¿á¿á¿á¿¢á¿®á¿´á¿¶á¿¸á¿¾â³â³âââââââââââââââ¦â¦â¨â¨âªâªâ¬â¯â±â»â¾ââââââ¢ââ°â°°â°²â± â±¢â³¦â³­â³°â³´â³µâ´â´§â´©â´©â´¯â´¯â´²âµ©âµ±âµ±â¶â¶â¶¢â¶¨â¶ªâ¶°â¶²â¶¸â¶ºâ·â·â·â·â·â·â·â·â· â¸±â¸±ããã£ã«ã³ã·ãºã¾ãããã¡ã£ã¼ã¾ããã¯ã³ãã¢ã¼ã²ããä¶·ä¸é¿êêêê¿êêêê¡ê¬ê­êê°êêê¢ê±êê¡ê¤êêê°ê²ê¹ê¹ê ê ê ê ê ê ê ¤ê¡ê¡µê¢ê¢µê£´ê£¹ê£½ê£½ê£¿ê£¿ê¤ê¤§ê¤²ê¥ê¥¢ê¥¾ê¦ê¦´ê§ê§ê§¢ê§¦ê§¨ê§±ê§¼ê¨ê¨ê¨ªê©ê©ê©ê©ê©¢ê©¸ê©¼ê©¼êªêª±êª³êª³êª·êª¸êª»êª¿ê«ê«ê«ê«ê«ê«ê«¢ê«¬ê«´ê«¶ê¬ê¬ê¬ê¬ê¬ê¬ê¬¢ê¬¨ê¬ªê¬°ê¬²ê­ê­ê­§ê­²ê¯¤ê°í¥í²ííí½ï¤ï©¯ï©²ï«ï¬ï¬ï¬ï¬ï¬ï¬ï¬¡ï¬ªï¬¬ï¬¸ï¬ºï¬¾ï­ï­ï­ï­ï­ï­ï­ï®³ï¯ï´¿ïµï¶ï¶ï·ï·²ï·½ï¹²ï¹¶ï¹¸ï»¾ï¼£ï¼¼ï½ï½ï½¨ï¿ï¿ï¿ï¿ï¿ï¿ï¿ï¿ï¿\r(*<>?AOR_ÂÃ¼ÅÅ¶ÊÊÊ¢ËÌÌ¡Ì²ÍÍÍ·ÎÎÎ¢ÏÏÏÏÏÐÒÒ²ÓÓÓ½ÔÔ©Ô²Õ¥ØÜ¸ÝÝÝ¢Ý©à à à à à à ·à ¹à ºà ¾à ¾à¡à¡à¡¢à¡¸à¢à¢ à£¢à£´à£¶à£·à¤à¤à¤¢à¤»à¦à¦¹à§à§à¨à¨à¨à¨à¨à¨à¨à¨µà©¢à©¾àªàªà«à«à«à«¦à¬à¬·à­à­à­¢à­´à®à®à°à±à²à²´à³à³´áá¹áá±ááªáá¨áá´á¸á¸áá´áááááááááá­ááááááááá¡áªá²á ááááááªá¬á²á´áµá·á»á¿á¿áááá£áá¶áááá±áááááá°áááá±áááá¬ááá¢¢á£¡á¤á¤á«á«ºá°á°á°á°°á±á±á±´á²ââââ°ââãã°ääæ æ¨ºæ©æ© æ«æ«¯æ¬æ¬±æ­æ­æ­¥æ­¹æ­¿æ®æ¼æ½æ½æ½æ¾æ¾¡æ¿¢æ¿¢çè®è è«´ëëë°ë±¬ë±²ë±¾ë²ë²ë²ë²ííííí í¡í¤í¤í§í¨í«í®í°í»í½í½í¿íííííííííí í»í½ííííí`,s._serializedATNSegment1=`íííí§íªííííí¼í¾ííí¶í¸ííí°í²íííªí¬íííî î£î¤î¥î¸î¸î¸î¸¡î¸£î¸¤î¸¦î¸¦î¸©î¸©î¸«î¸´î¸¶î¸¹î¸»î¸»î¸½î¸½î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹î¹¡î¹¡î¹£î¹¤î¹¦î¹¦î¹©î¹¬î¹®î¹´î¹¶î¹¹î¹»î¹¾îºîºîºîºîºîºîº£îº¥îº§îº«îº­îº½êêë¶ëë ë ¢ìº£ï ï¨1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`,s._serializedATN=h.join([s._serializedATNSegment0,s._serializedATNSegment1],""),In}var Kr={},Eu;function ac(){if(Eu)return Kr;Eu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Kr&&Kr.__decorate||function(x,h,s,r){var n=arguments.length,t=n<3?h:r===null?r=Object.getOwnPropertyDescriptor(h,s):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")t=Reflect.decorate(x,h,s,r);else for(var e=x.length-1;e>=0;e--)(o=x[e])&&(t=(n<3?o(t):n>3?o(h,s,t):o(h,s))||t);return n>3&&t&&Object.defineProperty(h,s,t),t};Object.defineProperty(Kr,"__esModule",{value:!0}),Kr.XPathLexerErrorListener=void 0;const a=z();let p=class{syntaxError(h,s,r,n,t,o){}};return l([a.Override],p.prototype,"syntaxError",null),Kr.XPathLexerErrorListener=p,Kr}var Gr={},$r={},Tu;function xn(){if(Tu)return $r;Tu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=$r&&$r.__decorate||function(x,h,s,r){var n=arguments.length,t=n<3?h:r===null?r=Object.getOwnPropertyDescriptor(h,s):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")t=Reflect.decorate(x,h,s,r);else for(var e=x.length-1;e>=0;e--)(o=x[e])&&(t=(n<3?o(t):n>3?o(h,s,t):o(h,s))||t);return n>3&&t&&Object.defineProperty(h,s,t),t};Object.defineProperty($r,"__esModule",{value:!0}),$r.XPathElement=void 0;const a=z();let p=class{constructor(h){this.nodeName=h,this.invert=!1}toString(){let h=this.invert?"!":"";return Object.constructor.name+"["+h+this.nodeName+"]"}};return l([a.Override],p.prototype,"toString",null),$r.XPathElement=p,$r}var gu;function cc(){if(gu)return Gr;gu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Gr&&Gr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Gr,"__esModule",{value:!0}),Gr.XPathRuleAnywhereElement=void 0;const a=z(),p=cn(),x=xn();let h=class extends x.XPathElement{constructor(r,n){super(r),this.ruleIndex=n}evaluate(r){return p.Trees.findAllRuleNodes(r,this.ruleIndex)}};return l([a.Override],h.prototype,"evaluate",null),Gr.XPathRuleAnywhereElement=h,Gr}var Qr={},yu;function hc(){if(yu)return Qr;yu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Qr&&Qr.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(Qr,"__esModule",{value:!0}),Qr.XPathRuleElement=void 0;const a=Me(),p=z(),x=cn(),h=xn();let s=class extends h.XPathElement{constructor(n,t){super(n),this.ruleIndex=t}evaluate(n){let t=[];for(let o of x.Trees.getChildren(n))o instanceof a.ParserRuleContext&&(o.ruleIndex===this.ruleIndex&&!this.invert||o.ruleIndex!==this.ruleIndex&&this.invert)&&t.push(o);return t}};return l([p.Override],s.prototype,"evaluate",null),Qr.XPathRuleElement=s,Qr}var Zr={},Nu;function fc(){if(Nu)return Zr;Nu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Zr&&Zr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(Zr,"__esModule",{value:!0}),Zr.XPathTokenAnywhereElement=void 0;const a=z(),p=cn(),x=xn();let h=class extends x.XPathElement{constructor(r,n){super(r),this.tokenType=n}evaluate(r){return p.Trees.findAllTokenNodes(r,this.tokenType)}};return l([a.Override],h.prototype,"evaluate",null),Zr.XPathTokenAnywhereElement=h,Zr}var Jr={},vu;function pc(){if(vu)return Jr;vu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Jr&&Jr.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(Jr,"__esModule",{value:!0}),Jr.XPathTokenElement=void 0;const a=z(),p=dn(),x=cn(),h=xn();let s=class extends h.XPathElement{constructor(n,t){super(n),this.tokenType=t}evaluate(n){let t=[];for(let o of x.Trees.getChildren(n))o instanceof p.TerminalNode&&(o.symbol.type===this.tokenType&&!this.invert||o.symbol.type!==this.tokenType&&this.invert)&&t.push(o);return t}};return l([a.Override],s.prototype,"evaluate",null),Jr.XPathTokenElement=s,Jr}var en={},Cu;function dc(){if(Cu)return en;Cu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=en&&en.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(en,"__esModule",{value:!0}),en.XPathWildcardAnywhereElement=void 0;const a=z(),p=cn(),x=co(),h=xn();let s=class extends h.XPathElement{constructor(){super(x.XPath.WILDCARD)}evaluate(n){return this.invert?[]:p.Trees.getDescendants(n)}};return l([a.Override],s.prototype,"evaluate",null),en.XPathWildcardAnywhereElement=s,en}var tn={},Ou;function xc(){if(Ou)return tn;Ou=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=tn&&tn.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(tn,"__esModule",{value:!0}),tn.XPathWildcardElement=void 0;const a=z(),p=cn(),x=co(),h=xn();let s=class extends h.XPathElement{constructor(){super(x.XPath.WILDCARD)}evaluate(n){let t=[];if(this.invert)return t;for(let o of p.Trees.getChildren(n))t.push(o);return t}};return l([a.Override],s.prototype,"evaluate",null),tn.XPathWildcardElement=s,tn}var Du;function co(){if(Du)return Fn;Du=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Fn,"__esModule",{value:!0}),Fn.XPath=void 0;const l=lo(),a=ao(),p=ci(),x=Me(),h=pe(),s=lc(),r=ac(),n=cc(),t=hc(),o=fc(),e=pc(),i=dc(),u=xc();let c=class fa{constructor(A,d){this.parser=A,this.path=d,this.elements=this.split(d)}split(A){let d=new s.XPathLexer(l.CharStreams.fromString(A));d.recover=T=>{throw T},d.removeErrorListeners(),d.addErrorListener(new r.XPathLexerErrorListener);let _=new a.CommonTokenStream(d);try{_.fill()}catch(T){if(T instanceof p.LexerNoViableAltException){let y="Invalid tokens or characters at index "+d.charPositionInLine+" in path '"+A+"' -- "+T.message;throw new RangeError(y)}throw T}let m=_.getTokens(),S=[],E=m.length,g=0;e:for(;g<E;){let T=m[g],N;switch(T.type){case s.XPathLexer.ROOT:case s.XPathLexer.ANYWHERE:let y=T.type===s.XPathLexer.ANYWHERE;g++,N=m[g];let O=N.type===s.XPathLexer.BANG;O&&(g++,N=m[g]);let F=this.getXPathElement(N,y);F.invert=O,S.push(F),g++;break;case s.XPathLexer.TOKEN_REF:case s.XPathLexer.RULE_REF:case s.XPathLexer.WILDCARD:S.push(this.getXPathElement(T,!1)),g++;break;case h.Token.EOF:break e;default:throw new Error("Unknowth path element "+T)}}return S}getXPathElement(A,d){if(A.type===h.Token.EOF)throw new Error("Missing path element at end of path");let _=A.text;if(_==null)throw new Error("Expected wordToken to have text content.");let m=this.parser.getTokenType(_),S=this.parser.getRuleIndex(_);switch(A.type){case s.XPathLexer.WILDCARD:return d?new i.XPathWildcardAnywhereElement:new u.XPathWildcardElement;case s.XPathLexer.TOKEN_REF:case s.XPathLexer.STRING:if(m===h.Token.INVALID_TYPE)throw new Error(_+" at index "+A.startIndex+" isn't a valid token name");return d?new o.XPathTokenAnywhereElement(_,m):new e.XPathTokenElement(_,m);default:if(S===-1)throw new Error(_+" at index "+A.startIndex+" isn't a valid rule name");return d?new n.XPathRuleAnywhereElement(_,S):new t.XPathRuleElement(_,S)}}static findAll(A,d,_){return new fa(_,d).evaluate(A)}evaluate(A){let d=new x.ParserRuleContext;d.addChild(A);let _=new Set([d]),m=0;for(;m<this.elements.length;){let S=new Set;for(let E of _)E.childCount>0&&this.elements[m].evaluate(E).forEach(S.add,S);m++,_=S}return _}};return Fn.XPath=c,c.WILDCARD="*",c.NOT="!",Fn}var bu;function _c(){if(bu)return Pt;bu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Pt&&Pt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=Pt&&Pt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(Pt,"__esModule",{value:!0}),Pt.ParseTreePattern=void 0;const p=z(),x=co();let h=class{constructor(r,n,t,o){this._matcher=r,this._patternRuleIndex=t,this._pattern=n,this._patternTree=o}match(r){return this._matcher.match(r,this)}matches(r){return this._matcher.match(r,this).succeeded}findAll(r,n){let t=x.XPath.findAll(r,n,this._matcher.parser),o=[];for(let e of t){let i=this.match(e);i.succeeded&&o.push(i)}return o}get matcher(){return this._matcher}get pattern(){return this._pattern}get patternRuleIndex(){return this._patternRuleIndex}get patternTree(){return this._patternTree}};return l([p.NotNull],h.prototype,"_pattern",void 0),l([p.NotNull],h.prototype,"_patternTree",void 0),l([p.NotNull],h.prototype,"_matcher",void 0),l([p.NotNull,a(0,p.NotNull)],h.prototype,"match",null),l([a(0,p.NotNull)],h.prototype,"matches",null),l([p.NotNull,a(0,p.NotNull),a(1,p.NotNull)],h.prototype,"findAll",null),l([p.NotNull],h.prototype,"matcher",null),l([p.NotNull],h.prototype,"pattern",null),l([p.NotNull],h.prototype,"patternTree",null),h=l([a(0,p.NotNull),a(1,p.NotNull),a(3,p.NotNull)],h),Pt.ParseTreePattern=h,Pt}var Lt={},Ru;function Ac(){if(Ru)return Lt;Ru=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Lt&&Lt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=Lt&&Lt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(Lt,"__esModule",{value:!0}),Lt.RuleTagToken=void 0;const p=z(),x=pe();let h=class{constructor(r,n,t){if(r==null||r.length===0)throw new Error("ruleName cannot be null or empty.");this._ruleName=r,this.bypassTokenType=n,this._label=t}get ruleName(){return this._ruleName}get label(){return this._label}get channel(){return x.Token.DEFAULT_CHANNEL}get text(){return this._label!=null?"<"+this._label+":"+this._ruleName+">":"<"+this._ruleName+">"}get type(){return this.bypassTokenType}get line(){return 0}get charPositionInLine(){return-1}get tokenIndex(){return-1}get startIndex(){return-1}get stopIndex(){return-1}get tokenSource(){}get inputStream(){}toString(){return this._ruleName+":"+this.bypassTokenType}};return l([p.NotNull],h.prototype,"ruleName",null),l([p.Override],h.prototype,"channel",null),l([p.Override],h.prototype,"text",null),l([p.Override],h.prototype,"type",null),l([p.Override],h.prototype,"line",null),l([p.Override],h.prototype,"charPositionInLine",null),l([p.Override],h.prototype,"tokenIndex",null),l([p.Override],h.prototype,"startIndex",null),l([p.Override],h.prototype,"stopIndex",null),l([p.Override],h.prototype,"tokenSource",null),l([p.Override],h.prototype,"inputStream",null),l([p.Override],h.prototype,"toString",null),h=l([a(0,p.NotNull)],h),Lt.RuleTagToken=h,Lt}var rn={},wn={},Pu;function pa(){if(Pu)return wn;Pu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(wn,"__esModule",{value:!0}),wn.Chunk=void 0;let l=class{};return wn.Chunk=l,wn}var Lu;function mc(){if(Lu)return rn;Lu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=rn&&rn.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o};Object.defineProperty(rn,"__esModule",{value:!0}),rn.TagChunk=void 0;const a=pa(),p=z();let x=class extends a.Chunk{constructor(s,r){if(super(),s==null||s.length===0)throw new Error("tag cannot be null or empty");this._tag=s,this._label=r}get tag(){return this._tag}get label(){return this._label}toString(){return this._label!=null?this._label+":"+this._tag:this._tag}};return l([p.NotNull],x.prototype,"tag",null),l([p.Override],x.prototype,"toString",null),rn.TagChunk=x,rn}var Ft={},Fu;function Sc(){if(Fu)return Ft;Fu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ft&&Ft.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=Ft&&Ft.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(Ft,"__esModule",{value:!0}),Ft.TextChunk=void 0;const p=pa(),x=z();let h=class extends p.Chunk{constructor(r){if(super(),r==null)throw new Error("text cannot be null");this._text=r}get text(){return this._text}toString(){return"'"+this._text+"'"}};return l([x.NotNull],h.prototype,"_text",void 0),l([x.NotNull],h.prototype,"text",null),l([x.Override],h.prototype,"toString",null),h=l([a(0,x.NotNull)],h),Ft.TextChunk=h,Ft}var It={},Iu;function Ec(){if(Iu)return It;Iu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=It&&It.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=It&&It.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(It,"__esModule",{value:!0}),It.TokenTagToken=void 0;const p=Vn(),x=z();let h=class extends p.CommonToken{constructor(r,n,t){super(n),this._tokenName=r,this._label=t}get tokenName(){return this._tokenName}get label(){return this._label}get text(){return this._label!=null?"<"+this._label+":"+this._tokenName+">":"<"+this._tokenName+">"}toString(){return this._tokenName+":"+this.type}};return l([x.NotNull],h.prototype,"_tokenName",void 0),l([x.NotNull],h.prototype,"tokenName",null),l([x.Override],h.prototype,"text",null),l([x.Override],h.prototype,"toString",null),h=l([a(0,x.NotNull)],h),It.TokenTagToken=h,It}var wu;function Tc(){return wu||(wu=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=Yr&&Yr.__decorate||function(N,y,O,F){var w=arguments.length,M=w<3?y:F===null?F=Object.getOwnPropertyDescriptor(y,O):F,W;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")M=Reflect.decorate(N,y,O,F);else for(var ee=N.length-1;ee>=0;ee--)(W=N[ee])&&(M=(w<3?W(M):w>3?W(y,O,M):W(y,O))||M);return w>3&&M&&Object.defineProperty(y,O,M),M},p=Yr&&Yr.__param||function(N,y){return function(O,F){y(O,F,N)}};Object.defineProperty(l,"__esModule",{value:!0}),l.ParseTreePatternMatcher=void 0;const x=da(),h=lo(),s=ao(),r=la(),n=sc(),t=z(),o=aa(),e=ha(),i=Me(),u=uc(),c=_c(),f=Qt(),A=so(),d=Ac(),_=mc(),m=dn(),S=Sc(),E=pe(),g=Ec();let T=class Yi{constructor(y,O){this.start="<",this.stop=">",this.escape="\\",this.escapeRE=/\\/g,this._lexer=y,this._parser=O}setDelimiters(y,O,F){if(!y)throw new Error("start cannot be null or empty");if(!O)throw new Error("stop cannot be null or empty");this.start=y,this.stop=O,this.escape=F,this.escapeRE=new RegExp(F.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g")}matches(y,O,F=0){if(typeof O=="string"){let w=this.compile(O,F);return this.matches(y,w)}else{let w=new n.MultiMap;return!this.matchImpl(y,O.patternTree,w)}}match(y,O,F=0){if(typeof O=="string"){let w=this.compile(O,F);return this.match(y,w)}else{let w=new n.MultiMap,M=this.matchImpl(y,O.patternTree,w);return new u.ParseTreeMatch(y,O,w,M)}}compile(y,O){let F=this.tokenize(y),w=new r.ListTokenSource(F),M=new s.CommonTokenStream(w);const W=this._parser;let ee=new e.ParserInterpreter(W.grammarFileName,W.vocabulary,W.ruleNames,W.getATNWithBypassAlts(),M),J;try{ee.errorHandler=new x.BailErrorStrategy,J=ee.parse(O)}catch(ae){throw ae instanceof o.ParseCancellationException?ae.getCause():ae instanceof f.RecognitionException?ae:ae instanceof Error?new Yi.CannotInvokeStartRule(ae):ae}if(M.LA(1)!==E.Token.EOF)throw new Yi.StartRuleDoesNotConsumeFullPattern;return new c.ParseTreePattern(this,y,O,J)}get lexer(){return this._lexer}get parser(){return this._parser}matchImpl(y,O,F){if(!y)throw new TypeError("tree cannot be null");if(!O)throw new TypeError("patternTree cannot be null");if(y instanceof m.TerminalNode&&O instanceof m.TerminalNode){let w;if(y.symbol.type===O.symbol.type)if(O.symbol instanceof g.TokenTagToken){let M=O.symbol;F.map(M.tokenName,y);const W=M.label;W&&F.map(W,y)}else y.text===O.text||w||(w=y);else w||(w=y);return w}if(y instanceof i.ParserRuleContext&&O instanceof i.ParserRuleContext){let w,M=this.getRuleTagToken(O);if(M){if(y.ruleContext.ruleIndex===O.ruleContext.ruleIndex){F.map(M.ruleName,y);const ee=M.label;ee&&F.map(ee,y)}else w||(w=y);return w}if(y.childCount!==O.childCount)return w||(w=y),w;let W=y.childCount;for(let ee=0;ee<W;ee++){let J=this.matchImpl(y.getChild(ee),O.getChild(ee),F);if(J)return J}return w}return y}getRuleTagToken(y){if(y instanceof A.RuleNode&&y.childCount===1&&y.getChild(0)instanceof m.TerminalNode){let O=y.getChild(0);if(O.symbol instanceof d.RuleTagToken)return O.symbol}}tokenize(y){let O=this.split(y),F=[];for(let w of O)if(w instanceof _.TagChunk){let M=w;const W=M.tag.substr(0,1);if(W===W.toUpperCase()){let ee=this._parser.getTokenType(M.tag);if(ee===E.Token.INVALID_TYPE)throw new Error("Unknown token "+M.tag+" in pattern: "+y);let J=new g.TokenTagToken(M.tag,ee,M.label);F.push(J)}else if(W===W.toLowerCase()){let ee=this._parser.getRuleIndex(M.tag);if(ee===-1)throw new Error("Unknown rule "+M.tag+" in pattern: "+y);let J=this._parser.getATNWithBypassAlts().ruleToTokenType[ee];F.push(new d.RuleTagToken(M.tag,J,M.label))}else throw new Error("invalid tag: "+M.tag+" in pattern: "+y)}else{let M=w;this._lexer.inputStream=h.CharStreams.fromString(M.text);let W=this._lexer.nextToken();for(;W.type!==E.Token.EOF;)F.push(W),W=this._lexer.nextToken()}return F}split(y){let O=0,F=y.length,w=[],M=[],W=[];for(;O<F;)O===y.indexOf(this.escape+this.start,O)?O+=this.escape.length+this.start.length:O===y.indexOf(this.escape+this.stop,O)?O+=this.escape.length+this.stop.length:O===y.indexOf(this.start,O)?(M.push(O),O+=this.start.length):O===y.indexOf(this.stop,O)?(W.push(O),O+=this.stop.length):O++;if(M.length>W.length)throw new Error("unterminated tag in pattern: "+y);if(M.length<W.length)throw new Error("missing start tag in pattern: "+y);let ee=M.length;for(let J=0;J<ee;J++)if(M[J]>=W[J])throw new Error("tag delimiters out of order in pattern: "+y);if(ee===0){let J=y.substring(0,F);w.push(new S.TextChunk(J))}if(ee>0&&M[0]>0){let J=y.substring(0,M[0]);w.push(new S.TextChunk(J))}for(let J=0;J<ee;J++){let ae=y.substring(M[J]+this.start.length,W[J]),Se=ae,ue,ke=ae.indexOf(":");if(ke>=0&&(ue=ae.substring(0,ke),Se=ae.substring(ke+1,ae.length)),w.push(new _.TagChunk(Se,ue)),J+1<ee){let Ne=y.substring(W[J]+this.stop.length,M[J+1]);w.push(new S.TextChunk(Ne))}}if(ee>0){let J=W[ee-1]+this.stop.length;if(J<F){let ae=y.substring(J,F);w.push(new S.TextChunk(ae))}}for(let J=0;J<w.length;J++){let ae=w[J];if(ae instanceof S.TextChunk){let Se=ae.text.replace(this.escapeRE,"");Se.length<ae.text.length&&(w[J]=new S.TextChunk(Se))}}return w}};a([t.NotNull,p(1,t.NotNull)],T.prototype,"match",null),a([t.NotNull],T.prototype,"lexer",null),a([t.NotNull],T.prototype,"parser",null),a([p(0,t.NotNull),p(1,t.NotNull),p(2,t.NotNull)],T.prototype,"matchImpl",null),l.ParseTreePatternMatcher=T,function(N){class y extends Error{constructor(w){super(`CannotInvokeStartRule: ${w}`),this.error=w}}N.CannotInvokeStartRule=y;class O extends Error{constructor(){super("StartRuleDoesNotConsumeFullPattern")}}N.StartRuleDoesNotConsumeFullPattern=O}(T=l.ParseTreePatternMatcher||(l.ParseTreePatternMatcher={}))}(Yr)),Yr}var wt={},Bt={},Mt={},Bu;function Gn(){if(Bu)return Mt;Bu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Mt&&Mt.__decorate||function(h,s,r,n){var t=arguments.length,o=t<3?s:n===null?n=Object.getOwnPropertyDescriptor(s,r):n,e;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(h,s,r,n);else for(var i=h.length-1;i>=0;i--)(e=h[i])&&(o=(t<3?e(o):t>3?e(s,r,o):e(s,r))||o);return t>3&&o&&Object.defineProperty(s,r,o),o},a=Mt&&Mt.__param||function(h,s){return function(r,n){s(r,n,h)}};Object.defineProperty(Mt,"__esModule",{value:!0}),Mt.DecisionEventInfo=void 0;const p=z();let x=class{constructor(s,r,n,t,o,e){this.decision=s,this.fullCtx=e,this.stopIndex=o,this.input=n,this.startIndex=t,this.state=r}};return l([p.NotNull],x.prototype,"input",void 0),x=l([a(2,p.NotNull)],x),Mt.DecisionEventInfo=x,Mt}var Mu;function gc(){if(Mu)return Bt;Mu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Bt&&Bt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=Bt&&Bt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(Bt,"__esModule",{value:!0}),Bt.AmbiguityInfo=void 0;const p=Gn(),x=z();let h=class extends p.DecisionEventInfo{constructor(r,n,t,o,e,i){super(r,n,o,e,i,n.useContext),this.ambigAlts=t}get ambiguousAlternatives(){return this.ambigAlts}};return l([x.NotNull],h.prototype,"ambigAlts",void 0),l([x.NotNull],h.prototype,"ambiguousAlternatives",null),h=l([a(1,x.NotNull),a(2,x.NotNull),a(3,x.NotNull)],h),Bt.AmbiguityInfo=h,Bt}var kt={},ku;function yc(){if(ku)return kt;ku=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=kt&&kt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=kt&&kt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(kt,"__esModule",{value:!0}),kt.ContextSensitivityInfo=void 0;const p=Gn(),x=z();let h=class extends p.DecisionEventInfo{constructor(r,n,t,o,e){super(r,n,t,o,e,!0)}};return h=l([a(1,x.NotNull),a(2,x.NotNull)],h),kt.ContextSensitivityInfo=h,kt}var nn={},ju;function Nc(){if(ju)return nn;ju=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=nn&&nn.__decorate||function(x,h,s,r){var n=arguments.length,t=n<3?h:r===null?r=Object.getOwnPropertyDescriptor(h,s):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")t=Reflect.decorate(x,h,s,r);else for(var e=x.length-1;e>=0;e--)(o=x[e])&&(t=(n<3?o(t):n>3?o(h,s,t):o(h,s))||t);return n>3&&t&&Object.defineProperty(h,s,t),t};Object.defineProperty(nn,"__esModule",{value:!0}),nn.DecisionInfo=void 0;const a=z();let p=class{constructor(h){this.invocations=0,this.timeInPrediction=0,this.SLL_TotalLook=0,this.SLL_MinLook=0,this.SLL_MaxLook=0,this.LL_TotalLook=0,this.LL_MinLook=0,this.LL_MaxLook=0,this.contextSensitivities=[],this.errors=[],this.ambiguities=[],this.predicateEvals=[],this.SLL_ATNTransitions=0,this.SLL_DFATransitions=0,this.LL_Fallback=0,this.LL_ATNTransitions=0,this.LL_DFATransitions=0,this.decision=h}toString(){return"{decision="+this.decision+", contextSensitivities="+this.contextSensitivities.length+", errors="+this.errors.length+", ambiguities="+this.ambiguities.length+", SLL_lookahead="+this.SLL_TotalLook+", SLL_ATNTransitions="+this.SLL_ATNTransitions+", SLL_DFATransitions="+this.SLL_DFATransitions+", LL_Fallback="+this.LL_Fallback+", LL_lookahead="+this.LL_TotalLook+", LL_ATNTransitions="+this.LL_ATNTransitions+"}"}};return l([a.Override],p.prototype,"toString",null),nn.DecisionInfo=p,nn}var jt={},qu;function vc(){if(qu)return jt;qu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=jt&&jt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=jt&&jt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(jt,"__esModule",{value:!0}),jt.ErrorInfo=void 0;const p=Gn(),x=z();let h=class extends p.DecisionEventInfo{constructor(r,n,t,o,e){super(r,n,t,o,e,n.useContext)}};return h=l([a(1,x.NotNull),a(2,x.NotNull)],h),jt.ErrorInfo=h,jt}var qt={},zu;function Cc(){if(zu)return qt;zu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=qt&&qt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=qt&&qt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(qt,"__esModule",{value:!0}),qt.LookaheadEventInfo=void 0;const p=Gn(),x=z();let h=class extends p.DecisionEventInfo{constructor(r,n,t,o,e,i,u){super(r,n,o,e,i,u),this.predictedAlt=t}};return h=l([a(3,x.NotNull)],h),qt.LookaheadEventInfo=h,qt}var zt={},Uu;function Oc(){if(Uu)return zt;Uu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=zt&&zt.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e},a=zt&&zt.__param||function(s,r){return function(n,t){r(n,t,s)}};Object.defineProperty(zt,"__esModule",{value:!0}),zt.PredicateEvalInfo=void 0;const p=Gn(),x=z();let h=class extends p.DecisionEventInfo{constructor(r,n,t,o,e,i,u,c){super(n,r,t,o,e,r.useContext),this.semctx=i,this.evalResult=u,this.predictedAlt=c}};return h=l([a(0,x.NotNull),a(2,x.NotNull),a(5,x.NotNull)],h),zt.PredicateEvalInfo=h,zt}var Hu;function Vu(){if(Hu)return wt;Hu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=wt&&wt.__decorate||function(A,d,_,m){var S=arguments.length,E=S<3?d:m===null?m=Object.getOwnPropertyDescriptor(d,_):m,g;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")E=Reflect.decorate(A,d,_,m);else for(var T=A.length-1;T>=0;T--)(g=A[T])&&(E=(S<3?g(E):S>3?g(d,_,E):g(d,_))||E);return S>3&&E&&Object.defineProperty(d,_,E),E},a=wt&&wt.__param||function(A,d){return function(_,m){d(_,m,A)}};Object.defineProperty(wt,"__esModule",{value:!0}),wt.ProfilingATNSimulator=void 0;const p=gc(),x=ze(),h=ai(),s=yc(),r=Nc(),n=vc(),t=z(),o=Cc(),e=Kn(),i=Oc(),u=fn(),c=ra();let f=class extends e.ParserATNSimulator{constructor(d){super(d.interpreter.atn,d),this._startIndex=0,this._sllStopIndex=0,this._llStopIndex=0,this.currentDecision=0,this.conflictingAltResolvedBySLL=0,this.optimize_ll1=!1,this.reportAmbiguities=!0,this.numDecisions=this.atn.decisionToState.length,this.decisions=[];for(let _=0;_<this.numDecisions;_++)this.decisions.push(new r.DecisionInfo(_))}adaptivePredict(d,_,m,S){if(S!==void 0)return super.adaptivePredict(d,_,m,S);try{this._input=d,this._startIndex=d.index,this._sllStopIndex=this._startIndex-1,this._llStopIndex=-1,this.currentDecision=_,this.currentState=void 0,this.conflictingAltResolvedBySLL=x.ATN.INVALID_ALT_NUMBER;let E=process.hrtime(),g=super.adaptivePredict(d,_,m),T=process.hrtime(),N=(T[0]-E[0])*1e9;N===0?N=T[1]-E[1]:N+=1e9-E[1]+T[1],this.decisions[_].timeInPrediction+=N,this.decisions[_].invocations++;let y=this._sllStopIndex-this._startIndex+1;if(this.decisions[_].SLL_TotalLook+=y,this.decisions[_].SLL_MinLook=this.decisions[_].SLL_MinLook===0?y:Math.min(this.decisions[_].SLL_MinLook,y),y>this.decisions[_].SLL_MaxLook&&(this.decisions[_].SLL_MaxLook=y,this.decisions[_].SLL_MaxLookEvent=new o.LookaheadEventInfo(_,void 0,g,d,this._startIndex,this._sllStopIndex,!1)),this._llStopIndex>=0){let O=this._llStopIndex-this._startIndex+1;this.decisions[_].LL_TotalLook+=O,this.decisions[_].LL_MinLook=this.decisions[_].LL_MinLook===0?O:Math.min(this.decisions[_].LL_MinLook,O),O>this.decisions[_].LL_MaxLook&&(this.decisions[_].LL_MaxLook=O,this.decisions[_].LL_MaxLookEvent=new o.LookaheadEventInfo(_,void 0,g,d,this._startIndex,this._llStopIndex,!0))}return g}finally{this._input=void 0,this.currentDecision=-1}}getStartState(d,_,m,S){let E=super.getStartState(d,_,m,S);return this.currentState=E,E}computeStartState(d,_,m){let S=super.computeStartState(d,_,m);return this.currentState=S,S}computeReachSet(d,_,m,S){if(this._input===void 0)throw new Error("Invalid state");let E=super.computeReachSet(d,_,m,S);return E==null&&this.decisions[this.currentDecision].errors.push(new n.ErrorInfo(this.currentDecision,_,this._input,this._startIndex,this._input.index)),this.currentState=E,E}getExistingTargetState(d,_){if(this.currentState===void 0||this._input===void 0)throw new Error("Invalid state");this.currentState.useContext?this._llStopIndex=this._input.index:this._sllStopIndex=this._input.index;let m=super.getExistingTargetState(d,_);if(m!=null&&(this.currentState=new c.SimulatorState(this.currentState.outerContext,m,this.currentState.useContext,this.currentState.remainingOuterContext),this.currentState.useContext?this.decisions[this.currentDecision].LL_DFATransitions++:this.decisions[this.currentDecision].SLL_DFATransitions++,m===h.ATNSimulator.ERROR)){let S=new c.SimulatorState(this.currentState.outerContext,d,this.currentState.useContext,this.currentState.remainingOuterContext);this.decisions[this.currentDecision].errors.push(new n.ErrorInfo(this.currentDecision,S,this._input,this._startIndex,this._input.index))}return m}computeTargetState(d,_,m,S,E,g){let T=super.computeTargetState(d,_,m,S,E,g);return E?this.decisions[this.currentDecision].LL_ATNTransitions++:this.decisions[this.currentDecision].SLL_ATNTransitions++,T}evalSemanticContextImpl(d,_,m){if(this.currentState===void 0||this._input===void 0)throw new Error("Invalid state");let S=super.evalSemanticContextImpl(d,_,m);if(!(d instanceof u.SemanticContext.PrecedencePredicate)){let g=this._llStopIndex>=0?this._llStopIndex:this._sllStopIndex;this.decisions[this.currentDecision].predicateEvals.push(new i.PredicateEvalInfo(this.currentState,this.currentDecision,this._input,this._startIndex,g,d,S,m))}return S}reportContextSensitivity(d,_,m,S,E){if(this._input===void 0)throw new Error("Invalid state");_!==this.conflictingAltResolvedBySLL&&this.decisions[this.currentDecision].contextSensitivities.push(new s.ContextSensitivityInfo(this.currentDecision,m,this._input,S,E)),super.reportContextSensitivity(d,_,m,S,E)}reportAttemptingFullContext(d,_,m,S,E){_!=null?this.conflictingAltResolvedBySLL=_.nextSetBit(0):this.conflictingAltResolvedBySLL=m.s0.configs.getRepresentedAlternatives().nextSetBit(0),this.decisions[this.currentDecision].LL_Fallback++,super.reportAttemptingFullContext(d,_,m,S,E)}reportAmbiguity(d,_,m,S,E,g,T){if(this.currentState===void 0||this._input===void 0)throw new Error("Invalid state");let N;g!=null?N=g.nextSetBit(0):N=T.getRepresentedAlternatives().nextSetBit(0),this.conflictingAltResolvedBySLL!==x.ATN.INVALID_ALT_NUMBER&&N!==this.conflictingAltResolvedBySLL&&this.decisions[this.currentDecision].contextSensitivities.push(new s.ContextSensitivityInfo(this.currentDecision,this.currentState,this._input,m,S)),this.decisions[this.currentDecision].ambiguities.push(new p.AmbiguityInfo(this.currentDecision,this.currentState,g,this._input,m,S)),super.reportAmbiguity(d,_,m,S,E,g,T)}getDecisionInfo(){return this.decisions}getCurrentState(){return this.currentState}};return l([t.Override,a(0,t.NotNull)],f.prototype,"adaptivePredict",null),l([t.Override],f.prototype,"getStartState",null),l([t.Override],f.prototype,"computeStartState",null),l([t.Override],f.prototype,"computeReachSet",null),l([t.Override],f.prototype,"getExistingTargetState",null),l([t.Override],f.prototype,"computeTargetState",null),l([t.Override],f.prototype,"evalSemanticContextImpl",null),l([t.Override],f.prototype,"reportContextSensitivity",null),l([t.Override],f.prototype,"reportAttemptingFullContext",null),l([t.Override,a(0,t.NotNull),a(5,t.NotNull),a(6,t.NotNull)],f.prototype,"reportAmbiguity",null),wt.ProfilingATNSimulator=f,wt}var Yu;function $n(){if(Yu)return we;Yu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=we&&we.__decorate||function(S,E,g,T){var N=arguments.length,y=N<3?E:T===null?T=Object.getOwnPropertyDescriptor(E,g):T,O;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")y=Reflect.decorate(S,E,g,T);else for(var F=S.length-1;F>=0;F--)(O=S[F])&&(y=(N<3?O(y):N>3?O(E,g,y):O(E,g))||y);return N>3&&y&&Object.defineProperty(E,g,y),y},a=we&&we.__param||function(S,E){return function(g,T){E(g,T,S)}},p=we&&we.__awaiter||function(S,E,g,T){function N(y){return y instanceof g?y:new g(function(O){O(y)})}return new(g||(g=Promise))(function(y,O){function F(W){try{M(T.next(W))}catch(ee){O(ee)}}function w(W){try{M(T.throw(W))}catch(ee){O(ee)}}function M(W){W.done?y(W.value):N(W.value).then(F,w)}M((T=T.apply(S,E||[])).next())})};Object.defineProperty(we,"__esModule",{value:!0}),we.Parser=void 0;const x=Xt(),h=Vl(),s=uo(),r=ho(),n=oo(),t=pl(),o=tr(),e=z(),i=ic(),u=Kn(),c=na(),f=Xn(),A=dn(),d=pe();class _{constructor(E,g){this.ruleNames=E,this.tokenStream=g}enterEveryRule(E){console.log("enter   "+this.ruleNames[E.ruleIndex]+", LT(1)="+this.tokenStream.LT(1).text)}exitEveryRule(E){console.log("exit    "+this.ruleNames[E.ruleIndex]+", LT(1)="+this.tokenStream.LT(1).text)}visitErrorNode(E){}visitTerminal(E){let g=E.parent.ruleContext,T=E.symbol;console.log("consume "+T+" rule "+this.ruleNames[g.ruleIndex])}}l([e.Override],_.prototype,"enterEveryRule",null),l([e.Override],_.prototype,"exitEveryRule",null),l([e.Override],_.prototype,"visitErrorNode",null),l([e.Override],_.prototype,"visitTerminal",null);let m=class ni extends f.Recognizer{constructor(E){super(),this._errHandler=new r.DefaultErrorStrategy,this._precedenceStack=new t.IntegerStack,this._buildParseTrees=!0,this._parseListeners=[],this._syntaxErrors=0,this.matchedEOF=!1,this._precedenceStack.push(0),this.inputStream=E}reset(E){(E===void 0||E)&&this.inputStream.seek(0),this._errHandler.reset(this),this._ctx=void 0,this._syntaxErrors=0,this.matchedEOF=!1,this.isTrace=!1,this._precedenceStack.clear(),this._precedenceStack.push(0);let g=this.interpreter;g!=null&&g.reset()}match(E){let g=this.currentToken;return g.type===E?(E===d.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()):(g=this._errHandler.recoverInline(this),this._buildParseTrees&&g.tokenIndex===-1&&this._ctx.addErrorNode(this.createErrorNode(this._ctx,g))),g}matchWildcard(){let E=this.currentToken;return E.type>0?(this._errHandler.reportMatch(this),this.consume()):(E=this._errHandler.recoverInline(this),this._buildParseTrees&&E.tokenIndex===-1&&this._ctx.addErrorNode(this.createErrorNode(this._ctx,E))),E}set buildParseTree(E){this._buildParseTrees=E}get buildParseTree(){return this._buildParseTrees}getParseListeners(){return this._parseListeners}addParseListener(E){if(E==null)throw new TypeError("listener cannot be null");this._parseListeners.push(E)}removeParseListener(E){let g=this._parseListeners.findIndex(T=>T===E);g!==-1&&this._parseListeners.splice(g,1)}removeParseListeners(){this._parseListeners.length=0}triggerEnterRuleEvent(){for(let E of this._parseListeners)E.enterEveryRule&&E.enterEveryRule(this._ctx),this._ctx.enterRule(E)}triggerExitRuleEvent(){for(let E=this._parseListeners.length-1;E>=0;E--){let g=this._parseListeners[E];this._ctx.exitRule(g),g.exitEveryRule&&g.exitEveryRule(this._ctx)}}get numberOfSyntaxErrors(){return this._syntaxErrors}get tokenFactory(){return this._input.tokenSource.tokenFactory}getATNWithBypassAlts(){let E=this.serializedATN;if(E==null)throw new Error("The current parser does not support an ATN with bypass alternatives.");let g=ni.bypassAltsAtnCache.get(E);if(g==null){let T=new h.ATNDeserializationOptions;T.isGenerateRuleBypassTransitions=!0,g=new s.ATNDeserializer(T).deserialize(x.toCharArray(E)),ni.bypassAltsAtnCache.set(E,g)}return g}compileParseTreePattern(E,g,T){return p(this,void 0,void 0,function*(){if(!T){if(this.inputStream){let F=this.inputStream.tokenSource;F instanceof o.Lexer&&(T=F)}if(!T)throw new Error("Parser can't discover a lexer to use")}let N=T,y=yield Promise.resolve().then(()=>Tc());return new y.ParseTreePatternMatcher(N,this).compile(E,g)})}get errorHandler(){return this._errHandler}set errorHandler(E){this._errHandler=E}get inputStream(){return this._input}set inputStream(E){this.reset(!1),this._input=E}get currentToken(){return this._input.LT(1)}notifyErrorListeners(E,g,T){g===void 0?g=this.currentToken:g===null&&(g=void 0),this._syntaxErrors++;let N=-1,y=-1;g!=null&&(N=g.line,y=g.charPositionInLine);let O=this.getErrorListenerDispatch();O.syntaxError&&O.syntaxError(this,g,N,y,E,T)}consume(){let E=this.currentToken;E.type!==ni.EOF&&this.inputStream.consume();let g=this._parseListeners.length!==0;if(this._buildParseTrees||g)if(this._errHandler.inErrorRecoveryMode(this)){let T=this._ctx.addErrorNode(this.createErrorNode(this._ctx,E));if(g)for(let N of this._parseListeners)N.visitErrorNode&&N.visitErrorNode(T)}else{let T=this.createTerminalNode(this._ctx,E);if(this._ctx.addChild(T),g)for(let N of this._parseListeners)N.visitTerminal&&N.visitTerminal(T)}return E}createTerminalNode(E,g){return new A.TerminalNode(g)}createErrorNode(E,g){return new n.ErrorNode(g)}addContextToParseTree(){let E=this._ctx._parent;E!=null&&E.addChild(this._ctx)}enterRule(E,g,T){this.state=g,this._ctx=E,this._ctx._start=this._input.LT(1),this._buildParseTrees&&this.addContextToParseTree(),this.triggerEnterRuleEvent()}enterLeftFactoredRule(E,g,T){if(this.state=g,this._buildParseTrees){let N=this._ctx.getChild(this._ctx.childCount-1);this._ctx.removeLastChild(),N._parent=E,E.addChild(N)}this._ctx=E,this._ctx._start=this._input.LT(1),this._buildParseTrees&&this.addContextToParseTree(),this.triggerEnterRuleEvent()}exitRule(){this.matchedEOF?this._ctx._stop=this._input.LT(1):this._ctx._stop=this._input.tryLT(-1),this.triggerExitRuleEvent(),this.state=this._ctx.invokingState,this._ctx=this._ctx._parent}enterOuterAlt(E,g){if(E.altNumber=g,this._buildParseTrees&&this._ctx!==E){let T=this._ctx._parent;T!=null&&(T.removeLastChild(),T.addChild(E))}this._ctx=E}get precedence(){return this._precedenceStack.isEmpty?-1:this._precedenceStack.peek()}enterRecursionRule(E,g,T,N){this.state=g,this._precedenceStack.push(N),this._ctx=E,this._ctx._start=this._input.LT(1),this.triggerEnterRuleEvent()}pushNewRecursionContext(E,g,T){let N=this._ctx;N._parent=E,N.invokingState=g,N._stop=this._input.tryLT(-1),this._ctx=E,this._ctx._start=N._start,this._buildParseTrees&&this._ctx.addChild(N),this.triggerEnterRuleEvent()}unrollRecursionContexts(E){this._precedenceStack.pop(),this._ctx._stop=this._input.tryLT(-1);let g=this._ctx;if(this._parseListeners.length>0)for(;this._ctx!==E;)this.triggerExitRuleEvent(),this._ctx=this._ctx._parent;else this._ctx=E;g._parent=E,this._buildParseTrees&&E!=null&&E.addChild(g)}getInvokingContext(E){let g=this._ctx;for(;g&&g.ruleIndex!==E;)g=g._parent;return g}get context(){return this._ctx}set context(E){this._ctx=E}precpred(E,g){return g>=this._precedenceStack.peek()}getErrorListenerDispatch(){return new c.ProxyParserErrorListener(this.getErrorListeners())}inContext(E){return!1}isExpectedToken(E){let g=this.interpreter.atn,T=this._ctx,N=g.states[this.state],y=g.nextTokens(N);if(y.contains(E))return!0;if(!y.contains(d.Token.EPSILON))return!1;for(;T!=null&&T.invokingState>=0&&y.contains(d.Token.EPSILON);){let F=g.states[T.invokingState].transition(0);if(y=g.nextTokens(F.followState),y.contains(E))return!0;T=T._parent}return!!(y.contains(d.Token.EPSILON)&&E===d.Token.EOF)}get isMatchedEOF(){return this.matchedEOF}getExpectedTokens(){return this.atn.getExpectedTokens(this.state,this.context)}getExpectedTokensWithinCurrentRule(){let E=this.interpreter.atn,g=E.states[this.state];return E.nextTokens(g)}getRuleIndex(E){let g=this.getRuleIndexMap().get(E);return g??-1}get ruleContext(){return this._ctx}getRuleInvocationStack(E=this._ctx){let g=E,T=this.ruleNames,N=[];for(;g!=null;){let y=g.ruleIndex;y<0?N.push("n/a"):N.push(T[y]),g=g._parent}return N}getDFAStrings(){let E=[];for(let g of this._interp.atn.decisionToDFA)E.push(g.toString(this.vocabulary,this.ruleNames));return E}dumpDFA(){let E=!1;for(let g of this._interp.atn.decisionToDFA)g.isEmpty||(E&&console.log(),console.log("Decision "+g.decision+":"),process.stdout.write(g.toString(this.vocabulary,this.ruleNames)),E=!0)}get sourceName(){return this._input.sourceName}get parseInfo(){return Promise.resolve().then(()=>Vu()).then(E=>{let g=this.interpreter;if(g instanceof E.ProfilingATNSimulator)return new i.ParseInfo(g)})}setProfile(E){return p(this,void 0,void 0,function*(){let g=yield Promise.resolve().then(()=>Vu()),T=this.interpreter;E?T instanceof g.ProfilingATNSimulator||(this.interpreter=new g.ProfilingATNSimulator(this)):T instanceof g.ProfilingATNSimulator&&(this.interpreter=new u.ParserATNSimulator(this.atn,this)),this.interpreter.setPredictionMode(T.getPredictionMode())})}set isTrace(E){E?(this._tracer?this.removeParseListener(this._tracer):this._tracer=new _(this.ruleNames,this._input),this.addParseListener(this._tracer)):this._tracer&&(this.removeParseListener(this._tracer),this._tracer=void 0)}get isTrace(){return this._tracer!=null}};return m.bypassAltsAtnCache=new Map,l([e.NotNull],m.prototype,"_errHandler",void 0),l([e.NotNull],m.prototype,"match",null),l([e.NotNull],m.prototype,"matchWildcard",null),l([e.NotNull],m.prototype,"getParseListeners",null),l([a(0,e.NotNull)],m.prototype,"addParseListener",null),l([e.NotNull],m.prototype,"getATNWithBypassAlts",null),l([e.NotNull,a(0,e.NotNull)],m.prototype,"errorHandler",null),l([e.Override],m.prototype,"inputStream",null),l([e.NotNull],m.prototype,"currentToken",null),l([a(0,e.NotNull)],m.prototype,"enterRule",null),l([e.Override,a(0,e.Nullable)],m.prototype,"precpred",null),l([e.Override],m.prototype,"getErrorListenerDispatch",null),l([e.NotNull],m.prototype,"getExpectedTokens",null),l([e.NotNull],m.prototype,"getExpectedTokensWithinCurrentRule",null),l([e.Override],m.prototype,"parseInfo",null),we.Parser=m,we}var Xu;function pi(){if(Xu)return vr;Xu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=vr&&vr.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(vr,"__esModule",{value:!0}),vr.NoViableAltException=void 0;const a=$n(),p=Qt(),x=z();let h=class extends p.RecognitionException{constructor(r,n,t,o,e,i){r instanceof a.Parser&&(n===void 0&&(n=r.inputStream),t===void 0&&(t=r.currentToken),o===void 0&&(o=r.currentToken),i===void 0&&(i=r.context)),super(r,n,i),this._deadEndConfigs=e,this._startToken=t,this.setOffendingToken(r,o)}get startToken(){return this._startToken}get deadEndConfigs(){return this._deadEndConfigs}};return l([x.NotNull],h.prototype,"_startToken",void 0),vr.NoViableAltException=h,vr}var Wu;function ho(){if(Wu)return He;Wu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=He&&He.__decorate||function(u,c,f,A){var d=arguments.length,_=d<3?c:A===null?A=Object.getOwnPropertyDescriptor(c,f):A,m;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")_=Reflect.decorate(u,c,f,A);else for(var S=u.length-1;S>=0;S--)(m=u[S])&&(_=(d<3?m(_):d>3?m(c,f,_):m(c,f))||_);return d>3&&_&&Object.defineProperty(c,f,_),_},a=He&&He.__param||function(u,c){return function(f,A){c(f,A,u)}};Object.defineProperty(He,"__esModule",{value:!0}),He.DefaultErrorStrategy=void 0;const p=Yt(),x=Te(),h=oi(),s=si(),r=an(),n=pi(),t=Be(),o=pe(),e=z();let i=class{constructor(){this.errorRecoveryMode=!1,this.lastErrorIndex=-1,this.nextTokensState=p.ATNState.INVALID_STATE_NUMBER}reset(c){this.endErrorCondition(c)}beginErrorCondition(c){this.errorRecoveryMode=!0}inErrorRecoveryMode(c){return this.errorRecoveryMode}endErrorCondition(c){this.errorRecoveryMode=!1,this.lastErrorStates=void 0,this.lastErrorIndex=-1}reportMatch(c){this.endErrorCondition(c)}reportError(c,f){this.inErrorRecoveryMode(c)||(this.beginErrorCondition(c),f instanceof n.NoViableAltException?this.reportNoViableAlternative(c,f):f instanceof s.InputMismatchException?this.reportInputMismatch(c,f):f instanceof h.FailedPredicateException?this.reportFailedPredicate(c,f):(console.error(`unknown recognition error type: ${f}`),this.notifyErrorListeners(c,f.toString(),f)))}notifyErrorListeners(c,f,A){let d=A.getOffendingToken(c);d===void 0&&(d=null),c.notifyErrorListeners(f,d,A)}recover(c,f){this.lastErrorIndex===c.inputStream.index&&this.lastErrorStates&&this.lastErrorStates.contains(c.state)&&c.consume(),this.lastErrorIndex=c.inputStream.index,this.lastErrorStates||(this.lastErrorStates=new r.IntervalSet),this.lastErrorStates.add(c.state);let A=this.getErrorRecoverySet(c);this.consumeUntil(c,A)}sync(c){let f=c.interpreter.atn.states[c.state];if(this.inErrorRecoveryMode(c))return;let d=c.inputStream.LA(1),_=c.atn.nextTokens(f);if(_.contains(d)){this.nextTokensContext=void 0,this.nextTokensState=p.ATNState.INVALID_STATE_NUMBER;return}if(_.contains(o.Token.EPSILON)){this.nextTokensContext===void 0&&(this.nextTokensContext=c.context,this.nextTokensState=c.state);return}switch(f.stateType){case x.ATNStateType.BLOCK_START:case x.ATNStateType.STAR_BLOCK_START:case x.ATNStateType.PLUS_BLOCK_START:case x.ATNStateType.STAR_LOOP_ENTRY:if(this.singleTokenDeletion(c))return;throw new s.InputMismatchException(c);case x.ATNStateType.PLUS_LOOP_BACK:case x.ATNStateType.STAR_LOOP_BACK:this.reportUnwantedToken(c);let S=c.getExpectedTokens().or(this.getErrorRecoverySet(c));this.consumeUntil(c,S);break}}reportNoViableAlternative(c,f){let A=c.inputStream,d;A?f.startToken.type===o.Token.EOF?d="<EOF>":d=A.getTextFromRange(f.startToken,f.getOffendingToken()):d="<unknown input>";let _="no viable alternative at input "+this.escapeWSAndQuote(d);this.notifyErrorListeners(c,_,f)}reportInputMismatch(c,f){let A=f.expectedTokens,d=A?A.toStringVocabulary(c.vocabulary):"",_="mismatched input "+this.getTokenErrorDisplay(f.getOffendingToken(c))+" expecting "+d;this.notifyErrorListeners(c,_,f)}reportFailedPredicate(c,f){let d="rule "+c.ruleNames[c.context.ruleIndex]+" "+f.message;this.notifyErrorListeners(c,d,f)}reportUnwantedToken(c){if(this.inErrorRecoveryMode(c))return;this.beginErrorCondition(c);let f=c.currentToken,A=this.getTokenErrorDisplay(f),d=this.getExpectedTokens(c),_="extraneous input "+A+" expecting "+d.toStringVocabulary(c.vocabulary);c.notifyErrorListeners(_,f,void 0)}reportMissingToken(c){if(this.inErrorRecoveryMode(c))return;this.beginErrorCondition(c);let f=c.currentToken,d="missing "+this.getExpectedTokens(c).toStringVocabulary(c.vocabulary)+" at "+this.getTokenErrorDisplay(f);c.notifyErrorListeners(d,f,void 0)}recoverInline(c){let f=this.singleTokenDeletion(c);if(f)return c.consume(),f;if(this.singleTokenInsertion(c))return this.getMissingSymbol(c);throw this.nextTokensContext===void 0?new s.InputMismatchException(c):new s.InputMismatchException(c,this.nextTokensState,this.nextTokensContext)}singleTokenInsertion(c){let f=c.inputStream.LA(1),d=c.interpreter.atn.states[c.state].transition(0).target,_=c.interpreter.atn;return _.nextTokens(d,t.PredictionContext.fromRuleContext(_,c.context)).contains(f)?(this.reportMissingToken(c),!0):!1}singleTokenDeletion(c){let f=c.inputStream.LA(2);if(this.getExpectedTokens(c).contains(f)){this.reportUnwantedToken(c),c.consume();let d=c.currentToken;return this.reportMatch(c),d}}getMissingSymbol(c){let f=c.currentToken,A=this.getExpectedTokens(c),d=o.Token.INVALID_TYPE;A.isNil||(d=A.minElement);let _;d===o.Token.EOF?_="<missing EOF>":_="<missing "+c.vocabulary.getDisplayName(d)+">";let m=f,S=c.inputStream.tryLT(-1);return m.type===o.Token.EOF&&S!=null&&(m=S),this.constructToken(c.inputStream.tokenSource,d,_,m)}constructToken(c,f,A,d){let _=c.tokenFactory,m=d.tokenSource,S=m?m.inputStream:void 0;return _.create({source:c,stream:S},f,A,o.Token.DEFAULT_CHANNEL,-1,-1,d.line,d.charPositionInLine)}getExpectedTokens(c){return c.getExpectedTokens()}getTokenErrorDisplay(c){if(!c)return"<no token>";let f=this.getSymbolText(c);return f||(this.getSymbolType(c)===o.Token.EOF?f="<EOF>":f=`<${this.getSymbolType(c)}>`),this.escapeWSAndQuote(f)}getSymbolText(c){return c.text}getSymbolType(c){return c.type}escapeWSAndQuote(c){return c=c.replace(`
`,"\\n"),c=c.replace("\r","\\r"),c=c.replace("	","\\t"),"'"+c+"'"}getErrorRecoverySet(c){let f=c.interpreter.atn,A=c.context,d=new r.IntervalSet;for(;A&&A.invokingState>=0;){let m=f.states[A.invokingState].transition(0),S=f.nextTokens(m.followState);d.addAll(S),A=A._parent}return d.remove(o.Token.EPSILON),d}consumeUntil(c,f){let A=c.inputStream.LA(1);for(;A!==o.Token.EOF&&!f.contains(A);)c.consume(),A=c.inputStream.LA(1)}};return l([e.Override],i.prototype,"reset",null),l([a(0,e.NotNull)],i.prototype,"beginErrorCondition",null),l([e.Override],i.prototype,"inErrorRecoveryMode",null),l([a(0,e.NotNull)],i.prototype,"endErrorCondition",null),l([e.Override],i.prototype,"reportMatch",null),l([e.Override],i.prototype,"reportError",null),l([a(0,e.NotNull)],i.prototype,"notifyErrorListeners",null),l([e.Override],i.prototype,"recover",null),l([e.Override],i.prototype,"sync",null),l([a(0,e.NotNull),a(1,e.NotNull)],i.prototype,"reportNoViableAlternative",null),l([a(0,e.NotNull),a(1,e.NotNull)],i.prototype,"reportInputMismatch",null),l([a(0,e.NotNull),a(1,e.NotNull)],i.prototype,"reportFailedPredicate",null),l([a(0,e.NotNull)],i.prototype,"reportUnwantedToken",null),l([a(0,e.NotNull)],i.prototype,"reportMissingToken",null),l([e.Override],i.prototype,"recoverInline",null),l([a(0,e.NotNull)],i.prototype,"singleTokenInsertion",null),l([a(0,e.NotNull)],i.prototype,"singleTokenDeletion",null),l([e.NotNull,a(0,e.NotNull)],i.prototype,"getMissingSymbol",null),l([e.NotNull,a(0,e.NotNull)],i.prototype,"getExpectedTokens",null),l([a(0,e.NotNull)],i.prototype,"getSymbolText",null),l([a(0,e.NotNull)],i.prototype,"getSymbolType",null),l([e.NotNull,a(0,e.NotNull)],i.prototype,"escapeWSAndQuote",null),l([e.NotNull,a(0,e.NotNull)],i.prototype,"getErrorRecoverySet",null),l([a(0,e.NotNull),a(1,e.NotNull)],i.prototype,"consumeUntil",null),He.DefaultErrorStrategy=i,He}var Ku;function da(){if(Ku)return ir;Ku=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=ir&&ir.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i};Object.defineProperty(ir,"__esModule",{value:!0}),ir.BailErrorStrategy=void 0;const a=ho(),p=si(),x=z(),h=aa();let s=class extends a.DefaultErrorStrategy{recover(n,t){for(let o=n.context;o;o=o.parent)o.exception=t;throw new h.ParseCancellationException(t)}recoverInline(n){let t=new p.InputMismatchException(n);for(let o=n.context;o;o=o.parent)o.exception=t;throw new h.ParseCancellationException(t)}sync(n){}};return l([x.Override],s.prototype,"recover",null),l([x.Override],s.prototype,"recoverInline",null),l([x.Override],s.prototype,"sync",null),ir.BailErrorStrategy=s,ir}var Oi={},Gu;function Dc(){if(Gu)return Oi;Gu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Oi,"__esModule",{value:!0}),Oi}var Di={},$u;function bc(){return $u||($u=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(l,"__esModule",{value:!0}),l.Dependents=void 0,function(a){a[a.SELF=0]="SELF",a[a.PARENTS=1]="PARENTS",a[a.CHILDREN=2]="CHILDREN",a[a.ANCESTORS=3]="ANCESTORS",a[a.DESCENDANTS=4]="DESCENDANTS",a[a.SIBLINGS=5]="SIBLINGS",a[a.PRECEEDING_SIBLINGS=6]="PRECEEDING_SIBLINGS",a[a.FOLLOWING_SIBLINGS=7]="FOLLOWING_SIBLINGS",a[a.PRECEEDING=8]="PRECEEDING",a[a.FOLLOWING=9]="FOLLOWING"}(l.Dependents||(l.Dependents={}))}(Di)),Di}var Ut={},Qu;function Rc(){if(Qu)return Ut;Qu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ut&&Ut.__decorate||function(r,n,t,o){var e=arguments.length,i=e<3?n:o===null?o=Object.getOwnPropertyDescriptor(n,t):o,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,n,t,o);else for(var c=r.length-1;c>=0;c--)(u=r[c])&&(i=(e<3?u(i):e>3?u(n,t,i):u(n,t))||i);return e>3&&i&&Object.defineProperty(n,t,i),i},a=Ut&&Ut.__param||function(r,n){return function(t,o){n(t,o,r)}};Object.defineProperty(Ut,"__esModule",{value:!0}),Ut.DiagnosticErrorListener=void 0;const p=er(),x=z(),h=ye();let s=class{constructor(n=!0){this.exactOnly=n,this.exactOnly=n}syntaxError(n,t,o,e,i,u){}reportAmbiguity(n,t,o,e,i,u,c){if(this.exactOnly&&!i)return;let f=this.getDecisionDescription(n,t),A=this.getConflictingAlts(u,c),d=n.inputStream.getText(h.Interval.of(o,e)),_=`reportAmbiguity d=${f}: ambigAlts=${A}, input='${d}'`;n.notifyErrorListeners(_)}reportAttemptingFullContext(n,t,o,e,i,u){let c=this.getDecisionDescription(n,t),f=n.inputStream.getText(h.Interval.of(o,e)),A=`reportAttemptingFullContext d=${c}, input='${f}'`;n.notifyErrorListeners(A)}reportContextSensitivity(n,t,o,e,i,u){let c=this.getDecisionDescription(n,t),f=n.inputStream.getText(h.Interval.of(o,e)),A=`reportContextSensitivity d=${c}, input='${f}'`;n.notifyErrorListeners(A)}getDecisionDescription(n,t){let o=t.decision,e=t.atnStartState.ruleIndex,i=n.ruleNames;if(e<0||e>=i.length)return o.toString();let u=i[e];return u?`${o} (${u})`:o.toString()}getConflictingAlts(n,t){if(n!=null)return n;let o=new p.BitSet;for(let e of t)o.set(e.alt);return o}};return l([x.Override],s.prototype,"syntaxError",null),l([x.Override,a(0,x.NotNull),a(1,x.NotNull),a(6,x.NotNull)],s.prototype,"reportAmbiguity",null),l([x.Override,a(0,x.NotNull),a(1,x.NotNull),a(5,x.NotNull)],s.prototype,"reportAttemptingFullContext",null),l([x.Override,a(0,x.NotNull),a(1,x.NotNull),a(5,x.NotNull)],s.prototype,"reportContextSensitivity",null),l([a(0,x.NotNull),a(1,x.NotNull)],s.prototype,"getDecisionDescription",null),l([x.NotNull,a(1,x.NotNull)],s.prototype,"getConflictingAlts",null),Ut.DiagnosticErrorListener=s,Ut}var Ht={},Zu;function Pc(){if(Zu)return Ht;Zu=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Ht&&Ht.__decorate||function(n,t,o,e){var i=arguments.length,u=i<3?t:e===null?e=Object.getOwnPropertyDescriptor(t,o):e,c;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")u=Reflect.decorate(n,t,o,e);else for(var f=n.length-1;f>=0;f--)(c=n[f])&&(u=(i<3?c(u):i>3?c(t,o,u):c(t,o))||u);return i>3&&u&&Object.defineProperty(t,o,u),u},a=Ht&&Ht.__param||function(n,t){return function(o,e){t(o,e,n)}};Object.defineProperty(Ht,"__esModule",{value:!0}),Ht.LexerInterpreter=void 0;const p=tr(),x=hi(),h=z(),s=z();let r=class extends p.Lexer{constructor(t,o,e,i,u,c,f){if(super(f),c.grammarType!==0)throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");this._grammarFileName=t,this._atn=c,this._ruleNames=e.slice(0),this._channelNames=i.slice(0),this._modeNames=u.slice(0),this._vocabulary=o,this._interp=new x.LexerATNSimulator(c,this)}get atn(){return this._atn}get grammarFileName(){return this._grammarFileName}get ruleNames(){return this._ruleNames}get channelNames(){return this._channelNames}get modeNames(){return this._modeNames}get vocabulary(){return this._vocabulary}};return l([h.NotNull],r.prototype,"_vocabulary",void 0),l([s.Override],r.prototype,"atn",null),l([s.Override],r.prototype,"grammarFileName",null),l([s.Override],r.prototype,"ruleNames",null),l([s.Override],r.prototype,"channelNames",null),l([s.Override],r.prototype,"modeNames",null),l([s.Override],r.prototype,"vocabulary",null),r=l([a(1,h.NotNull)],r),Ht.LexerInterpreter=r,Ht}var bi={},Ju;function Lc(){if(Ju)return bi;Ju=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(bi,"__esModule",{value:!0}),bi}var on={},el;function Fc(){if(el)return on;el=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=on&&on.__decorate||function(s,r,n,t){var o=arguments.length,e=o<3?r:t===null?t=Object.getOwnPropertyDescriptor(r,n):t,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")e=Reflect.decorate(s,r,n,t);else for(var u=s.length-1;u>=0;u--)(i=s[u])&&(e=(o<3?i(e):o>3?i(r,n,e):i(r,n))||e);return o>3&&e&&Object.defineProperty(r,n,e),e};Object.defineProperty(on,"__esModule",{value:!0}),on.RuleContextWithAltNum=void 0;const a=ze(),p=z(),x=Me();let h=class extends x.ParserRuleContext{constructor(r,n){n!==void 0?super(r,n):super(),this._altNumber=a.ATN.INVALID_ALT_NUMBER}get altNumber(){return this._altNumber}set altNumber(r){this._altNumber=r}};return l([p.Override],h.prototype,"altNumber",null),on.RuleContextWithAltNum=h,on}var Bn={},tl;function Ic(){if(tl)return Bn;tl=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Bn,"__esModule",{value:!0}),Bn.RuleDependency=void 0;function l(a){return(p,x,h)=>{}}return Bn.RuleDependency=l,Bn}var Mn={},rl;function wc(){if(rl)return Mn;rl=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(Mn,"__esModule",{value:!0}),Mn.RuleVersion=void 0;function l(a){return(p,x,h)=>{}}return Mn.RuleVersion=l,Mn}var Ri={},nl;function Bc(){if(nl)return Ri;nl=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Ri,"__esModule",{value:!0}),Ri}var Pi={},il;function Mc(){if(il)return Pi;il=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Pi,"__esModule",{value:!0}),Pi}var Li={},ol;function kc(){if(ol)return Li;ol=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Li,"__esModule",{value:!0}),Li}var Vt={},sl;function jc(){if(sl)return Vt;sl=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var l=Vt&&Vt.__decorate||function(o,e,i,u){var c=arguments.length,f=c<3?e:u===null?u=Object.getOwnPropertyDescriptor(e,i):u,A;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")f=Reflect.decorate(o,e,i,u);else for(var d=o.length-1;d>=0;d--)(A=o[d])&&(f=(c<3?A(f):c>3?A(e,i,f):A(e,i))||f);return c>3&&f&&Object.defineProperty(e,i,f),f};Object.defineProperty(Vt,"__esModule",{value:!0}),Vt.RewriteOperation=Vt.TokenStreamRewriter=void 0;const a=ye(),p=z(),x=pe();let h=class Fe{constructor(e){this.tokens=e,this.programs=new Map,this.programs.set(Fe.DEFAULT_PROGRAM_NAME,[]),this.lastRewriteTokenIndexes=new Map}getTokenStream(){return this.tokens}rollback(e,i=Fe.DEFAULT_PROGRAM_NAME){let u=this.programs.get(i);u!=null&&this.programs.set(i,u.slice(Fe.MIN_TOKEN_INDEX,e))}deleteProgram(e=Fe.DEFAULT_PROGRAM_NAME){this.rollback(Fe.MIN_TOKEN_INDEX,e)}insertAfter(e,i,u=Fe.DEFAULT_PROGRAM_NAME){let c;typeof e=="number"?c=e:c=e.tokenIndex;let f=this.getProgram(u),A=new n(this.tokens,c,f.length,i);f.push(A)}insertBefore(e,i,u=Fe.DEFAULT_PROGRAM_NAME){let c;typeof e=="number"?c=e:c=e.tokenIndex;let f=this.getProgram(u),A=new r(this.tokens,c,f.length,i);f.push(A)}replaceSingle(e,i){typeof e=="number"?this.replace(e,e,i):this.replace(e,e,i)}replace(e,i,u,c=Fe.DEFAULT_PROGRAM_NAME){if(typeof e!="number"&&(e=e.tokenIndex),typeof i!="number"&&(i=i.tokenIndex),e>i||e<0||i<0||i>=this.tokens.size)throw new RangeError(`replace: range invalid: ${e}..${i}(size=${this.tokens.size})`);let f=this.getProgram(c),A=new t(this.tokens,e,i,f.length,u);f.push(A)}delete(e,i,u=Fe.DEFAULT_PROGRAM_NAME){i===void 0&&(i=e),typeof e=="number"?this.replace(e,i,"",u):this.replace(e,i,"",u)}getLastRewriteTokenIndex(e=Fe.DEFAULT_PROGRAM_NAME){let i=this.lastRewriteTokenIndexes.get(e);return i??-1}setLastRewriteTokenIndex(e,i){this.lastRewriteTokenIndexes.set(e,i)}getProgram(e){let i=this.programs.get(e);return i==null&&(i=this.initializeProgram(e)),i}initializeProgram(e){let i=[];return this.programs.set(e,i),i}getText(e,i=Fe.DEFAULT_PROGRAM_NAME){let u;e instanceof a.Interval?u=e:u=a.Interval.of(0,this.tokens.size-1),typeof e=="string"&&(i=e);let c=this.programs.get(i),f=u.a,A=u.b;if(A>this.tokens.size-1&&(A=this.tokens.size-1),f<0&&(f=0),c==null||c.length===0)return this.tokens.getText(u);let d=[],_=this.reduceToSingleOperationPerIndex(c),m=f;for(;m<=A&&m<this.tokens.size;){let S=_.get(m);_.delete(m);let E=this.tokens.get(m);S==null?(E.type!==x.Token.EOF&&d.push(String(E.text)),m++):m=S.execute(d)}if(A===this.tokens.size-1)for(let S of _.values())S.index>=this.tokens.size-1&&d.push(S.text.toString());return d.join("")}reduceToSingleOperationPerIndex(e){for(let u=0;u<e.length;u++){let c=e[u];if(c==null||!(c instanceof t))continue;let f=c,A=this.getKindOfOps(e,r,u);for(let _ of A)_.index===f.index?(e[_.instructionIndex]=void 0,f.text=_.text.toString()+(f.text!=null?f.text.toString():"")):_.index>f.index&&_.index<=f.lastIndex&&(e[_.instructionIndex]=void 0);let d=this.getKindOfOps(e,t,u);for(let _ of d){if(_.index>=f.index&&_.lastIndex<=f.lastIndex){e[_.instructionIndex]=void 0;continue}let m=_.lastIndex<f.index||_.index>f.lastIndex;if(_.text==null&&f.text==null&&!m)e[_.instructionIndex]=void 0,f.index=Math.min(_.index,f.index),f.lastIndex=Math.max(_.lastIndex,f.lastIndex);else if(!m)throw new Error(`replace op boundaries of ${f} overlap with previous ${_}`)}}for(let u=0;u<e.length;u++){let c=e[u];if(c==null||!(c instanceof r))continue;let f=c,A=this.getKindOfOps(e,r,u);for(let _ of A)_.index===f.index&&(_ instanceof n?(f.text=this.catOpText(_.text,f.text),e[_.instructionIndex]=void 0):_ instanceof r&&(f.text=this.catOpText(f.text,_.text),e[_.instructionIndex]=void 0));let d=this.getKindOfOps(e,t,u);for(let _ of d){if(f.index===_.index){_.text=this.catOpText(f.text,_.text),e[u]=void 0;continue}if(f.index>=_.index&&f.index<=_.lastIndex)throw new Error(`insert op ${f} within boundaries of previous ${_}`)}}let i=new Map;for(let u of e)if(u!=null){if(i.get(u.index)!=null)throw new Error("should only be one op per index");i.set(u.index,u)}return i}catOpText(e,i){let u="",c="";return e!=null&&(u=e.toString()),i!=null&&(c=i.toString()),u+c}getKindOfOps(e,i,u){let c=[];for(let f=0;f<u&&f<e.length;f++){let A=e[f];A!=null&&A instanceof i&&c.push(A)}return c}};Vt.TokenStreamRewriter=h,h.DEFAULT_PROGRAM_NAME="default",h.PROGRAM_INIT_SIZE=100,h.MIN_TOKEN_INDEX=0;class s{constructor(e,i,u,c){this.tokens=e,this.instructionIndex=u,this.index=i,this.text=c===void 0?"":c}execute(e){return this.index}toString(){let e=this.constructor.name,i=e.indexOf("$");return e=e.substring(i+1,e.length),"<"+e+"@"+this.tokens.get(this.index)+':"'+this.text+'">'}}l([p.Override],s.prototype,"toString",null),Vt.RewriteOperation=s;class r extends s{constructor(e,i,u,c){super(e,i,u,c)}execute(e){return e.push(this.text.toString()),this.tokens.get(this.index).type!==x.Token.EOF&&e.push(String(this.tokens.get(this.index).text)),this.index+1}}l([p.Override],r.prototype,"execute",null);class n extends r{constructor(e,i,u,c){super(e,i+1,u,c)}}class t extends s{constructor(e,i,u,c,f){super(e,i,c,f),this.lastIndex=u}execute(e){return this.text!=null&&e.push(this.text.toString()),this.lastIndex+1}toString(){return this.text==null?"<DeleteOp@"+this.tokens.get(this.index)+".."+this.tokens.get(this.lastIndex)+">":"<ReplaceOp@"+this.tokens.get(this.index)+".."+this.tokens.get(this.lastIndex)+':"'+this.text+'">'}}return l([p.Override],t.prototype,"execute",null),l([p.Override],t.prototype,"toString",null),Vt}var Fi={},ul;function qc(){if(ul)return Fi;ul=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Fi,"__esModule",{value:!0}),Fi}var Ii={},ll;function zc(){if(ll)return Ii;ll=1;/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */return Object.defineProperty(Ii,"__esModule",{value:!0}),Ii}var al;function Uc(){return al||(al=1,function(l){/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var a=rr&&rr.__createBinding||(Object.create?function(x,h,s,r){r===void 0&&(r=s),Object.defineProperty(x,r,{enumerable:!0,get:function(){return h[s]}})}:function(x,h,s,r){r===void 0&&(r=s),x[r]=h[s]}),p=rr&&rr.__exportStar||function(x,h){for(var s in x)s!=="default"&&!Object.prototype.hasOwnProperty.call(h,s)&&a(h,x,s)};Object.defineProperty(l,"__esModule",{value:!0}),p(Na(),l),p(va(),l),p(Ca(),l),p(da(),l),p(ua(),l),p(Dc(),l),p(lo(),l),p(ia(),l),p(sa(),l),p(Vn(),l),p(Gi(),l),p(ao(),l),p(Bl(),l),p(ho(),l),p(bc(),l),p(Rc(),l),p(oi(),l),p(si(),l),p(ca(),l),p($t(),l),p(tr(),l),p(Pc(),l),p(ci(),l),p(la(),l),p(pi(),l),p($n(),l),p(Lc(),l),p(ha(),l),p(Me(),l),p(eo(),l),p(na(),l),p(Qt(),l),p(Xn(),l),p(ta(),l),p(Fc(),l),p(Ic(),l),p(wc(),l),p(pe(),l),p(Bc(),l),p(Mc(),l),p(kc(),l),p(jc(),l),p(qc(),l),p(ln(),l),p(zc(),l)}(rr)),rr}var Xh=Uc(),xa=uo(),Hc=tr(),Vc=hi(),_a=ln(),Aa=Xt();const ie=class ie extends Hc.Lexer{get vocabulary(){return ie.VOCABULARY}constructor(a){super(a),this._interp=new Vc.LexerATNSimulator(ie._ATN,this)}get grammarFileName(){return"Formula.g4"}get ruleNames(){return ie.ruleNames}get serializedATN(){return ie._serializedATN}get channelNames(){return ie.channelNames}get modeNames(){return ie.modeNames}static get _ATN(){return ie.__ATN||(ie.__ATN=new xa.ATNDeserializer().deserialize(Aa.toCharArray(ie._serializedATN))),ie.__ATN}};Q(ie,"T__0",1),Q(ie,"T__1",2),Q(ie,"T__2",3),Q(ie,"REFERENCE",4),Q(ie,"REF",5),Q(ie,"REFRANGE",6),Q(ie,"BOOL",7),Q(ie,"STRING",8),Q(ie,"NUM",9),Q(ie,"FUNCNAME",10),Q(ie,"WS",11),Q(ie,"MUL",12),Q(ie,"DIV",13),Q(ie,"ADD",14),Q(ie,"SUB",15),Q(ie,"EQ",16),Q(ie,"NEQ",17),Q(ie,"LTE",18),Q(ie,"GTE",19),Q(ie,"LT",20),Q(ie,"GT",21),Q(ie,"channelNames",["DEFAULT_TOKEN_CHANNEL","HIDDEN"]),Q(ie,"modeNames",["DEFAULT_MODE"]),Q(ie,"ruleNames",["T__0","T__1","T__2","REFERENCE","SHEET_NAME","QUOTED_SHEET_NAME","REF","REFRANGE","BOOL","STRING","NUM","FUNCNAME","WS","MUL","DIV","ADD","SUB","EQ","NEQ","LTE","GTE","LT","GT"]),Q(ie,"_LITERAL_NAMES",[void 0,"'('","')'","','",void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,"'*'","'/'","'+'","'-'","'='","'<>'","'<='","'>='","'<'","'>'"]),Q(ie,"_SYMBOLIC_NAMES",[void 0,void 0,void 0,void 0,"REFERENCE","REF","REFRANGE","BOOL","STRING","NUM","FUNCNAME","WS","MUL","DIV","ADD","SUB","EQ","NEQ","LTE","GTE","LT","GT"]),Q(ie,"VOCABULARY",new _a.VocabularyImpl(ie._LITERAL_NAMES,ie._SYMBOLIC_NAMES,[])),Q(ie,"_serializedATN",`ì¤ìªºÖê¾ºä½ØîªìÃ\b					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r											J
\x07N
\fQ\v\x07\x07\x07U
\x07\r\x07\x07V\x07\x07\b\b\\
\b\b\b\b\`
\b\b\bc
\b\b\bf
\b\b\b\x07\bj
\b\f\b\bm\v\b				


















Â

\v\v\x07\vÂ
\v\f\v\vÂ\v\v\v\v\f\fÂ
\f\r\f\fÂ\f\f\fÂ
\f\r\f\fÂ\fÂ
\f\r\r\x07\rÂ
\r\f\r\rÂ¢\v\rÂ¥
\rÂ¦\x07	\v\r\x07\b	
\v\f\x1B\r!#%')+-/
C\\c|2;C\\c|))3;2;$$\x07002;C\\aac|\v\v""Ã\x07	\x1B!#%')+-/13\x075	I\vK\rR[nÂÂÂÂ\x1BÂ¤ÂªÂ¬!Â®#Â°%Â²'Â´)Â·+Âº-Â½/Â¿12\x07*234\x07+456\x07.6\b78\r\x0789\x07#9:	:J;<\r\x07<=\x07#=>\b>J?@\v@A\x07#AB	BJCD\vDE\x07#EF\bFJGJ	HJ\bI7I;I?ICIGIHJ
KO	LN	MLNQOMOPP\fQORT\x07)SU
TSUVVTVWWXXY\x07)YZ\\\x07&[Z[\\\\]]_	^\`	_^_\`\`bac	babccedf\x07&edeffggk	hj	ihjmkikllmkno\bop\x07<pq\bqrs\x07Vst\x07Ttu\x07WuÂ\x07Gvw\x07Hwx\x07Cxy\x07Nyz\x07UzÂ\x07G{|\x07v|}\x07t}~\x07w~Â\x07gÂ\x07hÂÂ\x07cÂÂ\x07nÂÂ\x07uÂÂ\x07gÂrÂvÂ{ÂÂÂÂ\x07$ÂÂ
\x07ÂÂÂÂÂÂÂÂÂÂÂÂÂÂ\x07$ÂÂÂ	ÂÂÂÂÂÂÂÂÂÂÂÂ\x070ÂÂ	ÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂ 	ÂÂ	\bÂÂÂÂ¢Â ÂÂ Â¡Â¡Â¢Â Â£Â¥		Â¤Â£Â¥Â¦Â¦Â¤Â¦Â§Â§Â¨Â¨Â©\bÂ©ÂªÂ«\x07,Â«Â¬Â­\x071Â­ Â®Â¯\x07-Â¯"Â°Â±\x07/Â±$Â²Â³\x07?Â³&Â´Âµ\x07>ÂµÂ¶\x07@Â¶(Â·Â¸\x07>Â¸Â¹\x07?Â¹*ÂºÂ»\x07@Â»Â¼\x07?Â¼,Â½Â¾\x07>Â¾.Â¿Ã\x07@Ã0IOV[_bekÂÂÂÂÂÂ Â¦\b`),Q(ie,"__ATN");let cl=ie;var Yc=ze(),Xc=oi(),Wc=pi(),Kc=$n(),fo=Me(),Gc=Kn(),wi=Qt(),Bi=pe();const V=class V extends Kc.Parser{get vocabulary(){return V.VOCABULARY}get grammarFileName(){return"Formula.g4"}get ruleNames(){return V.ruleNames}get serializedATN(){return V._serializedATN}createFailedPredicateException(a,p){return new Xc.FailedPredicateException(this,a,p)}constructor(a){super(a),this._interp=new Gc.ParserATNSimulator(V._ATN,this)}formula(){let a=new $c(this._ctx,this.state);this.enterRule(a,0,V.RULE_formula);let p;try{this.enterOuterAlt(a,1);{this.state=7,this._errHandler.sync(this),p=this._input.LA(1);do this.state=6,this.expr(0),this.state=9,this._errHandler.sync(this),p=this._input.LA(1);while((p&-32)===0&&(1<<p&(1<<V.T__0|1<<V.REFERENCE|1<<V.BOOL|1<<V.STRING|1<<V.NUM|1<<V.FUNCNAME))!==0)}}catch(x){if(x instanceof wi.RecognitionException)a.exception=x,this._errHandler.reportError(this,x),this._errHandler.recover(this,x);else throw x}finally{this.exitRule()}return a}expr(a){a===void 0&&(a=0);let p=this._ctx,x=this.state,h=new de(this._ctx,x),s=h,r=2;this.enterRecursionRule(h,2,V.RULE_expr,a);let n;try{let t;this.enterOuterAlt(h,1);{switch(this.state=26,this._errHandler.sync(this),this._input.LA(1)){case V.FUNCNAME:h=new Qc(h),this._ctx=h,s=h,this.state=12,this.match(V.FUNCNAME),this.state=13,this.match(V.T__0),this.state=15,this._errHandler.sync(this),n=this._input.LA(1),(n&-32)===0&&(1<<n&(1<<V.T__0|1<<V.REFERENCE|1<<V.BOOL|1<<V.STRING|1<<V.NUM|1<<V.FUNCNAME))!==0&&(this.state=14,this.args()),this.state=17,this.match(V.T__1);break;case V.NUM:h=new t0(h),this._ctx=h,s=h,this.state=18,this.match(V.NUM);break;case V.BOOL:h=new r0(h),this._ctx=h,s=h,this.state=19,this.match(V.BOOL);break;case V.STRING:h=new n0(h),this._ctx=h,s=h,this.state=20,this.match(V.STRING);break;case V.REFERENCE:h=new i0(h),this._ctx=h,s=h,this.state=21,this.match(V.REFERENCE);break;case V.T__0:h=new o0(h),this._ctx=h,s=h,this.state=22,this.match(V.T__0),this.state=23,this.expr(0),this.state=24,this.match(V.T__1);break;default:throw new Wc.NoViableAltException(this)}for(this._ctx._stop=this._input.tryLT(-1),this.state=39,this._errHandler.sync(this),t=this.interpreter.adaptivePredict(this._input,4,this._ctx);t!==2&&t!==Yc.ATN.INVALID_ALT_NUMBER;){if(t===1)switch(this._parseListeners!=null&&this.triggerExitRuleEvent(),s=h,this.state=37,this._errHandler.sync(this),this.interpreter.adaptivePredict(this._input,3,this._ctx)){case 1:{if(h=new Zc(new de(p,x)),this.pushNewRecursionContext(h,r,V.RULE_expr),this.state=28,!this.precpred(this._ctx,8))throw this.createFailedPredicateException("this.precpred(this._ctx, 8)");this.state=29,h._op=this._input.LT(1),n=this._input.LA(1),n===V.MUL||n===V.DIV?(this._input.LA(1)===Bi.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()):h._op=this._errHandler.recoverInline(this),this.state=30,this.expr(9)}break;case 2:{if(h=new Jc(new de(p,x)),this.pushNewRecursionContext(h,r,V.RULE_expr),this.state=31,!this.precpred(this._ctx,7))throw this.createFailedPredicateException("this.precpred(this._ctx, 7)");this.state=32,h._op=this._input.LT(1),n=this._input.LA(1),n===V.ADD||n===V.SUB?(this._input.LA(1)===Bi.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()):h._op=this._errHandler.recoverInline(this),this.state=33,this.expr(8)}break;case 3:{if(h=new e0(new de(p,x)),this.pushNewRecursionContext(h,r,V.RULE_expr),this.state=34,!this.precpred(this._ctx,6))throw this.createFailedPredicateException("this.precpred(this._ctx, 6)");this.state=35,h._op=this._input.LT(1),n=this._input.LA(1),(n&-32)===0&&(1<<n&(1<<V.EQ|1<<V.NEQ|1<<V.LTE|1<<V.GTE|1<<V.LT|1<<V.GT))!==0?(this._input.LA(1)===Bi.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()):h._op=this._errHandler.recoverInline(this),this.state=36,this.expr(7)}break}this.state=41,this._errHandler.sync(this),t=this.interpreter.adaptivePredict(this._input,4,this._ctx)}}}catch(t){if(t instanceof wi.RecognitionException)h.exception=t,this._errHandler.reportError(this,t),this._errHandler.recover(this,t);else throw t}finally{this.unrollRecursionContexts(p)}return h}args(){let a=new ma(this._ctx,this.state);this.enterRule(a,4,V.RULE_args);let p;try{for(this.enterOuterAlt(a,1),this.state=42,this.expr(0),this.state=47,this._errHandler.sync(this),p=this._input.LA(1);p===V.T__2;)this.state=43,this.match(V.T__2),this.state=44,this.expr(0),this.state=49,this._errHandler.sync(this),p=this._input.LA(1)}catch(x){if(x instanceof wi.RecognitionException)a.exception=x,this._errHandler.reportError(this,x),this._errHandler.recover(this,x);else throw x}finally{this.exitRule()}return a}sempred(a,p,x){switch(p){case 1:return this.expr_sempred(a,x)}return!0}expr_sempred(a,p){switch(p){case 0:return this.precpred(this._ctx,8);case 1:return this.precpred(this._ctx,7);case 2:return this.precpred(this._ctx,6)}return!0}static get _ATN(){return V.__ATN||(V.__ATN=new xa.ATNDeserializer().deserialize(Aa.toCharArray(V._serializedATN))),V.__ATN}};Q(V,"T__0",1),Q(V,"T__1",2),Q(V,"T__2",3),Q(V,"REFERENCE",4),Q(V,"REF",5),Q(V,"REFRANGE",6),Q(V,"BOOL",7),Q(V,"STRING",8),Q(V,"NUM",9),Q(V,"FUNCNAME",10),Q(V,"WS",11),Q(V,"MUL",12),Q(V,"DIV",13),Q(V,"ADD",14),Q(V,"SUB",15),Q(V,"EQ",16),Q(V,"NEQ",17),Q(V,"LTE",18),Q(V,"GTE",19),Q(V,"LT",20),Q(V,"GT",21),Q(V,"RULE_formula",0),Q(V,"RULE_expr",1),Q(V,"RULE_args",2),Q(V,"ruleNames",["formula","expr","args"]),Q(V,"_LITERAL_NAMES",[void 0,"'('","')'","','",void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,"'*'","'/'","'+'","'-'","'='","'<>'","'<='","'>='","'<'","'>'"]),Q(V,"_SYMBOLIC_NAMES",[void 0,void 0,void 0,void 0,"REFERENCE","REF","REFRANGE","BOOL","STRING","NUM","FUNCNAME","WS","MUL","DIV","ADD","SUB","EQ","NEQ","LTE","GTE","LT","GT"]),Q(V,"VOCABULARY",new _a.VocabularyImpl(V._LITERAL_NAMES,V._SYMBOLIC_NAMES,[])),Q(V,"_serializedATN",`ì¤ìªºÖê¾ºä½Øîªì5			

\r\v

\x07(
\f+\v\x070
\f3\v<	,\b
	\b
\v\v	\v\f\f\r\b\x07\f\x07\x07\x07\v\x07	\x07
\x07\x07\x1B\x07\x1B\r)\f
 	 (\v!"\f	"#	#(
$%\f\b%&	&(	''!'$(+)')**+),1-.\x07.0/-031/122\x0731\b\v')1`),Q(V,"__ATN");let Ae=V;class $c extends fo.ParserRuleContext{expr(a){return a===void 0?this.getRuleContexts(de):this.getRuleContext(a,de)}constructor(a,p){super(a,p)}get ruleIndex(){return Ae.RULE_formula}enterRule(a){a.enterFormula&&a.enterFormula(this)}exitRule(a){a.exitFormula&&a.exitFormula(this)}accept(a){return a.visitFormula?a.visitFormula(this):a.visitChildren(this)}}class de extends fo.ParserRuleContext{constructor(a,p){super(a,p)}get ruleIndex(){return Ae.RULE_expr}copyFrom(a){super.copyFrom(a)}}class Qc extends de{FUNCNAME(){return this.getToken(Ae.FUNCNAME,0)}args(){return this.tryGetRuleContext(0,ma)}constructor(a){super(a.parent,a.invokingState),this.copyFrom(a)}enterRule(a){a.enterFunction&&a.enterFunction(this)}exitRule(a){a.exitFunction&&a.exitFunction(this)}accept(a){return a.visitFunction?a.visitFunction(this):a.visitChildren(this)}}class Zc extends de{constructor(p){super(p.parent,p.invokingState);Q(this,"_op");this.copyFrom(p)}expr(p){return p===void 0?this.getRuleContexts(de):this.getRuleContext(p,de)}MUL(){return this.tryGetToken(Ae.MUL,0)}DIV(){return this.tryGetToken(Ae.DIV,0)}enterRule(p){p.enterMulDiv&&p.enterMulDiv(this)}exitRule(p){p.exitMulDiv&&p.exitMulDiv(this)}accept(p){return p.visitMulDiv?p.visitMulDiv(this):p.visitChildren(this)}}class Jc extends de{constructor(p){super(p.parent,p.invokingState);Q(this,"_op");this.copyFrom(p)}expr(p){return p===void 0?this.getRuleContexts(de):this.getRuleContext(p,de)}ADD(){return this.tryGetToken(Ae.ADD,0)}SUB(){return this.tryGetToken(Ae.SUB,0)}enterRule(p){p.enterAddSub&&p.enterAddSub(this)}exitRule(p){p.exitAddSub&&p.exitAddSub(this)}accept(p){return p.visitAddSub?p.visitAddSub(this):p.visitChildren(this)}}class e0 extends de{constructor(p){super(p.parent,p.invokingState);Q(this,"_op");this.copyFrom(p)}expr(p){return p===void 0?this.getRuleContexts(de):this.getRuleContext(p,de)}EQ(){return this.tryGetToken(Ae.EQ,0)}NEQ(){return this.tryGetToken(Ae.NEQ,0)}LT(){return this.tryGetToken(Ae.LT,0)}GT(){return this.tryGetToken(Ae.GT,0)}LTE(){return this.tryGetToken(Ae.LTE,0)}GTE(){return this.tryGetToken(Ae.GTE,0)}enterRule(p){p.enterComparison&&p.enterComparison(this)}exitRule(p){p.exitComparison&&p.exitComparison(this)}accept(p){return p.visitComparison?p.visitComparison(this):p.visitChildren(this)}}class t0 extends de{NUM(){return this.getToken(Ae.NUM,0)}constructor(a){super(a.parent,a.invokingState),this.copyFrom(a)}enterRule(a){a.enterNumber&&a.enterNumber(this)}exitRule(a){a.exitNumber&&a.exitNumber(this)}accept(a){return a.visitNumber?a.visitNumber(this):a.visitChildren(this)}}class r0 extends de{BOOL(){return this.getToken(Ae.BOOL,0)}constructor(a){super(a.parent,a.invokingState),this.copyFrom(a)}enterRule(a){a.enterBoolean&&a.enterBoolean(this)}exitRule(a){a.exitBoolean&&a.exitBoolean(this)}accept(a){return a.visitBoolean?a.visitBoolean(this):a.visitChildren(this)}}class n0 extends de{STRING(){return this.getToken(Ae.STRING,0)}constructor(a){super(a.parent,a.invokingState),this.copyFrom(a)}enterRule(a){a.enterStr&&a.enterStr(this)}exitRule(a){a.exitStr&&a.exitStr(this)}accept(a){return a.visitStr?a.visitStr(this):a.visitChildren(this)}}class i0 extends de{REFERENCE(){return this.getToken(Ae.REFERENCE,0)}constructor(a){super(a.parent,a.invokingState),this.copyFrom(a)}enterRule(a){a.enterReference&&a.enterReference(this)}exitRule(a){a.exitReference&&a.exitReference(this)}accept(a){return a.visitReference?a.visitReference(this):a.visitChildren(this)}}class o0 extends de{expr(){return this.getRuleContext(0,de)}constructor(a){super(a.parent,a.invokingState),this.copyFrom(a)}enterRule(a){a.enterParentheses&&a.enterParentheses(this)}exitRule(a){a.exitParentheses&&a.exitParentheses(this)}accept(a){return a.visitParentheses?a.visitParentheses(this):a.visitChildren(this)}}class ma extends fo.ParserRuleContext{expr(a){return a===void 0?this.getRuleContexts(de):this.getRuleContext(a,de)}constructor(a,p){super(a,p)}get ruleIndex(){return Ae.RULE_args}enterRule(a){a.enterArgs&&a.enterArgs(this)}exitRule(a){a.exitArgs&&a.exitArgs(this)}accept(a){return a.visitArgs?a.visitArgs(this):a.visitChildren(this)}}export{cl as F,Xh as a,Ae as b};
